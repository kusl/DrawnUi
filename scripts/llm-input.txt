
Path
----
C:\code\DrawnUi
On branch main
Your branch is ahead of 'upstream/main' by 5 commits.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   scripts/llm-input.txt

no changes added to commit (use "git add" and/or "git commit -a")
* remote upstream
  Fetch URL: https://github.com/taublast/DrawnUi.Breakout.git
  Push  URL: https://github.com/taublast/DrawnUi.Breakout.git
  HEAD branch: main
  Remote branches:
    bump-hot-preview-to-v0.15              tracked
    dev/bret/use-latest-hot-preview        tracked
    feature/sl-add-game-controller-support tracked
    main                                   tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (fast-forwardable)
Folder PATH listing
Volume serial number is BE05-6605
C:.
ª   .gitignore
ª   Breakout.sln
ª   DeleteBinObj.ps1
ª   README.md
ª   
+---.github
ª   +---workflows
ª           build-release.yml
ª           pr-validation.yml
ª           
+---art
ª   ª   icon.png
ª   ª   
ª   +---android
ª   ª       1.jpg
ª   ª       2.jpg
ª   ª       3.jpg
ª   ª       500.png
ª   ª       a.jpg
ª   ª       b.jpg
ª   ª       c.jpg
ª   ª       ic_launcher-playstore.png
ª   ª       iPad.jpg
ª   ª       raw.SCREENSHOTS
ª   ª       readme.txt
ª   ª       
ª   +---ios
ª           a.jpg
ª           b.png
ª           c.png
ª           ipad.png
ª           padHotpot.ai.url
ª           phoneHotpot.ai.url
ª           Screen1.jpg
ª           Screen3.jpg
ª           Screen4.jpg
ª           Simulator_Screenshot_iPad_Pro_13_inch_M4.png
ª           
+---documentation
ª       claude.md
ª       github-actions.md
ª       
+---scripts
ª       cat.ps1
ª       llm-input.txt
ª       
+---src
    ª   App.xaml
    ª   App.xaml.cs
    ª   Breakout.csproj
    ª   MainPage.cs
    ª   MainPage.HotPreview.cs
    ª   MauiProgram.cs
    ª   
    +---Game
    ª   ª   BreakoutGame.cs
    ª   ª   BreakoutGame.HotPreview.cs
    ª   ª   BreakoutGame.Input.cs
    ª   ª   BreakoutGame.Loop.cs
    ª   ª   BreakoutGame.Sound.cs
    ª   ª   BreakoutGame.Ui.cs
    ª   ª   BreakoutGame.Ui.Dialogs.cs
    ª   ª   BreakoutGameExtensions.cs
    ª   ª   
    ª   +---Ai
    ª   ª       AIDifficulty.cs
    ª   ª       AIPaddleController.cs
    ª   ª       
    ª   +---Controls
    ª   ª       DisplayFlag.cs
    ª   ª       GameSwitch.cs
    ª   ª       HudArrows.cs
    ª   ª       OptionWithTappable.cs
    ª   ª       SelectableGameButton.cs
    ª   ª       StableCacheLayout.cs
    ª   ª       
    ª   +---Dev
    ª   ª       Test.cs
    ª   ª       
    ª   +---Dialogs
    ª   ª       DialogAnimations.cs
    ª   ª       Dialogs.md
    ª   ª       DialogTemplate.cs
    ª   ª       DialogThemes.cs
    ª   ª       GameDialog.cs
    ª   ª       
    ª   +---Input
    ª   ª       EventType.cs
    ª   ª       GameControllerInput.cs
    ª   ª       GameKey.cs
    ª   ª       HudController.cs
    ª   ª       IGameKeyHandler.cs
    ª   ª       IInputController.cs
    ª   ª       
    ª   +---Internals
    ª   ª       CollisionFace.cs
    ª   ª       COLLISION_SYSTEMS.md
    ª   ª       GameState.cs
    ª   ª       IReusableSprite.cs
    ª   ª       IWithHitBox.cs
    ª   ª       MauiGameExtensions.cs
    ª   ª       RaycastCollision.cs
    ª   ª       
    ª   +---Levels
    ª   ª       BrickPosition.cs
    ª   ª       BrickPreset.cs
    ª   ª       BrickPresets.cs
    ª   ª       FormationType.cs
    ª   ª       LevelManager.cs
    ª   ª       PowerUpType.cs
    ª   ª       
    ª   +---Sound
    ª   ª       AudioMixerService.cs
    ª   ª       GameAudioSource.cs
    ª   ª       IAudioService.cs
    ª   ª       MemoryAudioSource.cs
    ª   ª       SoundFlowAudioService.cs
    ª   ª       StreamingAudioSource.cs
    ª   ª       
    ª   +---Sprites
    ª           BallSprite.cs
    ª           BrickSprite.cs
    ª           BulletSprite.cs
    ª           LifeSprite.cs
    ª           PaddleSprite.cs
    ª           PowerupSprite.cs
    ª           
    +---Helpers
    ª       AppFonts.cs
    ª       AppLanguage.cs
    ª       AppSettings.cs
    ª       HotPreview.cs
    ª       
    +---Platforms
    ª   +---Android
    ª   ª   ª   AndroidManifest.xml
    ª   ª   ª   MainActivity.cs
    ª   ª   ª   MainApplication.cs
    ª   ª   ª   
    ª   ª   +---Resources
    ª   ª       +---mipmap-anydpi-v26
    ª   ª       ª       ic_launcher.xml
    ª   ª       ª       ic_launcher_round.xml
    ª   ª       ª       
    ª   ª       +---mipmap-hdpi
    ª   ª       ª       ic_launcher.webp
    ª   ª       ª       ic_launcher_foreground.webp
    ª   ª       ª       ic_launcher_round.webp
    ª   ª       ª       
    ª   ª       +---mipmap-mdpi
    ª   ª       ª       ic_launcher.webp
    ª   ª       ª       ic_launcher_foreground.webp
    ª   ª       ª       ic_launcher_round.webp
    ª   ª       ª       
    ª   ª       +---mipmap-xhdpi
    ª   ª       ª       ic_launcher.webp
    ª   ª       ª       ic_launcher_foreground.webp
    ª   ª       ª       ic_launcher_round.webp
    ª   ª       ª       
    ª   ª       +---mipmap-xxhdpi
    ª   ª       ª       ic_launcher.webp
    ª   ª       ª       ic_launcher_foreground.webp
    ª   ª       ª       ic_launcher_round.webp
    ª   ª       ª       
    ª   ª       +---mipmap-xxxhdpi
    ª   ª       ª       ic_launcher.webp
    ª   ª       ª       ic_launcher_foreground.webp
    ª   ª       ª       ic_launcher_round.webp
    ª   ª       ª       
    ª   ª       +---values
    ª   ª               colors.xml
    ª   ª               ic_launcher_background.xml
    ª   ª               styles.xml
    ª   ª               
    ª   +---iOS
    ª   ª   ª   AppDelegate.cs
    ª   ª   ª   Info.plist
    ª   ª   ª   Program.cs
    ª   ª   ª   
    ª   ª   +---Assets.xcassets
    ª   ª   ª   +---icon.appiconset
    ª   ª   ª           Contents.json
    ª   ª   ª           Icon1024.png
    ª   ª   ª           Icon120.png
    ª   ª   ª           Icon152.png
    ª   ª   ª           Icon167.png
    ª   ª   ª           Icon180.png
    ª   ª   ª           Icon20.png
    ª   ª   ª           Icon29.png
    ª   ª   ª           Icon40.png
    ª   ª   ª           Icon58.png
    ª   ª   ª           Icon60.png
    ª   ª   ª           Icon76.png
    ª   ª   ª           Icon80.png
    ª   ª   ª           Icon87.png
    ª   ª   ª           
    ª   ª   +---Resources
    ª   ª           PrivacyInfo.xcprivacy
    ª   ª           
    ª   +---MacCatalyst
    ª   ª       AppDelegate.cs
    ª   ª       Entitlements.plist
    ª   ª       Info.plist
    ª   ª       Program.cs
    ª   ª       
    ª   +---Tizen
    ª   ª       Main.cs
    ª   ª       tizen-manifest.xml
    ª   ª       
    ª   +---Windows
    ª           app.manifest
    ª           App.xaml
    ª           App.xaml.cs
    ª           Package.appxmanifest
    ª           
    +---Properties
    ª       launchSettings.json
    ª       
    +---Resources
        ª   Svg.xaml
        ª   
        +---AppIcon
        ª       appicon.svg
        ª       appiconfg.svg
        ª       
        +---Fonts
        ª       amstrad_cpc464.ttf
        ª       BlackHanSans-Regular.ttf
        ª       DelaGothicOne-Regular.ttf
        ª       MaShanZheng-Regular.ttf
        ª       ZenMaruGothic-Bold.ttf
        ª       
        +---Images
        ª       dotnet_bot.png
        ª       
        +---Raw
        ª   ª   AboutAssets.txt
        ª   ª   
        ª   +---Fx
        ª   ª       ballout.mp3
        ª   ª       bells1.mp3
        ª   ª       bricksynth.wav
        ª   ª       powerup27.mp3
        ª   ª       quirky26.mp3
        ª   ª       quirky7.mp3
        ª   ª       synthchime2.mp3
        ª   ª       
        ª   +---Images
        ª   ª       back.jpg
        ª   ª       glass.jpg
        ª   ª       tile.png
        ª   ª       tile2.png
        ª   ª       tile3.png
        ª   ª       tile4.png
        ª   ª       
        ª   +---Music
        ª   ª       demoHypnoticPuzzle4.mp3
        ª   ª       lvl1PixelCityGroovin.mp3
        ª   ª       MonkeyDrama.mp3
        ª   ª       TechnoTronic.mp3
        ª   ª       
        ª   +---Sounds
        ª           bip.mp3
        ª           bip.wav
        ª           bip1.wav
        ª           bip2.wav
        ª           brickglass.wav
        ª           bricksynth2.wav
        ª           bricksynth3.wav
        ª           gamestart.wav
        ª           kill.wav
        ª           one.wav
        ª           pong.wav
        ª           tik.wav
        ª           two.wav
        ª           
        +---Splash
        ª       splash.svg
        ª       
        +---Strings
        ª       ResStrings.de.resx
        ª       ResStrings.Designer.cs
        ª       ResStrings.es.resx
        ª       ResStrings.fr.resx
        ª       ResStrings.it.resx
        ª       ResStrings.ja.resx
        ª       ResStrings.ko.resx
        ª       ResStrings.resx
        ª       ResStrings.ru.resx
        ª       ResStrings.zh.resx
        ª       
        +---Styles
                Colors.xaml
                Styles.xaml
                

=== SLN FILE ===

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.35906.104
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Breakout", "src\Breakout.csproj", "{36E49A86-2263-FA52-3C95-98957BFF8B03}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{8EC462FD-D22E-90A8-E5CE-7E832BA40C5D}"
	ProjectSection(SolutionItems) = preProject
		.gitignore = .gitignore
		README.md = README.md
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Debug|Any CPU.Deploy.0 = Debug|Any CPU
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Release|Any CPU.Build.0 = Release|Any CPU
		{36E49A86-2263-FA52-3C95-98957BFF8B03}.Release|Any CPU.Deploy.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0D7B9789-07CE-492A-9DC4-C9823A73B2B6}
	EndGlobalSection
EndGlobal

=== CSPROJ FILES ===

--- C:\code\DrawnUi\src\Breakout.csproj ---
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>

    <!--<TargetFrameworks>net9.0-android;</TargetFrameworks>-->
    <!--<TargetFrameworks>net9.0-ios;</TargetFrameworks>-->
    <!--<TargetFrameworks>net9.0-windows10.0.19041.0</TargetFrameworks>-->

    <TargetFrameworks>net9.0-android;net9.0-ios;net9.0-maccatalyst</TargetFrameworks>
    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(TargetFrameworks);net9.0-windows10.0.19041.0</TargetFrameworks>

    <OutputType>Exe</OutputType>
    <RootNamespace>Breakout</RootNamespace>
    <UseMaui>true</UseMaui>
    <SingleProject>true</SingleProject>
    <ImplicitUsings>enable</ImplicitUsings>

    <!-- Display name -->
    <ApplicationTitle>Bricks Breaker</ApplicationTitle>
    
    <!-- App Identifier -->
    <ApplicationId>com.appomobi.drawnui.breakout</ApplicationId>
    <ApplicationIdGuid>230e07b0-ebc2-4fde-9ac8-074d3c3d69a9</ApplicationIdGuid>

    <!-- Versions -->
    <ApplicationDisplayVersion>1.0</ApplicationDisplayVersion>
    <ApplicationVersion>1</ApplicationVersion>

    <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'ios'">15.0</SupportedOSPlatformVersion>
    <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'maccatalyst'">15.2</SupportedOSPlatformVersion>
    <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'android'">21.0</SupportedOSPlatformVersion>
    <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.19041.0</SupportedOSPlatformVersion>
    <TargetPlatformMinVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.19041.0</TargetPlatformMinVersion>
    <WindowsPackageType>None</WindowsPackageType>
  </PropertyGroup>

  <!-- Custom Android icons: workaround for MAUI Android bug not including webp resources-->
  <ItemGroup Condition="$(TargetFramework.Contains('android'))">
    <AndroidResource Include="Platforms\Android\Resources\**\*.webp" />
  </ItemGroup>

  <!--Custom iOS icons-->
  <ItemGroup Condition="$(TargetFramework.Contains('ios')) == true">
    <BundleResource Include="Platforms\iOS\Assets.xcassets\**\*" />
  </ItemGroup>

  <ItemGroup>

    <!-- App Icon, ios and android will override this with our custom icons -->
    <MauiIcon Include="Resources\AppIcon\appicon.svg" ForegroundFile="Resources\AppIcon\appiconfg.svg" ForegroundScale="0.8" Color="#212529" />

		<!-- Splash Screen -->
		<MauiSplashScreen Include="Resources\Splash\splash.svg" Color="#212529" BaseSize="120,120" />

		<!-- Images -->
		<MauiImage Include="Resources\Images\*" />
		<MauiImage Update="Resources\Images\dotnet_bot.png" Resize="True" BaseSize="300,185" />

		<!-- Custom Fonts -->
		<MauiFont Include="Resources\Fonts\*" />

		<!-- Raw Assets (also remove the "Resources\Raw" prefix) -->
		<MauiAsset Include="Resources\Raw\**" LogicalName="%(RecursiveDir)%(Filename)%(Extension)" />
	</ItemGroup>

  <!--dev provisioning for iPhone-->
  <Import Project="../../Breakout.targets" Condition="Exists('../../Breakout.targets')" />

  <!--DEBUG-->
  <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
    <ProvisioningType>manual</ProvisioningType>
  </PropertyGroup>

  <ItemGroup>
    <None Include="..\README.md" Link="README.md" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="DrawnUi.Maui.Game" Version="1.6.2.27" />
    <!--can replace this with usual plugin if PR is merged-->
    <PackageReference Include="AppoMobi.Preview.Plugin.Maui.Audio" Version="3.0.2.1-pre1" />
    <PackageReference Include="Bijington.Orbit.Input" Version="0.2.2-preview.1" />
    <PackageReference Include="Microsoft.Maui.Controls" Version="9.0.70" />
		<PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup Condition="$(TargetFramework.Contains('android'))">
    <PackageReference Include="SoundFlow" Version="1.1.1" />
  </ItemGroup>

  <!--https://github.com/BretJohnson/hot-preview-->
  <!-- !!! uncomment this if you install dotnet tool hotpreviews !!! -->
  <!--<ItemGroup Condition="$(Configuration) == 'Debug'">
    <PackageReference Include="HotPreview.App.Maui" Version="0.14.31" />
  </ItemGroup>-->

  <!--for development-->
  <!--<ItemGroup>
    <ProjectReference Include="..\..\DrawnUi.Maui\src\Maui\DrawnUi\DrawnUi.Maui.csproj" />
    <ProjectReference Include="..\..\DrawnUi.Maui\src\Maui\Addons\DrawnUi.Maui.Game\DrawnUi.Maui.Game.csproj" />
  </ItemGroup>-->

  <ItemGroup>
    <Compile Update="Resources\Strings\ResStrings.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ResStrings.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="Resources\Strings\ResStrings.resx">
      <LastGenOutput>ResStrings.Designer.cs</LastGenOutput>
      <Generator>PublicResXFileCodeGenerator</Generator>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <MauiFont Include="Helpers\AppFonts.cs" />
  </ItemGroup>

</Project>

=== CS FILES ===

--- C:\code\DrawnUi\src\App.xaml.cs ---
using AppoMobi.Specials;
using Breakout.Helpers;


namespace Breakout;

public partial class App : Application
{
    public App()
    {
        InitializeComponent();

#if ANDROID
    Super.SetNavigationBarColor(Colors.Black, Colors.Black, false);    
#endif

#if PREVIEWS
        PreviewService.Initialize();
#endif
    }

    protected override Window CreateWindow(IActivationState? activationState)
    {
        return new Window(new NavigationPage(new MainPage()));
    }

    protected override void OnStart()
    {
        base.OnStart();

        Tasks.StartDelayed(TimeSpan.FromSeconds(3),
            () => { Dispatcher.Dispatch(() => { DeviceDisplay.Current.KeepScreenOn = true; }); });
    }

    protected override void OnSleep()
    {
        base.OnSleep();

        Dispatcher.Dispatch(() => { DeviceDisplay.Current.KeepScreenOn = false; });
    }

    protected override void OnResume()
    {
        base.OnResume();

        Dispatcher.Dispatch(() => { DeviceDisplay.Current.KeepScreenOn = true; });
    }
}

--- C:\code\DrawnUi\src\MainPage.cs ---
using Breakout.Game.Dialogs;
using DrawnUi.Controls;
using DrawnUi.Views;
using System.Globalization;
using Breakout;
#if PREVIEWS
using HotPreview;
#endif

namespace Breakout.Game
{
    public partial class MainPage : BasePageReloadable
    {
        public MainPage()
        {
            BackgroundColor = Colors.Black; //iOS statusbar and bottom insets

            Instance = this; // To change of this instance, to be accessed from AppLanguage helper

            AppLanguage.ApplySelected();
        }

        //for AppLanguage etc access
        public static MainPage Instance;

        //for previews
        public static SkiaViewSwitcher? ViewsContainer;

        Canvas Canvas;

        // This is called by constructor and .NET HotReload
        public override void Build()
        {
            Canvas?.Dispose();

            Canvas = new RescalingCanvas()
            {
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                Gestures = GesturesMode.Lock,
                RenderingMode = RenderingModeType.Accelerated,
                BackgroundColor = Colors.Black,

                Content = new SkiaLayer()
                {
                    Children =
                    {
                        //WALLPAPER
                        new SkiaImage(@"Images/back.jpg")
                        {
                            UseCache = SkiaCacheType.Image,
                            AddEffect = SkiaImageEffect.Darken,
                            Darken = 0.2
                        }.Fill(),

                        //MAIN VIEW
                        new SkiaViewSwitcher()
                        {
                            HorizontalOptions = LayoutOptions.Center,
                            WidthRequest = 360,
                            HeightRequest = 760,
                            VerticalOptions = LayoutOptions.Center,
                            SelectedIndex = 0,
                            Children =
                            {
                                new Game.BreakoutGame(),
                            }
                        }.Assign(out ViewsContainer),
#if NEED_DEBUG
                        new SkiaLabelFps()
                        {
                            Margin = new(0, 0, 4, 24),
                            VerticalOptions = LayoutOptions.End,
                            HorizontalOptions = LayoutOptions.End,
                            Rotation = -45,
                            FontSize = 11,
                            BackgroundColor = Colors.DarkRed,
                            TextColor = Colors.White,
                            ZIndex = 110,
                        }
#endif
                    }
                }.Fill()
            };
#if IOS
            this.Content = new Grid() //using grid wrapper to take apply safe insets on ios, other platforms use different logic
            {
                Children = { Canvas }
            };
#else
            this.Content = Canvas;
#endif
        }

#if PREVIEWS
        [AutoGeneratePreview(false)]
#endif
        public class RescalingCanvas : Canvas
        {
            public float GameScale { get; set; } = 1;

            protected override void Draw(DrawingContext context)
            {
                var wantedHeight = Breakout.Game.BreakoutGame.HEIGHT * context.Scale;
                var wantedWidth = Breakout.Game.BreakoutGame.WIDTH * context.Scale;

                var scaleWidth = this.DrawingRect.Width / wantedWidth;
                var scaleHeight = this.DrawingRect.Height / wantedHeight;

                GameScale = Math.Min(scaleWidth, scaleHeight);

                context.Scale *= GameScale;

                base.Draw(context);
            }
        }
    }
}

--- C:\code\DrawnUi\src\MainPage.HotPreview.cs ---
#if PREVIEWS

using Breakout.Game.Dialogs;
using DrawnUi.Controls;
using DrawnUi.Views;
using HotPreview;

namespace Breakout.Game
{


    public partial class MainPage : BasePageReloadable
    {
        #region DIALOGS

        [Preview]
        public static void Dialog_Options() => GameAction(x => x.ShowOptions());

        #endregion

        [Preview]
        public static void State_Welcome() => ApplyPreviewState(new PreviewAppState() { GameState = GameState.Ready });

        [Preview]
        public static void State_Playing() => ApplyPreviewState(new PreviewAppState() { GameState = GameState.Playing });

        [Preview]
        public static void State_Paused() => ApplyPreviewState(new PreviewAppState() { GameState = GameState.Paused });

        [Preview]
        public static void State_Level_Complete() =>
            ApplyPreviewState(new PreviewAppState() { GameState = GameState.LevelComplete });
        
        [Preview]
        public static void State_Game_Lost() => GameAction(x => x.GameLost());

        [Preview]
        public static void State_Game_Complete() => GameAction(x => x.GameComplete());

        [Preview]
        public static void DemoPlay() => ApplyPreviewState(new PreviewAppState() { GameState = GameState.DemoPlay });

        [Preview]
        public static void Level_1() => GameAction(x => x.StartNewLevel(1));

        [Preview]
        public static void Level_2() => GameAction(x=>x.StartNewLevel(2));

        [Preview]
        public static void Level_3() => GameAction(x => x.StartNewLevel(3));

        [Preview]
        public static void Level_4() => GameAction(x => x.StartNewLevel(4));

        [Preview]
        public static void Level_5() => GameAction(x => x.StartNewLevel(5));

        [Preview]
        public static void Level_6() => GameAction(x => x.StartNewLevel(6));

        [Preview]
        public static void Level_7() => GameAction(x => x.StartNewLevel(7));

        [Preview]
        public static void Level_8() => GameAction(x => x.StartNewLevel(8));

        [Preview]
        public static void Level_9() => GameAction(x => x.StartNewLevel(9));

        [Preview]
        public static void Level_10() => GameAction(x => x.StartNewLevel(10));

        [Preview]
        public static void Level_11() => GameAction(x => x.StartNewLevel(11));

        [Preview]
        public static void Level_12() => GameAction(x => x.StartNewLevel(12));
 

        #region SPRITES

        [Preview]
        public static void Sprite_Paddle() => Preview(new PaddleSprite(), "Paddle sprite has initial position X-Center, Y-End");

        [Preview]
        public static void Sprite_Ball() => Preview(new BallSprite(), "Ball sprite has initial position X-Center, Y-End");

        [Preview]
        public static void Sprite_Brick() => Preview( BrickSprite.Create(), "Brick sprite has initial position X-Start, Y-Start");

        #endregion

        #region LANGUAGE

        [PreviewCommand]
        public static void Language_EN() => AppLanguage.SetAndApply("en");

        [PreviewCommand]
        public static void Language_DE() => AppLanguage.SetAndApply("de");

        [PreviewCommand]
        public static void Language_ES() => AppLanguage.SetAndApply("es");

        [PreviewCommand]
        public static void Language_FR() => AppLanguage.SetAndApply("fr");

        [PreviewCommand]
        public static void Language_RU() => AppLanguage.SetAndApply("ru");

        [PreviewCommand]
        public static void Language_IT() => AppLanguage.SetAndApply("it");

        [PreviewCommand]
        public static void Language_JA() => AppLanguage.SetAndApply("ja");

        [PreviewCommand]
        public static void Language_KO() => AppLanguage.SetAndApply("ko");

        [PreviewCommand]
        public static void Language_ZH() => AppLanguage.SetAndApply("zh");

        #endregion

        public static SkiaLayout CreatePreviewWrapper(SkiaControl control, string comments)
        {
            return new SkiaStack()
            {
                Spacing = 0,
                BackgroundColor = Colors.DarkGrey,
                VerticalOptions = LayoutOptions.Fill,
                Children =
                {
                    // navbar
                    new SkiaLayer()
                    {
                        HeightRequest = 44,
                        UseCache = SkiaCacheType.Operations,
                        BackgroundColor = Colors.Black,
                        Children =
                        {
                            new SkiaRichLabel($"← {ResStrings.BtnGoBack}")
                                {
                                    FontSize = 16,
                                    VerticalOptions = LayoutOptions.Center,
                                    Padding = new(16, 0),
                                    UseCache = SkiaCacheType.Operations
                                }
                                .OnTapped(me => { _ = ViewsContainer?.PopPage(); })
                        }
                    },

                    control,

                    //overlay
                    new SkiaRichLabel(comments)
                    {
                        Opacity = 0.5,
                        FontSize = 16,
                        VerticalOptions = LayoutOptions.Center,
                        HorizontalOptions = LayoutOptions.Fill,
                        HorizontalTextAlignment = DrawTextAlignment.Center,
                        Margin = new (32),
                        Padding = new(12),
                        BackgroundColor = Color.Parse("#22000000"),
                        TextColor = Colors.White,
                        UseCache = SkiaCacheType.Operations
                    },

                }
            };
        }

        private static void Preview(SkiaControl control, string comments = null)
        {
            if (ViewsContainer != null)
            {
                ViewsContainer.PushView(CreatePreviewWrapper(control, comments), true, false);
            }
        }

        private static void GameAction(Action<BreakoutGame> action)
        {
            var breakoutGame = BreakoutGame.Instance ??
                               throw new InvalidOperationException("BreakoutGame isn't initialized");

            _ = GameDialog.PopAllAsync(breakoutGame);

            action?.Invoke(breakoutGame);
        }

        private static void ApplyPreviewState(PreviewAppState previewAppState)
        {
            var breakoutGame = BreakoutGame.Instance ??
                               throw new InvalidOperationException("BreakoutGame isn't initialized");

            breakoutGame.ApplyPreviewState(previewAppState);
        }
    }

}

#endif

--- C:\code\DrawnUi\src\MauiProgram.cs ---
global using DrawnUi.Draw;
global using DrawnUi.Gaming;
global using Breakout.Game;
global using Breakout.Resources.Fonts;
global using Breakout.Resources.Strings;
using Microsoft.Extensions.Logging;
using Orbit.Input;
using Plugin.Maui.Audio;

namespace Breakout;

public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp<App>()
            .AddAppFonts()
            .AddAudio() //Plugin.Maui.Audio
            .UseOrbitGameController(options => { }) //Game controller support
            .UseDrawnUi(new()
            {
                UseDesktopKeyboard = true,
                DesktopWindow = new()
                {
#if WINDOWS
                    Width = BreakoutGame.WIDTH + 15,
                    Height = BreakoutGame.HEIGHT + 40,
#else
                    Width = BreakoutGame.WIDTH,
                    Height = BreakoutGame.HEIGHT,
#endif
                }
            });

        //to avoid returning many copies of same sprite bitmap for different images
        SkiaImageManager.ReuseBitmaps = true;

#if DEBUG
        builder.Logging.AddDebug();
#endif

        return builder.Build();
    }

    public static bool IsDebug
    {
        get
        {
#if DEBUG
            return true;
#else
            return false;
#endif
        }
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.cs ---
using AppoMobi.Maui.Gestures;
using AppoMobi.Specials;
using Breakout.Game.Ai;
using Breakout.Game.Dialogs;
using SkiaSharp;
using System.Diagnostics;
using System.Numerics;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using static Breakout.Game.BreakoutGame;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region CONSTANTS

        public const int WIDTH = 360;
        public const int HEIGHT = 760;

        public const float BALL_SPEED = 375f;
        public const float POWERUP_SPEED = 120;
        public const float PADDLE_SPEED = 475;
        public const float PADDLE_WIDTH = 80;
        public const int MAX_BRICKS_COLUMNS = 8;
        public const int MAX_BRICKS_ROWS = 15;
        public const int MAX_BRICKS = MAX_BRICKS_COLUMNS * MAX_BRICKS_ROWS + 1;
        public const int MIN_BRICKS_ROWS = 3;
        public const float SPACING_BRICKS = 3f;
        public const float BRICKS_SIDE_MARGIN = 16f;

        public const int LIVES = 3;
        private const double POWERUP_SPAWN_COOLDOWN_SECONDS = 0.2;

        public const int MAXLVL = 12;
        public const int DEMO_MAXLVL = 3;
        public const int POWERUP_MAX_BULLETS = 10;
        public const int POWERUP_DURATION = 10;

        public const int MAX_POWERUPS_IN_POOL = 12;
        public const int MAX_BULLETS_IN_POOL = 64;
        public const int MAX_BALLS_IN_POOL = 8;

        /// <summary>
        /// For long running profiling
        /// </summary>
        const bool CHEAT_INVULNERABLE = false;

        public static bool USE_SOUND = true;

        public static bool USE_SOUND_IN_DEMO = false;

        /// <summary>
        /// Compile-time flag to enable raycasting collision detection instead of AABB intersection
        /// AABB works ok on desktops, but on mobile with frame drops better to use raycasting.
        /// </summary>
        public static bool USE_RAYCAST_COLLISION = true;

        #endregion

        #region INITIALIZE

        private AIPaddleController _aiController;
        public AIPaddleController AIController => _aiController ??= new AIPaddleController(this, AIDifficulty.Medium);

        public IAudioService? _audioService;

        public BreakoutGame()
        {
            CreateUi();

#if ANDROID
            //prefer skipping frames than go smooth because this game is dynamic
            MauiGame.FrameInterpolatorDisabled = true;
#endif

            BindingContext = this;

            Instance = this;

            InitializeInput();

            InitDialogs();

            if (USE_SOUND)
            {
                _ = InitializeAudioAsync();
            }

            _aiController = new AIPaddleController(this, AIDifficulty.Hard);


            //pause/resume loop background music etc
            Super.OnNativeAppResumed += Super_OnNativeAppResumed;
            Super.OnNativeAppPaused += Super_OnNativeAppPaused;
        }

        #endregion

        public override void OnWillDisposeWithChildren()
        {
            Super.OnNativeAppResumed += Super_OnNativeAppResumed;

            Super.OnNativeAppPaused += Super_OnNativeAppPaused;

            _audioService?.Dispose();

            foreach (var inputController in InputControllers)
            {
                inputController.Dispose();
            }

            base.OnWillDisposeWithChildren();
        }

        private void Super_OnNativeAppPaused(object sender, EventArgs e)
        {
            Pause();
        }

        private void Super_OnNativeAppResumed(object sender, EventArgs e)
        {
            Resume();
        }

        /// <summary>
        /// So it can get paused/resumed from anywhere in the app
        /// </summary>
        public static BreakoutGame Instance { get; set; }

        protected override void OnBindingContextChanged()
        {
            base.OnBindingContextChanged();

            BindingContext = this; //insist in case parent view might set its own
        }

        protected override void OnLayoutReady()
        {
            base.OnLayoutReady();

            Task.Run(async () =>
            {
                while (Superview == null || !Superview.HasHandler)
                {
                    await Task.Delay(30);
                }

                //we have some GPU cache used so we need the canvas to be fully created before we would start
                Prepare(); //game loop will be started inside
            }).ConfigureAwait(false);
        }

        bool _appeared;

        public override void OnAppeared()
        {
            base.OnAppeared();

            Tasks.StartDelayed(TimeSpan.FromSeconds(1), () =>
            {
                //our dialog has a transparent background that is blurring pixels under
                //so we have 2 options:
                //A - do not cache the backdrop and blur underground pixels in realtime
                //B - cache the backdrop but blur after the content below was rendered, so we implement the hack below, knowing our blurred background will be static as we show it only during pauses.

                _appeared = true;
                //OnPropertyChanged(nameof(ShowDialog));
            });
        }

        void Prepare()
        {
            if (!Superview.HasHandler || _initialized)
                return;

            RndExtensions.RandomizeTime(); //amstrad cpc forever

            IgnoreChildrenInvalidations = true;

            // in case we implement key press 
            Focus();

            _initialized = true;

            // Pool bricks for reuse
            for (int i = 0; i < MAX_BRICKS; i++)
            {
                AddToPoolBrickSprite();
            }

            // Pool powerups for reuse
            for (int i = 0; i < MAX_POWERUPS_IN_POOL; i++)
            {
                AddToPoolPowerupSprite();
            }

            // Pool paddle bullets for reuse
            for (int i = 0; i < MAX_BULLETS_IN_POOL; i++)
            {
                AddToPoolPaddleBulletSprite();
            }

            // Pool balls for multiball powerup
            for (int i = 0; i < MAX_BALLS_IN_POOL; i++)
            {
                AddToPoolBallSprite();
            }

            // Set initial timestamp
            //LastFrameTimeNanos = SkiaControl.GetNanoseconds();
            //ResetGame();

            _needPrerender = true;

            _initialized = true;

            PresentGame();
        }

        protected override void Draw(DrawingContext context)
        {
            base.Draw(context);

            if (_needPrerender)
            {
                //prerender or precompile something like shaders etc
                // ...

                _needPrerender = false;

                //Tasks.StartDelayed(TimeSpan.FromSeconds(1), () =>
                //{
                //    StartNewGameDemo();
                //});
            }

            //if (Ball != null)
            //{
            //    Trace.WriteLine($"-------------");
            //    Trace.WriteLine($"BALL {Ball.GetPositionOnCanvas()}");
            //    Trace.WriteLine($"BALL {Ball.RenderedNode.HitBoxWithTransforms.Pixels.Location}");
            //    Trace.WriteLine($"-------------");
            //    //Trace.WriteLine($"PADDLE {Paddle.GetPositionOnCanvas()}");
            //}
        }

        #region ACTIONS

        private BrickSprite AddBrickToContainer(string presetId, int col, int row,
            float brickWidth, float brickHeight, float margin)
        {
            var preset = BrickPresets.Presets[presetId];
            if (BricksPool.Count > 0)
            {
                var brick = BricksPool.Get();
                if (brick != null)
                {
                    brick.IsActive = true;
                    brick.WidthRequest = brickWidth;
                    brick.HeightRequest = brickHeight;

                    // Position relative to container (0,0)
                    float xPos = col * (brickWidth + margin);
                    float yPos = row * (brickHeight + margin);
                    brick.Left = xPos;
                    brick.Top = yPos;

                    brick.Preset = preset;
                    brick.BackgroundColor = preset.BackgroundColor;
                    brick.SupplementaryHitsToDestroy = preset.SupplementaryHitsToDestroy;
                    brick.Undestructible = preset.Undestructible;

                    // Add to container instead of main field
                    _spritesToBeAdded.Add(brick);
                    return brick;
                }
            }
            else
            {
                Super.Log("[FATAL] Out of bricks in the pool, check what you done wrong!!!");
            }

            return null;
        }

        private void AddBrick(string presetId, int col, int row,
            float brickWidth, float brickHeight, float margin, float offsetX, float offsetY)
        {
            var preset = BrickPresets.Presets[presetId];
            if (BricksPool.Count > 0)
            {
                var brick = BricksPool.Get();
                if (brick != null)
                {
                    brick.IsActive = true;
                    brick.WidthRequest = brickWidth;
                    brick.HeightRequest = brickHeight;
                    float xPos = margin + col * (brickWidth + margin);
                    float yPos = margin + row * (brickHeight + margin);
                    brick.Left = offsetX + xPos;
                    brick.Top = yPos + offsetY;

                    brick.BackgroundColor = preset.BackgroundColor;
                    brick.SupplementaryHitsToDestroy = preset.SupplementaryHitsToDestroy;
                    brick.Undestructible = preset.Undestructible;

                    brick.ResetAnimationState();
                    _spritesToBeAdded.Add(brick);
                }
            }
        }

        public LevelManager LevelManager { get; set; }
        public int BricksLeftToBreak { get; set; }

        void LevelComplete()
        {
            if (_levelCompletionPrompt)
            {
                return;
            }

            _levelCompletionPrompt = true;

            // Store current game state before changing levels
            // Note: State is already GameState.LevelComplete at this point, so check PreviousState
            var wasInDemoMode = PreviousState == GameState.DemoPlay;

            if (wasInDemoMode)
            {
                // In demo mode, auto-continue to next level without showing dialog
                if (Level < DEMO_MAXLVL)
                {
                    Level++;
                }
                else
                {
                    Level = 1; // Loop back to level 1 in demo mode
                }

                // Auto-continue demo mode
                StartNewLevel();
                State = GameState.DemoPlay;
                StartLoop();
            }
            else
            {
                // Normal mode - show level complete dialog
                if (Level < MAXLVL)
                {
                    Level++;
                    ShowLevelCompleteDialog();
                }
                else
                {
                    GameComplete();
                }
            }
        }

        public async void GameComplete()
        {
            PlaySound(Sound.Joy);

            var levelCompleteContent =
                UiElements.DialogPrompt(string.Format(ResStrings.MessageGameComplete, Score));

            if (await GameDialog.ShowAsync(this, levelCompleteContent, ResStrings.BtnOk.ToUpperInvariant()))
            {
                //todo can show credits or something

                StartDemoMode();
                ShowWelcomeDialog();
            }
        }

        /// <summary>
        /// Called when out of lives
        /// </summary>
        public void GameLost()
        {
            State = GameState.Ended;

            Tasks.StartDelayed(TimeSpan.FromMilliseconds(150), () =>
            {
                //PlaySound(Sound.SomethingTerrible);
                ShowGameOverDialog();
            });
        }

        private int CollectedPowerUps;
        private int CollectedPowerUpsSpeedy;
        private int BulletsAvailable;

        // Powerup spawn timing control
        private DateTime _lastPowerupSpawnTime = DateTime.MinValue;

        /// <summary>
        /// Start a precise level number in player mode
        /// </summary>
        /// <param name="level"></param>
        public void StartNewLevel(int level)
        {
            _ = GameDialog.PopAllAsync(this);
            Level = level;
            State = GameState.Unset;
            StartNewLevel();
        }

        void StartNewLevel()
        {
            if (LevelManager == null)
            {
                return;
            }

            _levelCompletionPrompt = false;
            _levelCompletionPending = 0;

            ClearSpritesOnBoard();
            ProcessSpritesToBeRemoved();

            ResetPaddle();

            // Then set ball properties for all active balls

            // Set formation and presets based on level
            FormationType formation;
            List<string> allowedPresets = null;

            switch (Level)
            {
                case 1:
                    // Level 1: Simple grid with basic bricks
                    formation = FormationType.Grid;
                    allowedPresets = new List<string>
                    {
                        "Standard_Red",
                        "Standard_Blue",
                        "Standard_Green",
                        "Standard_Orange",
                        "Standard_Yellow"
                    };
                    break;

                case 2:
                    // Level 2: Arch formation with some reinforced bricks
                    formation = FormationType.Arch;
                    allowedPresets = new List<string>
                    {
                        "Standard_Red",
                        "Standard_Blue",
                        "Standard_Green",
                        "Standard_Orange",
                        "Standard_Yellow",
                        "Reinforced_Brown"
                    };
                    break;

                case 3:
                    formation = FormationType.Organic;
                    // null means use all available presets
                    break;

                case 4:
                    formation = FormationType.Diamond;
                    allowedPresets = new List<string>
                    {
                        "Standard_Red", "Standard_Blue", "Reinforced_Brown", "Hard_DarkGray"
                    };
                    break;

                case 5:
                    formation = FormationType.Maze;
                    // null means use all available presets
                    break;

                case 6:
                    formation = FormationType.Zigzag;
                    break;

                case 7:
                    formation = FormationType.Wave;
                    break;

                case 8:
                    formation = FormationType.Arch;
                    break;

                case 9:
                    formation = FormationType.Organic;
                    break;

                case 10:
                    formation = FormationType.Diamond;
                    break;

                case 11:
                    formation = FormationType.Zigzag;
                    break;

                case 12:
                    formation = FormationType.Grid;
                    break;

                default:
                    // Use modulo to cycle through all formations 
                    int formationIndex = Level % 8; // by total number of formations 
                    formation = (FormationType)formationIndex;
                    break;
            }

            // Generate the level
            var brickPositions = LevelManager.GenerateLevel(
                Level,
                (float)GameField.Width - BRICKS_SIDE_MARGIN * 2,
                (float)GameField.Height / 2,
                formation,
                allowedPresets
            );

            BricksLeftToBreak = LevelManager.CountBreakableBricks(brickPositions);

            // Calculate brick dimensions based on columns and rows
            int columns = brickPositions.Select(p => (int)p.Column).Distinct().Count();

            float margin = SPACING_BRICKS;
            float totalSpacing = margin * (columns + 1);
            float availableWidth = (float)Width - totalSpacing - BRICKS_SIDE_MARGIN * 2;
            float brickWidth = availableWidth / MAX_BRICKS_COLUMNS;
            float brickHeight = 20f; // Fixed brick height as in original code

            // Calculate container dimensions
            int maxRow = brickPositions.Max(p => (int)p.Row);

            float containerWidth = columns * brickWidth + (columns - 1) * margin;
            float containerHeight = (maxRow + 1) * brickHeight + maxRow * margin + 1;

            // Prepare BricksContainer
            SetupBricksContainer(containerWidth, containerHeight);

            // Create and setup BricksContainer
            // Add bricks to container
            foreach (var position in brickPositions)
            {
                int col = (int)position.Column;
                int row = (int)position.Row;
                string presetId = position.PresetId;

                if (string.IsNullOrEmpty(presetId))
                    continue;

                var brick = AddBrickToContainer(presetId, col, row, brickWidth, brickHeight, margin);

                if (brick != null)
                {
                    BrickPresets.ApplyPreset(brick, presetId);
                }
            }

            levelReady = false;

            // Preserve demo state if we're in demo mode, otherwise set to Playing
            if (PreviousState == GameState.Playing)
            {
                State = GameState.Playing;
            }

            if (State != GameState.Playing)
            {
                State = GameState.DemoPlay;
            }

            if (State == GameState.DemoPlay)
            {
                AIController.ResetTimers();
            }
            else
            {
                //PLAYER!
                State = GameState.Playing; //last one bulletrpoof
                PlaySound(Sound.Start);
            }

            SetupBackgroundMusic();
        }

        void SetupBricksContainer(float width, float height)
        {
            BricksContainer.ClearChildren(); //todo check they dont get disposed!

            BricksContainer.WidthRequest = width;
            BricksContainer.HeightRequest = height;
        }

        private bool levelReady;

        public void StartNewGameDemo()
        {
            PreviousState = GameState.DemoPlay;
            State = GameState.DemoPlay;
            StartNewGame();
        }

        public void StartNewGamePlayer()
        {
            PreviousState = GameState.Playing;
            State = GameState.Playing;
            StartNewGame();
        }


        void StartNewGame()
        {
            _ = GameDialog.PopAll(this);

            Score = 0;

            Lives = LIVES;

            Level = 1;

            LevelManager = new LevelManager();

            StartNewLevel();

            //ShowDialog = false;
            StartLoop();
        }

        void PresentGame()
        {
            // Start demo mode - bot plays behind the welcome dialog
            StartDemoMode();

            ShowWelcomeDialog();
        }

        void StartDemoMode()
        {
            // Initialize demo mode
            Score = 0;
            Lives = LIVES;
            Level = 1;
            LevelManager = new LevelManager();

            // Set demo state and start level
            State = GameState.DemoPlay;
            StartNewLevel();
            StartLoop();
        }

        void ClearSpritesOnBoard()
        {
            lock (_lockSpritesToBeRemovedLater)
            {
                foreach (var control in GameField.Views)
                {
                    if (control == BricksContainer)
                    {
                        foreach (var brick in BricksContainer.Views)
                        {
                            _spritesToBeRemovedLater.Enqueue(brick);
                        }
                    }
                    else if (control is IReusableSprite)
                    {
                        _spritesToBeRemovedLater.Enqueue(control);
                    }
                }
            }
        }

        void RestartDemoMode()
        {
            // Restart demo mode from level 1 without showing any dialogs
            Score = 0;
            Lives = LIVES;
            Level = 1;

            ClearSpritesOnBoard();

            ProcessSpritesToBeRemoved();

            // Reset ball and continue demo
            ResetBall();
            foreach (var ball in ActiveBalls)
            {
                ball.IsMoving = false;
            }

            // Set demo state before starting new level
            State = GameState.DemoPlay;

            // Start new level in demo mode
            StartNewLevel();
            Update();
        }

        void ResetGame()
        {
            // Reset game state
            Lives = LIVES;
            Score = 0;
            Level = 1;
            State = GameState.Ready;

            ClearSpritesOnBoard();

            ProcessSpritesToBeRemoved();

            // Start new level
            StartNewLevel();
            Update();
        }

        #endregion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void AddToPoolBrickSprite()
        {
            var brick = BrickSprite.Create();
            BricksPool.Return(brick);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void AddToPoolPowerupSprite()
        {
            var powerup = PowerUpSprite.Create();
            PowerupsPool.Return(powerup);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void AddToPoolPaddleBulletSprite()
        {
            var bullet = BulletSprite.Create();
            PaddleBulletsPool.Return(bullet);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void AddToPoolBallSprite()
        {
            var ball = BallSprite.Create();
            BallsPool.Return(ball);
        }

        private int _level = 1;

        public int Level
        {
            get => _level;
            set
            {
                if (_level != value)
                {
                    _level = value;
                    OnPropertyChanged();
                }
            }
        }

        private int _lives = LIVES;

        public int Lives
        {
            get => _lives;
            set
            {
                if (_lives != value)
                {
                    _lives = value;
                    OnPropertyChanged();
                }
            }
        }

        private int _score;

        public int Score
        {
            get => _score;
            set
            {
                if (_score != value)
                {
                    _score = value;
                    OnPropertyChanged();
                }
            }
        }

        private bool _initialized;
        private bool _needPrerender;

        public class ReusableSpritePool<T> where T : IReusableSprite
        {
            protected Dictionary<Guid, T> Pool;

            public ReusableSpritePool(int size)
            {
                Pool = new(size);
            }

            public void Return(T item)
            {
                Pool.TryAdd(item.Uid, item);
            }

            public T Get()
            {
                var item = Pool.Values.FirstOrDefault();
                if (item != null && Pool.Remove(item.Uid))
                {
                    return item;
                }

                return default;
            }

            public int Count
            {
                get
                {
                    if (Pool == null)
                    {
                        return 0;
                    }

                    return Pool.Count;
                }
            }
        }

        // Pools for reusable sprites
        private ReusableSpritePool<BrickSprite> BricksPool = new(MAX_BRICKS);
        private ReusableSpritePool<PowerUpSprite> PowerupsPool = new(MAX_POWERUPS_IN_POOL);
        private ReusableSpritePool<BulletSprite> PaddleBulletsPool = new(MAX_BULLETS_IN_POOL);
        private ReusableSpritePool<BallSprite> BallsPool = new(MAX_BALLS_IN_POOL);
        public SKRect GameFieldArea = SKRect.Empty;
        public SKRect BricksArea = SKRect.Empty;
        private Queue<SkiaControl> _spritesToBeRemovedLater = new();
        private object _lockSpritesToBeRemovedLater = new();
        private List<SkiaControl> _spritesToBeAdded = new(MAX_BRICKS);

        // For paddle movement via keys/gestures
        volatile bool IsMovingLeft, IsMovingRight;
        private bool WasPanning;
        private bool IsPressed;

        // Ball stuck detection
        private Vector2 _lastBallPosition;
        private float _ballStuckTimer;
        private const float BALL_STUCK_THRESHOLD = 2.0f; // seconds
        private const float BALL_STUCK_DISTANCE = 5.0f; // pixels
        private GameState _lastState;
        private GameState _state;

        public GameState State
        {
            get => _state;
            set
            {
                if (_state != value)
                {
                    PreviousState = _state;
                    _lastStateChecked = PreviousState;
                    _state = value;
                    OnPropertyChanged();
                    Debug.WriteLine($"Game state changed: {value}");
                }
            }
        }

        protected bool CheckStateChanged()
        {
            var ret = _lastStateChecked != State;
            _lastStateChecked = State;
            return ret;
        }

        protected GameState PreviousState;


        void CollideBallAndPaddle(PaddleSprite paddle, BallSprite ball)
        {
            PlaySound(Sound.Board);

            // Determine paddle's horizontal velocity based on current movement input
            float paddleVelocity = 0;
            if (IsMovingLeft)
                paddleVelocity = -PADDLE_SPEED;
            else if (IsMovingRight)
                paddleVelocity = PADDLE_SPEED;

            // Calculate where on the paddle the ball hit (normalized position from -1 to 1)
            float paddleWidth = paddle.HitBox.Width;
            float paddleCenterX = paddle.HitBox.MidX;
            float ballCenterX = ball.HitBox.MidX;

            // Calculate normalized hit position (-1 is far left, 0 is center, 1 is far right)
            float hitPosition = (ballCenterX - paddleCenterX) / (paddleWidth / 2);
            hitPosition = Math.Clamp(hitPosition, -1.0f, 1.0f);

            // Start with basic reflection
            float newAngle = -ball.Angle;

            // Track how horizontal the new angle will be (for speed adjustment)
            float horizontalFactor = 0f;
            float baseAngle = -MathF.PI / 3; // Straight up

            // Apply special angle changes if the paddle is moving
            if (Math.Abs(paddleVelocity) > 0.1f)
            {
                // Apply paddle velocity with appropriate direction
                float effectivePaddleVelocity = -paddleVelocity;

                // Influence factor 
                float velocityInfluence = 0.9f;

                // Calculate paddle effect
                float paddleEffect = (effectivePaddleVelocity / PADDLE_SPEED) * velocityInfluence;

                // Maximum angle adjustment (30 degrees)
                float maxAngleAdjust = MathF.PI / 8;

                // Calculate angle adjustment from paddle movement
                float velocityAngleAdjust = paddleEffect * maxAngleAdjust;

                // Apply hit position effect (larger effect toward the edges)
                float positionFactor = 0.66f; // !!! 
                float positionAngleEffect = hitPosition * MathF.PI / 9 * positionFactor;

                if (hitPosition < 0)
                {
                    // Combine for final angle
                    newAngle = (float)Math.PI - baseAngle + velocityAngleAdjust + positionAngleEffect;
                }
                else
                {
                    // Combine for final angle
                    newAngle = baseAngle + velocityAngleAdjust + positionAngleEffect;
                }
            }
            else
            {
                // For stationary paddle, use hit position-based reflection

                float angleRange = MathF.PI / 4;
                float adjustedHitPosition = MathF.Sign(hitPosition) * MathF.Pow(MathF.Abs(hitPosition), 1.9f);

                if (hitPosition < 0)
                {
                    // Combine for final angle
                    newAngle = (float)Math.PI - baseAngle + (adjustedHitPosition * angleRange);
                }
                else
                {
                    // Combine for final angle
                    newAngle = baseAngle + (adjustedHitPosition * angleRange);
                }
            }

            // Set the new angle
            ball.Angle = newAngle;

            // Adjust speed based on angle horizontality
            horizontalFactor = MathF.Abs(MathF.Cos(newAngle));
            float baseSpeedBoost = 1.03f;
            float angleSpeedBoost = 1.0f + (horizontalFactor * 0.33f);
            float paddleSpeedContribution = (Math.Abs(paddleVelocity) / PADDLE_SPEED) * 0.03f;
            float finalSpeedMultiplier = baseSpeedBoost * angleSpeedBoost + paddleSpeedContribution;

            // Apply speed change with cap
            float maxSpeedRatio = 1.1f + (horizontalFactor * 0.75f);
            ball.SpeedRatio = MathF.Min(ball.SpeedRatio * finalSpeedMultiplier, maxSpeedRatio);

            //adjust some for frame drops
            AlightBallWithPaddleSurface(ball);

            if (Paddle.Powerup == PowerupType.StickyBall)
            {
                // Make THIS specific ball sticky (the one that just collided)
                ball.IsMoving = false;
                // Position sticky ball above paddle
                ball.SetOffsetY(Paddle.Top - ball.HeightRequest);
            }
        }

        /// <summary>
        /// Handles collision between ball and paddle with contextual physics based on hit position
        /// Left half: Normal physics (paddle movement direction = ball direction)
        /// Right half: Inverse physics (paddle movement direction = opposite ball direction)
        /// </summary>
        void CollideBallAndPaddle(PaddleSprite paddle, BallSprite ball, SKRect overlap)
        {
            CollideBallAndPaddle(paddle, ball);
        }

        /// <summary>
        /// Handles collision between ball and brick
        /// </summary>
        void CollideBallAndBrick(BrickSprite brick, BallSprite ball, SKRect overlap, bool isFireball = false)
        {
            // Get brick dimensions and position
            var brickRect = brick.HitBox;

            // Determine which face of the brick was hit
            var face = overlap.GetCollisionFace(brickRect);

            var penetration = overlap.Top;

            switch (face)
            {
                case CollisionFace.Top:
                case CollisionFace.Bottom:
                    penetration = overlap.Height;
                    break;

                case CollisionFace.Left:
                case CollisionFace.Right:
                    penetration = overlap.Width;
                    break;
            }

            CollideBallAndBrick(brick, ball, face, penetration, isFireball);
        }

        void CollideBallAndBrick(BrickSprite brick, BallSprite ball, CollisionFace face, float overlap,
            bool isFireball = false)
        {
            var offset = overlap * 1.1;

            // Only bounce if not in fireball mode
            if (!isFireball)
            {
                switch (face)
                {
                    case CollisionFace.Top:
                        ball.Angle = -ball.Angle;
                        ball.Top -= offset;
                        break;
                    case CollisionFace.Bottom:
                        // Vertical collision - reflect vertically
                        ball.Angle = -ball.Angle;
                        ball.Top += offset;
                        break;

                    case CollisionFace.Left:
                        ball.Left -= offset;
                        ball.Angle = MathF.PI - ball.Angle;
                        break;
                    case CollisionFace.Right:
                        ball.Left += offset;
                        ball.Angle = MathF.PI - ball.Angle;
                        break;
                }
            }

            // After calculating new angle in collision response
            // Move the ball slightly in the new direction to prevent sticking
            //float adjustDistance = overlap;
            //ball.Left += adjustDistance * MathF.Cos(ball.Angle);
            //ball.Top += adjustDistance * MathF.Sin(ball.Angle);

            // Handle brick hit logic based on properties
            if (brick.Undestructible)
            {
                if (isFireball)
                {
                    // Fireball can pass through undestructible bricks too!
                    PlaySound(Sound.Brick); // Different sound for fireball
                    // Don't remove undestructible bricks, but don't return either
                    // Let fireball continue through
                }
                else
                {
                    PlaySound(Sound.Wall);
                    // Don't remove undestructible bricks
                    return;
                }
            }

            PlaySound(Sound.Brick);

            if (brick.SupplementaryHitsToDestroy > 0)
            {
                // Brick needs multiple hits to destroy
                brick.SupplementaryHitsToDestroy--;
                // Add some visual feedback (could change color based on damage)
                // For now, just adjust opacity slightly
                brick.BackgroundColor = brick.BackgroundColor.WithLuminosity(0.5f);
                //brick.Opacity = 0.7f + (0.3f * brick.SupplementaryHitsToDestroy / 3.0f);

                // Add some points for hitting a reinforced brick
                Score += 5;
            }
            else
            {
                // Brick is destroyed
                // Increment score
                Score += 10;

                SpawnPowerUp(brick);

                // Remove the brick
                RemoveBrick(brick);
            }
        }

        void RemoveBrick(BrickSprite brick)
        {
            // Only decrement counter for destructible bricks
            if (!brick.Undestructible)
            {
                BricksLeftToBreak -= 1;
            }

            RemoveReusable(brick);
        }

        void CollideBulletAndBrick(BulletSprite bullet, BrickSprite brick)
        {
            // Remove the bullet
            RemoveReusable(bullet);

            // Handle brick hit logic - destroyer bullets can destroy undestructible bricks!
            if (brick.Undestructible)
            {
                // Destroyer bullets can destroy even undestructible bricks!
                PlaySound(Sound.Brick); // Different sound for destroyer
                Score += 10; // Give points for destroying undestructible brick
                SpawnPowerUp(brick);
                RemoveBrick(brick); // This will NOT decrement BricksLeftToBreak due to our fix
                return; // Exit early, brick is destroyed
            }

            PlaySound(Sound.Brick);

            if (brick.SupplementaryHitsToDestroy > 0)
            {
                brick.SupplementaryHitsToDestroy--;
                brick.BackgroundColor = brick.BackgroundColor.WithLuminosity(0.5f);
                Score += 5;
            }
            else
            {
                Score += 10;

                SpawnPowerUp(brick);

                RemoveBrick(brick);
            }
        }

        #region RAYCAST COLLISION DETECTION

        /// <summary>
        /// Alternative collision detection using raycasting for more accurate collision detection
        /// </summary>
        /// <param name="ball">The ball sprite</param>
        /// <param name="deltaSeconds">Time delta for this frame</param>
        /// <returns>True if a collision was detected and handled</returns>
        bool DetectCollisionsWithRaycast(BallSprite ball, float deltaSeconds)
        {
            if (!ball.IsActive || !ball.IsMoving)
                return false;

            // Calculate ball's movement for this frame
            // Use ball center position for raycast calculations
            Vector2 ballPosition = ball.Position; // This returns center position
            Vector2 ballDirection = ball.Direction;
            float ballRadius = (float)(ball.Width / 2);
            float ballSpeed = BALL_SPEED * ball.SpeedRatio;
            float maxDistance = ballSpeed * deltaSeconds;

            // System.Diagnostics.Debug.WriteLine($"Raycast: Ball center at ({ballPosition.X}, {ballPosition.Y}), direction ({ballDirection.X}, {ballDirection.Y}), distance {maxDistance}");

            // Collect all potential collision targets
            var collisionTargets = new List<IWithHitBox>();

            // Add bricks
            foreach (var view in GameField.Views)
            {
                if (view == BricksContainer)
                {
                    foreach (var child in BricksContainer.Views)
                    {
                        if (child is BrickSprite brick && brick.IsActive)
                        {
                            collisionTargets.Add(brick);
                        }
                    }
                }
            }

            // Add paddle (only if ball is moving downward)
            if (MathF.Sin(ball.Angle) > 0)
            {
                foreach (var view in GameField.Views)
                {
                    if (view is PaddleSprite paddle && paddle.IsActive)
                    {
                        paddle.UpdateState(LastFrameTimeNanos);
                        collisionTargets.Add(paddle);
                    }
                }
            }

            // Check for collisions with objects
            var objectHit =
                RaycastCollision.CastRay(ballPosition, ballDirection, maxDistance, ballRadius, collisionTargets);

            // Check for wall collisions
            var wallHit = RaycastCollision.CheckWallCollision(ballPosition, ballDirection, ballRadius, maxDistance,
                GameField.VisualLayer.HitBoxWithTransforms.Units);

            // Determine which collision happens first
            RaycastCollision.RaycastHit firstHit = RaycastCollision.RaycastHit.None;
            bool isWallCollision = false;

            if (objectHit.Collided && wallHit.Collided)
            {
                firstHit = objectHit.Distance <= wallHit.Distance ? objectHit : wallHit;
                isWallCollision = firstHit.Distance == wallHit.Distance;
            }
            else if (objectHit.Collided)
            {
                firstHit = objectHit;
                isWallCollision = false;
            }
            else if (wallHit.Collided)
            {
                firstHit = wallHit;
                isWallCollision = true;
            }

            if (firstHit.Collided)
            {
                // System.Diagnostics.Debug.WriteLine($"Raycast collision detected: {firstHit.Face} at distance {firstHit.Distance}");

                // Handle collision response - let the traditional collision methods handle positioning
                if (isWallCollision)
                {
                    HandleWallCollisionRaycast(ball, firstHit);
                }
                else
                {
                    HandleObjectCollisionRaycast(ball, firstHit);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Handles wall collision using raycast data - matches traditional collision behavior
        /// </summary>
        void HandleWallCollisionRaycast(BallSprite ball, RaycastCollision.RaycastHit hit)
        {
            // System.Diagnostics.Debug.WriteLine($"Wall collision: {hit.Face}");
            switch (hit.Face)
            {
                case CollisionFace.Left:
                    // Check for shallow angle and use larger penetration if needed
                    var leftPenetration = MathF.Abs(MathF.Cos(ball.Angle)) < 0.15f ? 6.0f : 2.0f;
                    ball.MoveOffset(leftPenetration * 1.1f, 0);
                    ball.Angle = MathF.PI - ball.Angle;
                    PlaySound(Sound.Wall, new Vector3(-1.0f, 0f, -1f));
                    break;
                case CollisionFace.Right:
                    // Check for shallow angle and use larger penetration if needed
                    var rightPenetration = MathF.Abs(MathF.Cos(ball.Angle)) < 0.15f ? 6.0f : 2.0f;
                    ball.MoveOffset(-rightPenetration * 1.1f, 0);
                    ball.Angle = MathF.PI - ball.Angle;
                    PlaySound(Sound.Wall, new Vector3(2.0f, 0f, -1f));
                    break;
                case CollisionFace.Bottom:
                    // Ball hit TOP wall (collision face is bottom of the wall)
                    var topPenetration = 2.0f;
                    ball.MoveOffset(0, topPenetration * 1.1f);
                    ball.Angle = -ball.Angle;
                    PlaySound(Sound.Wall);
                    break;
                case CollisionFace.Top:
                    // Ball hit BOTTOM wall (collision face is top of the wall) - game over logic
                    PlaySound(Sound.Oops);
                    if (CHEAT_INVULNERABLE)
                    {
                        // In cheat mode, just reset the ball position
                        ball.Top = GameField.Height - ball.Height - 10;
                        ball.Angle = -ball.Angle;
                    }
                    else
                    {
                        // Remove this ball from play (multiball-aware)
                        RemoveBall(ball);

                        // Check if all balls are gone
                        if (ActiveBalls.Count == 0)
                        {
                            LooseLife();
                        }
                    }

                    break;
            }
        }

        void LooseLife()
        {
            Lives--;
            if (Lives <= 0)
            {
                if (State == GameState.DemoPlay)
                {
                    // In demo mode, restart from level 1 without showing dialog
                    RestartDemoMode();
                }
                else
                {
                    this.GameLost();
                }
            }
            else
            {
                ResetPaddle(false);
            }
        }

        /// <summary>
        /// Handles object collision (brick or paddle) using raycast data
        /// </summary>
        void HandleObjectCollisionRaycast(BallSprite ball, RaycastCollision.RaycastHit hit)
        {
            if (hit.Target is BrickSprite brick)
            {
                // Use the SAME collision logic as traditional system
                // Calculate a small penetration value to match traditional behavior
                float fakePenetration = 2.0f; // Small value to simulate overlap
                CollideBallAndBrick(brick, ball, hit.Face, fakePenetration, ball.IsFireball);
            }
            else if (hit.Target is PaddleSprite paddle)
            {
                // Use existing paddle collision logic
                CollideBallAndPaddle(paddle, ball);
            }
        }

        #endregion

        public void AlightBallWithPaddleSurface(BallSprite ball = null)
        {
            if (ball != null)
            {
                ball.SetOffsetY(Paddle.Top - ball.HeightRequest);
            }
            else
            {
                // If no specific ball provided, align all active balls
                foreach (var activeBall in ActiveBalls)
                {
                    activeBall.SetOffsetY(Paddle.Top - activeBall.HeightRequest);
                }
            }
        }

        public void ResetPaddle(bool center = true)
        {
            CollectedPowerUps = 0;
            CollectedPowerUpsSpeedy = 0;

            IsMovingLeft = false;
            IsMovingRight = false;

            if (center)
                Paddle.Left = 0;

            ResetBall();

            ResetPowerUp();
        }

        void ResetPowerUp()
        {
            foreach (var ball in ActiveBalls)
            {
                ball.IsFireball = false;
            }
            ResetBallsSpeed();

            Paddle.Powerup = PowerupType.None;
            Paddle.PowerupDuration = 0;
        }

        public void ResetBall()
        {
            //PlaySound(Sound.Start);

            // Clear all existing balls
            ClearAllBalls();

            // Add a single ball
            var newBall = AddBall();
            if (newBall != null)
            {
                newBall.SpeedRatio = 1;
                // Position the ball above the paddle's center
                newBall.SetOffsetX(Paddle.Left);

                AlightBallWithPaddleSurface(newBall);

                // Random angle between -60� and -120� (upward)
                float randomAngle = (float)(new Random().NextDouble() * (MathF.PI / 3) - MathF.PI / 6 - MathF.PI / 2);

                newBall.Angle = randomAngle;

                newBall.IsMoving = false;
                newBall.IsActive = true;
            }

            ResetBallsSpeed();
        }

        void ResetBallsSpeed()
        {
            foreach (var ball in ActiveBalls)
            {
                ball.SpeedRatio = 1 + 0.05f * (Level - 1);
            }
        }

        #region HELPER METHODS

        void UpdatePlayerPosition(double x)
        {
            var leftLimit = -Width / 2f + Paddle.Width / 2f;
            var rightLimit = Width / 2f - Paddle.Width / 2f;
            var clampedX = Math.Clamp(x, leftLimit, rightLimit);
            var deltaX = clampedX - Paddle.Left;

            if (clampedX != Paddle.Left)
            {
                Paddle.Left = clampedX;

                // Move ALL sticky balls with the paddle
                foreach (var ball in ActiveBalls)
                {
                    if (!ball.IsMoving)
                    {
                        ball.MoveOffset(deltaX, 0);
                    }
                }
            }
        }

        void RemoveReusable(IReusableSprite sprite)
        {
            sprite.IsActive = false;
            sprite.AnimateDisappearing()
                .ContinueWith((s) =>
                {
                    lock (_lockSpritesToBeRemovedLater)
                    {
                        if (!sprite.IsActive)
                            _spritesToBeRemovedLater.Enqueue(sprite as SkiaControl);
                    }
                }).ConfigureAwait(false);
        }

        void RemoveSprite(SkiaControl sprite)
        {
            if (sprite is BrickSprite enemy)
            {
                BricksPool.Return(enemy);
            }

            if (sprite is PowerUpSprite powerup)
            {
                PowerupsPool.Return(powerup);
            }

            if (sprite is BulletSprite paddleBullet)
            {
                PaddleBulletsPool.Return(paddleBullet);
            }

            if (sprite is BrickSprite brick)
            {
                BricksContainer.RemoveSubView(brick);
            }
            else
            {
                GameField.RemoveSubView(sprite);
            }
        }

        void ProcessSpritesToBeRemoved()
        {
            SkiaControl sprite;
            lock (_lockSpritesToBeRemovedLater)
            {
                while (_spritesToBeRemovedLater.Count > 0)
                {
                    if (_spritesToBeRemovedLater.TryDequeue(out sprite))
                    {
                        RemoveSprite(sprite);
                    }
                }
            }
        }

        public void SpawnPowerUp(BrickSprite brick)
        {
            // Check if enough time has passed since last powerup spawn
            var currentTime = DateTime.Now;
            var timeSinceLastSpawn = (currentTime - _lastPowerupSpawnTime).TotalSeconds;

            if (timeSinceLastSpawn < POWERUP_SPAWN_COOLDOWN_SECONDS)
            {
                // Too soon, skip spawning this powerup
                return;
            }

            // Update timestamp immediately to prevent multiple spawns in same frame
            _lastPowerupSpawnTime = currentTime;

            if (PowerupsPool.Count > 0)
            {
                var powerup = PowerupsPool.Get();
                if (powerup != null)
                {
                    powerup.IsActive = true;

                    // Determine powerup type
                    PowerupType powerupType = PowerupType.None;
                    if (brick.Preset != null && brick.Preset.PowerUpType != PowerupType.None)
                    {
                        var chance = RndExtensions.Rnd.NextDouble(0, 1, 0.01);
                        if (chance < 0.5)
                        {
                            powerupType = brick.Preset.PowerUpType;
                        }
                    }
                    else
                    {
                        powerupType = GetRandomPowerupType();
                    }

                    if (powerupType != PowerupType.None)
                    {
                        // Position at center of destroyed brick
                        powerup.Left = brick.HitBox.Left + (brick.Width - powerup.WidthRequest) / 2 -
                                       GameFieldArea.Left;
                        powerup.Top = brick.HitBox.Top - GameFieldArea.Top;

                        powerup.SetPowerupType(powerupType);
                        powerup.ResetAnimationState();

                        _spritesToBeAdded.Add(powerup);
                    }
                    else
                    {
                        PowerupsPool.Return(powerup);
                    }
                }
            }
        }

        private PowerupType GetRandomPowerupType()
        {
            var chance = RndExtensions.Rnd.NextDouble(0, 1, 0.01);

            if (chance < 0.05) return PowerupType.ExtraLife;
            if (chance < 0.10) return PowerupType.Destroyer;
            if (chance < 0.15) return PowerupType.MultiBall;
            if (chance < 0.17) return PowerupType.Fireball;
            if (chance < 0.27) return PowerupType.SlowBall;
            if (chance < 0.37) return PowerupType.ShrinkPaddle;
            if (chance < 0.47) return PowerupType.FastBall;
            if (chance < 0.57) return PowerupType.ExpandPaddle;
            if (chance < 0.67) return PowerupType.StickyBall;

            return PowerupType.None;
        }

        private void ApplyPowerUp(PowerupType powerUpType)
        {
            if (powerUpType != PowerupType.None)
            {
                CollectedPowerUps++;

                // Add score for collecting powerups
                switch (powerUpType)
                {
                    case PowerupType.MultiBall:
                    case PowerupType.Fireball:
                        Score += 200;
                        break;
                    case PowerupType.Destroyer:
                        Score += 150;
                        break;
                    case PowerupType.ExpandPaddle:
                    case PowerupType.StickyBall:
                    case PowerupType.ExtraLife:
                    case PowerupType.SlowBall:
                        Score += 30;
                        break;
                    case PowerupType.ShrinkPaddle:
                    case PowerupType.FastBall:
                        Score += 100;
                        break;
                }

                if (powerUpType == PowerupType.Destroyer || powerUpType == PowerupType.FastBall)
                {
                    CollectedPowerUpsSpeedy++;
                    if (CollectedPowerUpsSpeedy == 1)
                    {
                        PlaySpeedyMusic();
                    }
                }
                else //rare
                if (powerUpType == PowerupType.MultiBall || powerUpType == PowerupType.Fireball)
                {
                    CollectedPowerUpsSpeedy++;
                    if (CollectedPowerUpsSpeedy == 1)
                    {
                        PlaySpecialMusic();
                    }
                }
            }

            if (powerUpType == PowerupType.Destroyer)
            {
                BulletsAvailable = POWERUP_MAX_BULLETS;
                PlaySound(Sound.Attack);
            }
            else if (powerUpType == PowerupType.None)
            {
                PlaySound(Sound.PowerDown);
            }
            else
            {
                PlaySound(Sound.PowerUp);
            }

            // Reset previous powerup effects before applying new one
            if (Paddle.Powerup != PowerupType.None && Paddle.Powerup != powerUpType)
            {
                ResetPowerUp();
            }


            if (powerUpType == PowerupType.ExtraLife)
            {
                if (Lives < 8)
                {
                    Lives++;
                }
            }

            // Apply ball speed effects to all active balls
            if (powerUpType == PowerupType.SlowBall)
            {
                foreach (var ball in ActiveBalls)
                {
                    ball.SpeedRatio *= 0.5f;
                }
            }
            else if (powerUpType == PowerupType.FastBall)
            {
                foreach (var ball in ActiveBalls)
                {
                    ball.SpeedRatio *= 2.0f;
                }
            }
            else if (powerUpType == PowerupType.MultiBall)
            {
                ActivateMultiball();
            }
            else if (powerUpType == PowerupType.Fireball)
            {
                ActivateFireball();
            }

            // Handle sticky ball logic - release all balls when switching away from sticky
            if (Paddle.Powerup == PowerupType.StickyBall && powerUpType != PowerupType.StickyBall)
            {
                foreach (var ball in ActiveBalls)
                {
                    ball.IsMoving = true;
                }
            }
            else if (powerUpType != PowerupType.StickyBall)
            {
                foreach (var ball in ActiveBalls)
                {
                    ball.IsMoving = true;
                }
            }

            Debug.WriteLine($"POWERUP! {powerUpType}");

            Paddle.Powerup = powerUpType;
        }

        /// <summary>
        /// Activates multiball powerup by spawning additional balls
        /// </summary>
        private void ActivateMultiball()
        {
            if (ActiveBalls.Count == 0) return;

            // Get the first active ball as reference
            var referenceBall = ActiveBalls.First();

            // Make sure all balls start moving (override sticky ball)
            foreach (var ball in ActiveBalls)
            {
                ball.IsMoving = true;
            }

            // Spawn 2 additional balls (total of 3 balls)
            const int additionalBalls = 2;
            const float angleSpread = MathF.PI / 4; // 45 degrees spread

            for (int i = 0; i < additionalBalls; i++)
            {
                var newBall = AddBall();
                if (newBall != null)
                {
                    // Position new ball at reference ball location
                    newBall.Left = referenceBall.Left;
                    newBall.Top = referenceBall.Top;

                    // Copy reference ball properties
                    newBall.SpeedRatio = referenceBall.SpeedRatio;
                    newBall.IsMoving = true; // Always start moving, ignore sticky ball
                    newBall.IsActive = true;
                    newBall.IsFireball = referenceBall.IsFireball; // Inherit fireball state

                    // Calculate spread angle
                    float baseAngle = referenceBall.Angle;
                    float spreadOffset = (i + 1) * (angleSpread / (additionalBalls + 1)) - angleSpread / 2;
                    newBall.Angle = baseAngle + spreadOffset;

                    // Ensure angle is valid
                    newBall.Angle = BallSprite.ClampAngleFromHorizontal(newBall.Angle);

                    Debug.WriteLine($"Multiball: Spawned ball {i + 1} at angle {newBall.Angle * 180 / MathF.PI:F1}°");
                }
            }

            Debug.WriteLine($"Multiball activated! Total balls: {ActiveBalls.Count}");
        }

        /// <summary>
        /// Activates fireball powerup making all balls destructive and able to pass through bricks
        /// </summary>
        private void ActivateFireball()
        {
            // Make all active balls fireballs
            foreach (var ball in ActiveBalls)
            {
                ball.IsFireball = true;
            }

            Debug.WriteLine($"Fireball activated! All {ActiveBalls.Count} balls are now fireballs");
        }

        private bool DetectBulletCollisionsWithRaycast(BulletSprite bullet, float deltaSeconds)
        {
            // Calculate bullet movement
            Vector2 bulletPosition = new Vector2((float)bullet.HitBox.Left + (float)bullet.HitBox.Width / 2,
                (float)bullet.HitBox.Top + (float)bullet.HitBox.Height / 2);

            Vector2 bulletDirection = new Vector2(0, -1); // Moving up
            float bulletRadius = (float)bullet.HitBox.Width / 2;
            float bulletSpeed = BulletSprite.Speed * bullet.SpeedRatio;
            float maxDistance = bulletSpeed * deltaSeconds;

            // Collect brick targets
            var collisionTargets = new List<IWithHitBox>();

            foreach (var view in GameField.Views)
            {
                if (view == BricksContainer)
                {
                    foreach (var child in BricksContainer.Views)
                    {
                        if (child is BrickSprite brick && brick.IsActive)
                        {
                            collisionTargets.Add(brick);
                        }
                    }
                }
                // Add powerups as targets too
                else if (view is PowerUpSprite powerup && powerup.IsActive)
                {
                    collisionTargets.Add(powerup);
                }
            }

            // Check for collisions
            var hit = RaycastCollision.CastRay(bulletPosition, bulletDirection, maxDistance, bulletRadius,
                collisionTargets);

            if (hit.Collided)
            {
                if (hit.Target is BrickSprite brickHit)
                {
                    CollideBulletAndBrick(bullet, brickHit);
                    return true;
                }
                else if (hit.Target is PowerUpSprite powerupHit)
                {
                    // Remove both bullet and powerup
                    RemoveReusable(bullet);
                    RemoveReusable(powerupHit);
                    return true;
                }
            }

            return false;
        }

        void FirePaddleBullet()
        {
            if (PaddleBulletsPool.Count > 0)
            {
                var bullet = PaddleBulletsPool.Get();
                if (bullet != null)
                {
                    bullet.IsActive = true;

                    // Position bullet at center of paddle, above it
                    bullet.Left = Paddle.Left + (Paddle.Width - bullet.Width) / 2;
                    bullet.Top = Paddle.Top - bullet.Height;

                    bullet.ResetAnimationState();
                    _spritesToBeAdded.Add(bullet);
                }
            }

            BulletsAvailable--;
            if (BulletsAvailable <= 0)
            {
                ApplyPowerUp(PowerupType.None);
            }
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.HotPreview.cs ---
using Breakout.Game.Dialogs;


namespace Breakout.Game
{

#if PREVIEWS

    public partial class BreakoutGame : MauiGame
    {
        public void ApplyPreviewState(PreviewAppState previewAppState)
        {
            ResetGame();

            _ = GameDialog.PopAllAsync(this);

            var newState = previewAppState.GameState;
            if (newState == GameState.Ready)
            {
                StartDemoMode();
                ShowWelcomeDialog();
            }
            else if (newState == GameState.DemoPlay)
            {
                StartDemoMode();
            }
            else if (newState == GameState.Playing)
            {
                StartNewGamePlayer();

                Lives = previewAppState.Lives;
                Score = previewAppState.Score;
            }
            else if (newState == GameState.Paused)
            {
                StartNewGamePlayer();

                Lives = previewAppState.Lives;
                Score = previewAppState.Score;

                PauseGame();
            }
            else if (newState == GameState.LevelComplete)
            {
                StartNewGamePlayer();
                State = GameState.LevelComplete;
                Level = previewAppState.Level;
                Lives = previewAppState.Lives;
                Score = previewAppState.Score;

                LevelComplete();
            }
        }
    }

    public record PreviewAppState
    {
        public GameState GameState { get; init; } = GameState.Ready;
        public int Level { get; init; } = 1;
        public int Lives { get; init; } = 3;
        public int Score { get; init; } = 1000;

        public static PreviewAppState BeginningOfLevel(int level)
        {
            return new PreviewAppState()
                { Level = level - 1, GameState = GameState.LevelComplete, Score = 1000 * (level - 1) };
        }
    }

#endif
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Input.cs ---
using AppoMobi.Maui.Gestures;
using Breakout.Game.Dialogs;
using Breakout.Game.Input;
using Breakout.Helpers;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region GESTURES AND KEYS

        protected void InitializeInput()
        {
            SetInputPressMode(AppSettings.Get(AppSettings.InputPressEnabled, AppSettings.InputPressEnabledDefault));

            //GAME CONTROLLER SUPPORT
            AddInputController(new GameControllerInput(this));
        }

        public virtual void SendKey(GameKey key)
        {
            GameKeysQueue.Enqueue(key);
        }

        private int ActionDelayMs = 2000;
 
        private Dictionary<GameKey, long> LastActions = new();

        private bool CanProcessSpecialKey(GameKey key)
        {
            var currentTime = Environment.TickCount64;
            var allowed = true;
            if (LastActions.TryGetValue(key, out var lastActionTime))
            {
                allowed = currentTime - lastActionTime >= ActionDelayMs;
            }
            return allowed;
        }

        private void MarkCanProcessSpecialKey(GameKey key)
        {
            LastActions[key] = Environment.TickCount64;
        }

        public void ProcessInput()
        {
            foreach (var inputController in InputControllers)
            {
                inputController.ProcessState();
            }

            while (GameKeysQueue.Count > 0)
            {
                var gameKey = GameKeysQueue.Dequeue();

                //special global keys
                if (gameKey == GameKey.Pause)
                {
                    if (!CanProcessSpecialKey(GameKey.Pause))
                    {
                        continue;
                    }
                    MarkCanProcessSpecialKey(gameKey); 
                }
                else
                //keys that can go to dialogs too
                if (GameDialog.IsAnyDialogOpen(this))
                {
                    var topDialog = GameDialog.GetTopDialog(this);
                    if (topDialog is IGameKeyHandler handler && handler.HandleGameKey(gameKey))
                    {
                        continue;
                    }
                }

                // If dialog didn't consume apply to game
                ApplyGameKey(gameKey);
            }
        }

        protected List<IInputController> InputControllers = new();

        public void AddInputController(IInputController controller)
        {
            InputControllers.Add(controller);
        }

        public void RemoveInputController(IInputController controller)
        {
            InputControllers.Remove(controller);
        }

        /// <summary>
        /// Since touch gestures can come several for 1 frame we enqueue them and will process at start of the frame
        /// </summary>
        protected Queue<GameKey> GameKeysQueue = new();

        private GameState _lastStateChecked;
        private float thresholdTapVelocity = 200;


        /// <summary>
        /// You could use this to simulate key presses from game controller/anything
        /// </summary>
        /// <param name="gameKey"></param>
        public virtual void ApplyGameKey(GameKey gameKey)
        {

            if (gameKey == GameKey.Pause)
            {
                TogglePause();
                return;
            }

            // For playing state, set movement flags
            if (State == GameState.Playing || State == GameState.DemoPlay)
            {
                if (gameKey == GameKey.Fire)
                {
                    // Check if any balls are not moving (sticky)
                    bool hasStickyballs = ActiveBalls.Any(ball => !ball.IsMoving);

                    if (hasStickyballs)
                    {
                        // Release ALL sticky balls
                        foreach (var ball in ActiveBalls)
                        {
                            if (!ball.IsMoving)
                            {
                                ball.IsMoving = true;
                            }
                        }
                    }
                    else if (Paddle.Powerup == PowerupType.Destroyer)
                    {
                        FirePaddleBullet();
                    }
                }

                if (gameKey == GameKey.Stop)
                {
                    IsMovingLeft = false;
                    IsMovingRight = false;
                }
                else if (gameKey == GameKey.Left)
                {
                    IsMovingLeft = true;
                    IsMovingRight = false;
                }
                else if (gameKey == GameKey.Right)
                {
                    IsMovingLeft = false;
                    IsMovingRight = true;
                }


            }
        }


        public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args,
            GestureEventProcessingInfo apply)
        {
            ISkiaGestureListener consumed = null;

            ISkiaGestureListener PassToChildren()
            {
                return base.ProcessGestures(args, apply);
            }

            if (GameDialog.IsAnyDialogOpen(this))
            {
                return PassToChildren();
            }

            consumed = PassToChildren();
            if (consumed != null && consumed != this)
            {
                return consumed;
            }

            if (State == GameState.Playing)
            {
                var velocityX = (float)(args.Event.Distance.Velocity.X / RenderingScale);

                if (!InputPressMode)
                {
                    if (args.Type == TouchActionResult.Panning)
                    {
                        WasPanning = true;

                        if (velocityX < 0)
                        {
                            IsMovingLeft = true;
                            IsMovingRight = false;
                        }
                        else if (velocityX > 0)
                        {
                            IsMovingRight = true;
                            IsMovingLeft = false;
                        }

                        return this;
                    }
                }

                if (args.Type == TouchActionResult.Down)
                {
                    WasPanning = false;
                    IsPressed = true;

                    if (args.Event.NumberOfTouches > 1) //lets say its fire
                    {
                        if (State == GameState.Playing)
                        {
                            GameKeysQueue.Enqueue(GameKey.Fire);
                        }
                    }
                }

                else if (args.Type == TouchActionResult.Tapped)
                {
                    if (State == GameState.Playing)
                    {
                        GameKeysQueue.Enqueue(GameKey.Fire);
                    }
                }

                else if (args.Type == TouchActionResult.Up)
                {
                    IsPressed = false;
                }

                IsMovingLeft = IsMovingRight = false;
                return this;
            }

            IsMovingLeft = IsMovingRight = false;
            return base.ProcessGestures(args, apply);
        }

        void PauseGame()
        {
            if (State == GameState.Playing)
            {
                State = GameState.Paused;
                IsMovingLeft = false;
                IsMovingRight = false;
                GameDialog.Show(this, null, ResStrings.StatePaused.ToUpperInvariant(), null, () => { TogglePause(); });
            }
        }

        bool TogglePause()
        {
            //if (State == GameState.Playing)
            //{
            //    ShowOptions();
            //    //PauseGame();
            //    return true;
            //}

            if (State == GameState.Paused)
            {
                State = PreviousState;
                IsMovingLeft = false;
                IsMovingRight = false;
                _ = GameDialog.PopAllAsync(this);
                return true;
            }
            else
            {
                ShowOptions();
                return true;
            }

            return false;
        }

        GameKey MapToGame(MauiKey key)
        {
            switch (key)
            {
                case MauiKey.Enter:
                case MauiKey.Space:
                    return GameKey.Fire;

                case MauiKey.KeyP:
                case MauiKey.Escape:
                case MauiKey.Pause:
                    return GameKey.Pause;

                case MauiKey.ArrowLeft:
                    return GameKey.Left;

                case MauiKey.ArrowRight:
                    return GameKey.Right;

                case MauiKey.ArrowDown:
                    return GameKey.Down;

                case MauiKey.ArrowUp:
                    return GameKey.Up;

                case MauiKey.KeyD:
                    return GameKey.Demo;
            }

            return GameKey.Unset;
        }

        /*
        /// <summary>
        /// Maps a GameKey to its primary MauiKey equivalent
        /// </summary>
        /// <param name="gameKey">The game key to map</param>
        /// <returns>The corresponding MauiKey</returns>
        public MauiKey MapToKeyboard(GameKey gameKey)
        {
            switch (gameKey)
            {
                case GameKey.Fire:
                    return MauiKey.Space;
                case GameKey.Pause:
                    return MauiKey.KeyP;
                case GameKey.Left:
                    return MauiKey.ArrowLeft;
                case GameKey.Right:
                    return MauiKey.ArrowRight;
                case GameKey.Demo:
                    return MauiKey.KeyD;
                case GameKey.Unset:
                default:
                    return MauiKey.Unknown;
            }
        }
        */

        protected void SetInputPressMode(bool state)
        {
            AppSettings.Set(AppSettings.InputPressEnabled, state);
            InputPressMode = state;
        }

        public bool InputPressMode { get; protected set; }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Loop.cs ---
using System.Diagnostics;
using System.Numerics;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region GAME LOOP

        public override void GameLoop(float deltaSeconds)
        {
            base.GameLoop(deltaSeconds);

            float cappedDelta = deltaSeconds;

            GameFieldArea = GameField.GetHitBox();
            BricksArea = BricksContainer.GetHitBox();

            ProcessInput();

            if ((State == GameState.DemoPlay || State == GameState.Playing) && levelReady)
            {
                // Update all active balls
                foreach (var ball in ActiveBalls)
                {
                    ball.UpdateState(LastFrameTimeNanos);
                }

                foreach (var child in BricksContainer.Views)
                {
                    if (child is BrickSprite brick && brick.IsActive)
                    {
                        brick.UpdateState(LastFrameTimeNanos);
                    }
                }

                // collision detection for all active balls
                foreach (var ball in ActiveBalls.ToList())
                {
                    if (!ball.IsActive) continue;

                    bool ballCollided = false;
                    var ballRect = ball.HitBox;

                    //bricks
                    if (ball.IsMoving)
                    {
                        if (USE_RAYCAST_COLLISION)
                        {
                            // Use raycast collision detection
                            ballCollided = DetectCollisionsWithRaycast(ball, cappedDelta);
                        }
                        else
                        {
                            // Use traditional AABB collision detection
                            if (!ballCollided && ball.IsActive)
                            {
                                foreach (var view in GameField.Views)
                                {
                                    if (view == BricksContainer)
                                    {
                                        foreach (var child in BricksContainer.Views)
                                        {
                                            if (child is BrickSprite brick && brick.IsActive)
                                            {
                                                if (ballRect.IntersectsWith(brick.HitBox, out var overlap))
                                                {
                                                    if (ball.IsFireball)
                                                    {
                                                        // Fireball mode: destroy brick but don't bounce
                                                        CollideBallAndBrick(brick, ball, overlap, isFireball: true);
                                                        // Don't set ballCollided = true, so ball continues through
                                                    }
                                                    else
                                                    {
                                                        // Normal mode: destroy brick and bounce
                                                        CollideBallAndBrick(brick, ball, overlap);
                                                        ballCollided = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                        //maybe GameState would change after all of that
                        if (BricksLeftToBreak == 0)
                        {
                            break;
                        }

                        if (State == GameState.Playing || State == GameState.DemoPlay)
                        {
                            //paddle(s) - only for traditional collision detection (raycast handles this in DetectCollisionsWithRaycast)
                            if (!USE_RAYCAST_COLLISION && !ballCollided && ball.IsActive)
                            {
                                if (MathF.Sin(ball.Angle) > 0) //only if ball moves downward
                                {
                                    foreach (var view in GameField.Views)
                                    {
                                        if (view is PaddleSprite paddle && paddle.IsActive)
                                        {
                                            //calculate hitbox
                                            paddle.UpdateState(LastFrameTimeNanos);

                                            if (ballRect.IntersectsWith(paddle.HitBox, out var overlap))
                                            {
                                                CollideBallAndPaddle(paddle, ball, overlap);
                                                ballCollided = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            //walls - only for traditional collision detection (raycast handles this in DetectCollisionsWithRaycast)
                            if (!USE_RAYCAST_COLLISION && !ballCollided && ball.IsActive)
                            {
                                if (ballRect.Left < 0)
                                {
                                    var penetration = -ballRect.Left;
                                    ball.MoveOffset(penetration * 1.1f, 0);
                                    ball.Angle = MathF.PI - ball.Angle;
                                    PlaySound(Sound.Wall, new Vector3(-1.0f, 0f, -1f));
                                    ballCollided = true;
                                }
                                // Right wall
                                else if (ballRect.Right > Width)
                                {
                                    var penetration = ballRect.Right - Width;
                                    ball.MoveOffset(-penetration * 1.1f, 0);
                                    ball.Angle = MathF.PI - ball.Angle;
                                    PlaySound(Sound.Wall, new Vector3(2.0f, 0f, -1f));
                                    ballCollided = true;
                                }

                                // Top wall
                                if (ballRect.Top < 0)
                                {
                                    var penetration = -ballRect.Top;
                                    ball.MoveOffset(0, penetration * 1.1f);
                                    ball.Angle = -ball.Angle;
                                    PlaySound(Sound.Wall);
                                    ballCollided = true;
                                }

                                if (ballRect.Bottom > GameField.Height)
                                {
                                    ballCollided = true;
                                    PlaySound(Sound.Oops);
                                    if (CHEAT_INVULNERABLE)
                                    {
                                        // In cheat mode, just reset the ball position
                                        ball.Top = GameField.Height - ball.Height - 10;
                                        ball.Angle = -ball.Angle;
                                    }
                                    else
                                    {
                                        // Remove this ball from play
                                        RemoveBall(ball);

                                        // Check if all balls are gone
                                        if (ActiveBalls.Count == 0)
                                        {
                                            Lives--;
                                            if (Lives <= 0)
                                            {
                                                if (State == GameState.DemoPlay)
                                                {
                                                    // In demo mode, restart from level 1 without showing dialog
                                                    RestartDemoMode();
                                                }
                                                else
                                                {
                                                    GameLost();
                                                }
                                            }
                                            else
                                            {
                                                ResetBall();
                                                //State = GameState.Paused;
                                            }
                                        }
                                    }
                                }
                            }

                            // Update ball position - raycast collision handles positioning during collision detection
                            if (ball.IsActive && (!ballCollided || !USE_RAYCAST_COLLISION))
                            {
                                ball.UpdatePosition(cappedDelta);
                            }
                        }
                }

                // Handle powerups separately
                foreach (var x in this.GameField.Views.ToList())
                {
                    if (x is PowerUpSprite powerup && powerup.IsActive)
                    {
                        // Update powerup state and position
                        powerup.UpdateState(LastFrameTimeNanos);
                        powerup.UpdateRotation(cappedDelta);

                        // Check if powerup hit bottom - remove it
                        if (powerup.Top > GameField.Height)
                        {
                            RemoveReusable(powerup);
                        }
                        else
                        {
                            // Check collision with paddle
                            var powerupRect = powerup.HitBox;

                            foreach (var view in GameField.Views)
                            {
                                if (view is PaddleSprite paddle && paddle.IsActive)
                                {
                                    paddle.UpdateState(LastFrameTimeNanos);

                                    if (powerupRect.IntersectsWith(paddle.HitBox))
                                    {
                                        ApplyPowerUp(powerup.Type);
                                        RemoveReusable(powerup);
                                        break;
                                    }
                                }
                            }

                            // Move powerup down if still active
                            if (powerup.IsActive)
                            {
                                powerup.Top += PowerUpSprite.FallSpeed * cappedDelta;
                            }
                        }
                    }
                    else if (x is BulletSprite bullet && bullet.IsActive)
                    {
                        bullet.UpdateState(LastFrameTimeNanos);

                        // Check if bullet reached top - remove it
                        if (bullet.HitBox.Top < 0)
                        {
                            RemoveReusable(bullet);
                        }
                        else
                        {
                            // Check collision with bricks using raycast
                            bool bulletHit = false;

                            if (USE_RAYCAST_COLLISION)
                            {
                                bulletHit = DetectBulletCollisionsWithRaycast(bullet, cappedDelta);
                            }
                            else
                            {
                                // Traditional AABB collision for bullets vs bricks and powerups
                                var bulletRect = bullet.HitBox;

                                foreach (var view in GameField.Views)
                                {
                                    if (view == BricksContainer)
                                    {
                                        foreach (var child in BricksContainer.Views)
                                        {
                                            if (child is BrickSprite brick && brick.IsActive)
                                            {
                                                if (bulletRect.IntersectsWith(brick.HitBox))
                                                {
                                                    CollideBulletAndBrick(bullet, brick);
                                                    bulletHit = true;
                                                    break;
                                                }
                                            }
                                        }

                                        if (bulletHit) break;
                                    }
                                    // Check collision with powerups
                                    else if (view is PowerUpSprite fallingPowerup && fallingPowerup.IsActive)
                                    {
                                        if (bulletRect.IntersectsWith(fallingPowerup.HitBox))
                                        {
                                            RemoveReusable(bullet);
                                            RemoveReusable(fallingPowerup);
                                            bulletHit = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            // Move bullet up if still active
                            if (bullet.IsActive && !bulletHit)
                            {
                                bullet.Top -= BulletSprite.Speed * cappedDelta;
                            }
                        }
                    }
                }

                //check we broke all bricks
                if ((State == GameState.Playing || State == GameState.DemoPlay) &&
                    (BricksLeftToBreak == 0))
                {
                    _levelCompletionPending++;

                    //make sure we show some frames after the final collision was detected
                    if (_levelCompletionPending > 20)
                    {
                        State = GameState.LevelComplete;
                        _levelCompletionPending = 0;
                    }
                }

                //update ai
                if (State == GameState.DemoPlay)
                {
                    AIController.UpdateAI(cappedDelta);
                }

                //update player state and position
                if (State == GameState.Playing || State == GameState.DemoPlay)
                {
                    // Update paddle powerup duration
                    if (Paddle.PowerupDuration > 0)
                    {
                        Paddle.PowerupDuration -= cappedDelta;
                        if (Paddle.PowerupDuration <= 0)
                        {
                            // timer expired
                            ResetPowerUp();
                        }
                    }

                    // movement control
                    if (IsMovingLeft)
                    {
                        UpdatePlayerPosition(Paddle.Left - PADDLE_SPEED * cappedDelta);
                    }

                    if (IsMovingRight)
                    {
                        UpdatePlayerPosition(Paddle.Left + PADDLE_SPEED * cappedDelta);
                    }
                }
            }

            // Ensure all balls never exit game field bounds (raycast collision fallback)
            foreach (var ball in ActiveBalls.ToList())
            {
                if (!ball.IsActive) continue;

                var ballLeftLimit = -GameField.Width / 2f + ball.Width / 2f;
                var ballRightLimit = GameField.Width / 2f - ball.Width / 2f;
                var wasLeft = ball.Left;
                ball.Left = Math.Clamp(ball.Left, ballLeftLimit, ballRightLimit);

                // If ball was clamped horizontally, reflect its horizontal direction
                if (wasLeft != ball.Left && ball.IsMoving)
                {
                    ball.Angle = MathF.PI - ball.Angle; // Reflect horizontally
                    PlaySound(Sound.Wall, new Vector3(ball.Left < 0 ? -1.0f : 1.0f, 0f, -1f));
                }

                var ballTopLimit = -GameField.Height + ball.Height;
                var ballBottomLimit = 0;
                var wasTop = ball.Top;
                ball.Top = Math.Clamp(ball.Top, ballTopLimit, ballBottomLimit);

                // If ball was clamped vertically, reflect its vertical direction with slight randomization
                if (wasTop != ball.Top && ball.IsMoving)
                {
                    // Reflect vertically
                    ball.Angle = -ball.Angle;

                    // Add slight randomization to prevent infinite vertical bouncing
                    var randomOffset = (Random.Shared.NextSingle() - 0.5f) * 0.2f; // ±0.1 radians (~±6 degrees)
                    ball.Angle += randomOffset;

                    // Ensure angle doesn't become too horizontal (use existing clamping)
                    ball.Angle = BallSprite.ClampAngleFromHorizontal(ball.Angle);

                    PlaySound(Sound.Wall, new Vector3(0f, ball.Top < -GameField.Height / 2f ? -1.0f : 1.0f, -1f));
                }
            }
            
            ProcessSpritesToBeRemoved();

            if (_spritesToBeAdded.Count > 0)
            {
                foreach (var add in _spritesToBeAdded)
                {
                    if (add is BrickSprite brick)
                    {
                        BricksContainer.AddSubView(brick);
                    }
                    else
                    {
                        GameField.AddSubView(add);
                    }
                }

                _spritesToBeAdded.Clear();
            }

            if (State == GameState.Playing || State == GameState.DemoPlay)
            {
                levelReady = true; //we have added all sprites, can play now
            }
            else 
            if (State == GameState.LevelComplete)
            {
                LevelComplete();
            }
        }

        /// <summary>
        /// Engine was paused maybe app went to background
        /// </summary>
        protected override void OnPaused()
        {
            if (_audioService != null)
            {
                _audioService.IsMuted = true;
                _audioService.StopBackgroundMusic();
            }
            
            PauseGame();
            
            StopLoop();
        }

        /// <summary>
        /// Engine was paused maybe app went to foreground
        /// </summary>
        protected override void OnResumed()
        {
            if (_audioService != null)
            {
                _audioService.IsMuted = false;
                SetupBackgroundMusic();
            }

            StartLoop();
        }

        private int _levelCompletionPending = 0;
        private bool _levelCompletionPrompt = false;

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Sound.cs ---
using Breakout.Helpers;
using System.Numerics;
using AppoMobi.Specials;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region AUDIO

        public enum Sound
        {
            None,
            Board,
            Brick,
            Wall,
            Oops,
            Start,
            PowerUp,
            PowerDown,
            Attack,
            Dialog,
            Selection,
            Joy,
            Sad
        }

        public void EnableSounds(bool state)
        {
            soundsOn = state;
        }

        private bool soundsOn;

        private async Task InitializeAudioAsync()
        {
            IAudioService audioService;

#if !ANDROID
            audioService = new AudioMixerService(Plugin.Maui.Audio.AudioManager.Current);
#else
            audioService = new SoundFlowAudioService();
#endif

            // Preload
            //will keep
            await audioService.PreloadSoundAsync("oops", "Fx/ballout.mp3");
            await audioService.PreloadSoundAsync("collide", "Fx/bricksynth.wav");
            await audioService.PreloadSoundAsync("aggro", "Fx/powerup27.mp3");
            await audioService.PreloadSoundAsync("dlg", "Fx/quirky26.mp3");
            await audioService.PreloadSoundAsync("sel", "Fx/quirky7.mp3");
            await audioService.PreloadSoundAsync("joy", "Fx/synthchime2.mp3");
            await audioService.PreloadSoundAsync("sad", "Fx/bells1.mp3");
            //todo maybe
            //await audioService.PreloadSoundAsync("powerdown", "Fx/????.mp3");
            //await audioService.PreloadSoundAsync("powerup", "Fx/????.mp3");

            //maybe
            await audioService.PreloadSoundAsync("brick", "Sounds/tik.wav");
            await audioService.PreloadSoundAsync("board2", "Sounds/bricksynth2.wav");
            await audioService.PreloadSoundAsync("board3", "Sounds/bricksynth3.wav");
            await audioService.PreloadSoundAsync("wall", "Sounds/brickglass.wav");
            await audioService.PreloadSoundAsync("start", "Sounds/gamestart.wav");
            await audioService.PreloadSoundAsync("ball", "Sounds/pong.wav");
            await audioService.PreloadSoundAsync("bip", "Sounds/bip.wav");
            await audioService.PreloadSoundAsync("bip1", "Sounds/bip1.wav");
            await audioService.PreloadSoundAsync("bip2", "Sounds/bip2.wav");

            await audioService.PreloadSoundAsync("one", "Sounds/one.wav");
            await audioService.PreloadSoundAsync("two", "Sounds/two.wav");

            // Background music files will be streamed directly for memory efficiency
            // Both SoundFlow and AudioMixer now support streaming from files

            // Preload background music
            //we need to preload as Soundflow actually has a problem to get valid Length when reading from mobile file
            //so in the future we could play from file when its fixed
            await audioService.PreloadSoundAsync("demo", "Music/demoHypnoticPuzzle4.mp3");
            await audioService.PreloadSoundAsync("play", "Music/lvl1PixelCityGroovin.mp3");
            await audioService.PreloadSoundAsync("speedy", "Music/MonkeyDrama.mp3");
            await audioService.PreloadSoundAsync("tronic", "Music/TechnoTronic.mp3");

            _audioService = audioService;

            var soundsOn = AppSettings.Get(AppSettings.SoundsOn, AppSettings.SoundsOnDefault);
            EnableSounds(soundsOn);

            SetupBackgroundMusic();
        }


        public void PlaySound(Sound sound, System.Numerics.Vector3 position = default)
        {
            if (_audioService == null || !soundsOn)
                return;

            if (State == GameState.DemoPlay && !USE_SOUND_IN_DEMO)
            {
                return;
            }

            Tasks.StartDelayedAsync(TimeSpan.FromMicroseconds(1), async () =>
            {
                if (position == default)
                {
                    position = new Vector3(01f, 1, 1f);
                }

                switch (sound)
                {
                case Sound.Board:
                _audioService.PlaySpatialSound("ball", position, 0.5f);
                break;
                case Sound.Brick:
                _audioService.PlaySpatialSound("board2", position);
                break;
                case Sound.Wall:
                _audioService.PlaySpatialSound("board3", position, 0.5f);
                break;
                case Sound.Oops:
                _audioService.PlaySound("oops", 0.75f);
                break;
                case Sound.Joy:
                _audioService.PlaySound("joy", 0.95f);
                break;
                case Sound.Sad:
                _audioService.PlaySound("sad", 0.95f);
                break;
                case Sound.Dialog:
                _audioService.PlaySound("dlg", 0.75f);
                break;
                case Sound.Selection:
                _audioService.PlaySound("sel", 0.75f);
                break;
                case Sound.Start:
                _audioService.PlaySound("start", 0.75f);
                break;
                case Sound.PowerUp:
                //_audioService.PlaySound("powerup", 0.5f);
                break;
                case Sound.PowerDown:
                //_audioService.PlaySound("powerdown", 0.33f);
                break;
                case Sound.Attack:
                _audioService.PlaySound("aggro", 0.66f);
                break;
                }
            });
        }


        public void PlaySpecialMusic()
        {
            var musicOn = AppSettings.Get(AppSettings.MusicOn, AppSettings.MusicOnDefault);

            if (musicOn && State == GameState.Playing)
            {
                //_audioService.StartBackgroundMusicFromFile("Music/MonkeyDrama.mp3", 1.0f);
                _audioService?.StartBackgroundMusic("tronic", 1.0f);
            }
        }

        public void PlaySpeedyMusic()
        {
            var musicOn = AppSettings.Get(AppSettings.MusicOn, AppSettings.MusicOnDefault);

            if (musicOn && State == GameState.Playing)
            {
                //_audioService.StartBackgroundMusicFromFile("Music/MonkeyDrama.mp3", 1.0f);
                _audioService?.StartBackgroundMusic("speedy", 1.0f);
            }
        }

        public void SetupBackgroundMusic()
        {
            var musicOn = AppSettings.Get(AppSettings.MusicOn, AppSettings.MusicOnDefault);
            SetupBackgroundMusic(musicOn);
        }

        protected void SetupBackgroundMusic(bool isOn)
        {
            if (!isOn)
            {
                StopBackgroundMusic();
            }
            else
            {
                if (State == GameState.Playing)
                {
                    PlayMusicLooped(Level);
                }
                else
                {
                    PlayMusicLooped(0);
                }
            }
        }

        public void ToggleSound()
        {
            if (_audioService == null)
            {
                return;
            }

            _audioService.IsMuted = !_audioService.IsMuted;
        }

        /// <summary>
        /// Starts the background music loop using efficient file streaming
        /// </summary>
        public void PlayMusicLooped(int lvl)
        {
            if (_audioService == null || !AppSettings.Get(AppSettings.MusicOn, AppSettings.MusicOnDefault))
            {
                return;
            }

            // Stream background music directly from files (memory efficient)
            if (lvl > 0)
            {
                //_audioService.StartBackgroundMusicFromFile("Music/lvl1PixelCityGroovin.mp3", 1.0f);
                _audioService?.StartBackgroundMusic("play", 1.0f);
            }
            else
            {
                //_audioService.StartBackgroundMusicFromFile("Music/demoHypnoticPuzzle4.mp3", 0.5f);
                _audioService?.StartBackgroundMusic("demo", 1.0f);
            }
        }

        /// <summary>
        /// Stops the background music
        /// </summary>
        public void StopBackgroundMusic()
        {
            _audioService?.StopBackgroundMusic();
        }

        /// <summary>
        /// Sets the background music volume
        /// </summary>
        /// <param name="volume">Volume level (0.0 to 1.0)</param>
        public void SetBackgroundMusicVolume(float volume)
        {
            _audioService?.SetSoundVolume("background", volume);
        }

        /// <summary>
        /// Gets whether background music is currently playing
        /// </summary>
        public bool IsBackgroundMusicPlaying => _audioService?.IsBackgroundMusicPlaying == true;

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Ui.cs ---
using System.Diagnostics;
using AppoMobi.Maui.Gestures;
using Breakout.Game.Controls;
using Breakout.Game.Dialogs;
using Breakout.Game.Input;
using SkiaSharp;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region UI

        // Ball management for multiball support
        private List<BallSprite> _activeBalls = new();
        public IReadOnlyList<BallSprite> ActiveBalls => _activeBalls.AsReadOnly();

        public PaddleSprite Paddle;
        public SkiaLayout GameField;
        private SkiaLayout BricksContainer;

        #region BALL MANAGEMENT

        /// <summary>
        /// Adds a new ball to the game from the pool
        /// </summary>
        public BallSprite AddBall()
        {
            if (BallsPool.Count > 0)
            {
                var ball = BallsPool.Get();
                if (ball != null)
                {
                    ball.IsActive = true;
                    _activeBalls.Add(ball);
                    GameField.AddSubView(ball);
                    return ball;
                }
            }
            return null;
        }

        /// <summary>
        /// Removes a ball from the game and returns it to the pool
        /// </summary>
        public void RemoveBall(BallSprite ball)
        {
            if (ball != null && _activeBalls.Remove(ball))
            {
                ball.IsActive = false;
                GameField.RemoveSubView(ball);
                BallsPool.Return(ball);
            }
        }

        /// <summary>
        /// Removes all balls and returns them to the pool
        /// </summary>
        public void ClearAllBalls()
        {
            foreach (var ball in _activeBalls.ToList())
            {
                RemoveBall(ball);
            }
            _activeBalls.Clear();
        }

        #endregion

        /// <summary>
        /// Redraw game labels re-open dialog when we change language
        /// </summary>
        public void RedrawFromOptions()
        {
            OnPropertyChanged(nameof(Level));
            OnPropertyChanged(nameof(Score));
            OnPropertyChanged(nameof(State));
            State = PreviousState;
            ShowOptions();
        }

        void CreateUi()
        {
            HorizontalOptions = LayoutOptions.Fill;
            VerticalOptions = LayoutOptions.Fill;
            BackgroundColor = Colors.DarkSlateBlue.WithAlpha(0.975f);

            Children = new List<SkiaControl>()
            {
                //game and controls below
                new SkiaStack()
                {
                    Tag = "GameStack",
                    VerticalOptions = LayoutOptions.Fill,
                    Spacing = 0,
                    Children =
                    {
                        //GAME FIELD
                        new SkiaLayer()
                        {
                            IsClippedToBounds = true, // clip powerups
                            VerticalOptions = LayoutOptions.Fill,
                            //HeightRequest = 500,
                            Children =
                            {
                                //all bricks inside one layer draw cached if unchanged
                                new SkiaLayout()
                                {
                                    UseCache = SkiaCacheType.ImageComposite, //critical for perf
                                    HorizontalOptions = LayoutOptions.Center,
                                    Margin = new(0,90,0,0),
                                }.Assign(out BricksContainer),

                                // Ball will be created via AddBall() method during ResetBall()

                                new PaddleSprite()
                                {
                                    ZIndex = 5,
                                    Top = -28
                                }.Assign(out Paddle),

                                //SCORE TOP BAR
                                new SkiaLayer()
                                {
                                    ZIndex = 110,
                                    UseCache = SkiaCacheType.GPU,
                                    Children =
                                    {
                                        //SCORE/DEMO
                                        new SkiaRichLabel()
                                        {
                                            UseCache = SkiaCacheType.Operations,
                                            Margin = 16,
                                            FontFamily = AppFonts.GameAutoselect,
                                            FontSize = 17 * AppFonts.GameAdjustSize,
                                            StrokeColor = AmstradColors.DarkBlue,
                                            TextColor = AmstradColors.White,
                                            DropShadowColor = Colors.DarkBlue,
                                            DropShadowOffsetX = 2,
                                            DropShadowOffsetY = 2,
                                            DropShadowSize = 2,
                                            FillGradient = new()
                                            {
                                                Colors = new List<Color>()
                                                {
                                                    Colors.White,
                                                    Colors.CornflowerBlue
                                                }
                                            }
                                        }
                                        .ObserveProperties(this, [nameof(Score), nameof(State)], me =>
                                        {
                                            me.FontFamily = AppFonts.GameAutoselect;
                                            me.FontSize = 17 * AppFonts.GameAdjustSize;

                                            if (State == GameState.DemoPlay)
                                            {
                                                me.Text = ResStrings.DemoMode.ToUpperInvariant();
                                            }
                                            else
                                            {
                                                me.Text = $"{ResStrings.Score.ToUpperInvariant()}: {Score:0}";
                                            }
                                        }),

                                        //LEVEL
                            
                                        new SkiaRichLabel()
                                        {
                                            UseCache = SkiaCacheType.Operations,
                                            Margin = 16,
                                            HorizontalOptions = LayoutOptions.End,
                                            FontFamily = AppFonts.GameAutoselect,
                                            FontSize = 17* AppFonts.GameAdjustSize,
                                            StrokeColor = AmstradColors.DarkBlue,
                                            TextColor = AmstradColors.White,
                                            DropShadowColor = Colors.DarkBlue,
                                            DropShadowOffsetX = 2,
                                            DropShadowOffsetY = 2,
                                            DropShadowSize = 2,
                                            FillGradient = new()
                                            {
                                                Colors = new List<Color>()
                                                {
                                                    Colors.White,
                                                    Colors.CornflowerBlue
                                                }
                                            }
                                        }
                                        .ObserveProperty(this, nameof(Level), me =>
                                        {
                                            me.FontFamily = AppFonts.GameAutoselect;
                                            me.FontSize = 17 * AppFonts.GameAdjustSize;

                                            me.Text = $"{ResStrings.Lev.ToUpperInvariant()}: {Level}";
                                        }),
                                 

                                        //LIVES
                                        new SkiaLayout()
                                        {
                                            UseCache = SkiaCacheType.Image,
                                            HorizontalOptions = LayoutOptions.Start,
                                            Type = LayoutType.Row,
                                            Spacing = 3,
                                            Margin = new (16,60,16,0),
                                            ItemTemplateType = typeof(LifeSprite)
                                        }
                                        .ObserveProperties(this, [nameof(Lives), nameof(State)], me =>
                                        {
                                            //if (State == GameState.DemoPlay)
                                            //{
                                            //    me.IsVisible = false;
                                            //}
                                            //else
                                            {
                                                me.IsVisible = true;
                                                me.ItemsSource = Enumerable.Repeat(1, Lives).ToArray();
                                            }
                                            Debug.WriteLine($"LIVES: {Lives}");
                                        }),
                                    }
                                }
                            }
                        }.Assign(out GameField),

                        //CONTROLS
                        new StableCacheLayout()
                        {
                            HeightRequest = 80,
                            HorizontalOptions = LayoutOptions.Fill,
                            UseCache = SkiaCacheType.GPU,
                            BackgroundColor = Color.Parse("#66000000"),
                            Children =
                            {
                                new SkiaSvg()
                                {
                                    Opacity = 0.85,
                                    UseCache = SkiaCacheType.Image,
                                    SvgString = App.Current.Resources.Get<string>("SvgSettings"),
                                    WidthRequest = 56,
                                    LockRatio = 1,
                                    VerticalOptions = LayoutOptions.Center,
                                    Margin = new (12,0,0,0),
                                }
                                .OnTapped(me =>
                                {
                                    TogglePause();

                                    //var dlgOptions = GameDialog.GetTopDialog(this);
                                    //if (dlgOptions!=null && dlgOptions.Content.Tag == "Options")
                                    //{
                                    //    _ = dlgOptions.CloseAsync(true, true);
                                    //}
                                    //else
                                    //{
                                    //    this.ShowOptions();
                                    //}
                                }),


                                //ARROWS
                                new HudArrows(this)
                                {
                                    Margin = new (80,0,16,0),
                                    HorizontalOptions = LayoutOptions.Fill,
                                    VerticalOptions = LayoutOptions.Fill,
                                    UseCache = SkiaCacheType.Operations,
                                    ColumnSpacing = 20,
                                    Children=
                                    {
                                        new SkiaSvg()
                                        {
                                            Opacity = 0.75,
                                            TintColor = UiElements.ColorPrimary,
                                            UseCache = SkiaCacheType.Image,
                                            SvgString = App.Current.Resources.Get<string>("SvgLeft"),
                                            WidthRequest = 56,
                                            LockRatio = 1,
                                            HorizontalOptions = LayoutOptions.End,
                                            VerticalOptions = LayoutOptions.Center,
                                        },
                                        new SkiaSvg()
                                        {
                                            HorizontalOptions = LayoutOptions.Start,
                                            TintColor = UiElements.ColorPrimary,
                                            Opacity = 0.75,
                                            UseCache = SkiaCacheType.Image,
                                            SvgString = App.Current.Resources.Get<string>("SvgRight"),
                                            WidthRequest = 56,
                                            LockRatio = 1,
                                            VerticalOptions = LayoutOptions.Center,
                                        }.WithColumn(1),
                                        
                                        //we will add hotspots in code-behind

                                    }
                                }.WithColumnDefinitions("50*, 50*"),


                                /*
                                new SkiaSvg()
                                    {
                                        Opacity = 0.75,
                                        UseCache = SkiaCacheType.Image,
                                        SvgString = App.Current.Resources.Get<string>("SvgUser"),
                                        WidthRequest = 56,
                                        LockRatio = 1,
                                        HorizontalOptions = LayoutOptions.End,
                                        VerticalOptions = LayoutOptions.Center,
                                        Margin = new (0,0,12,0),
                                    }
                                    .OnTapped(me =>
                                    {
                                        //profile
                                    })
                                */
                            }
                        }
                    }
                },
            };
        }

        #endregion

        public static class UiElements
        {

            public static Color ColorPrimary = Colors.HotPink;
            public static Color ColorPrimaryDark = Colors.DeepPink;

            public static Color ColorIconSecondary = Colors.DarkGray;

            public static SkiaControl DialogPrompt(string prompt)
            {
                return new SkiaRichLabel() //will auto-find installed font for missing glyphs
                {
                    Text = prompt,
                    UseCache = SkiaCacheType.Image,
                    HorizontalTextAlignment = DrawTextAlignment.Center,
                    HorizontalOptions = LayoutOptions.Fill,
                    FontFamily = AppFonts.Default,
                    LineHeight = 1,
                    LineSpacing = 0,
                    CharacterSpacing = 1.33,
                    FontSize = 18,
                    TextColor = AmstradColors.White,

                    //StrokeColor = AmstradColors.DarkBlue,
                    //DropShadowColor = Colors.DarkBlue,
                    //DropShadowOffsetX = 1,
                    //DropShadowOffsetY = 1,
                    //DropShadowSize = 1,
                };
            }

            public static void SetButtonPressed(SkiaShape btn)
            {
                btn.Children[0].TranslationX = 1;
                btn.Children[0].TranslationY = 1;
                btn.BevelType = BevelType.Emboss;
            }

            public static void SetButtonReleased(SkiaShape btn)
            {
                btn.Children[0].TranslationX = 0;
                btn.Children[0].TranslationY = 0;
                btn.BevelType = BevelType.Bevel;
            }


            public static SkiaShape Button(string caption, Action action)
            {
                return new SelectableGameButton()
                {
                    UseCache = SkiaCacheType.Image,
                    CornerRadius = 8,
                    MinimumWidthRequest = 100,
                    BackgroundColor = Colors.Black,
                    BevelType = BevelType.Bevel,
                    Bevel = new SkiaBevel()
                    {
                        Depth = 2,
                        LightColor = Colors.White,
                        ShadowColor = Colors.DarkBlue,
                        Opacity = 0.33,
                    },
                    Children =
                    {
                        new SkiaRichLabel()
                        {
                            Text = caption,
                            Margin = new Thickness(16, 8,16,10),
                            UseCache = SkiaCacheType.Operations,
                            HorizontalOptions = LayoutOptions.Center,
                            VerticalOptions = LayoutOptions.Center,
                            FontSize = 14 * AppFonts.GameAdjustSize,
                            FontFamily = AppFonts.GameAutoselect,
                            TextColor = Colors.White,
                        }
                    },
                    FillGradient = new SkiaGradient()
                    {
                        StartXRatio = 0,
                        EndXRatio = 1,
                        StartYRatio = 0,
                        EndYRatio = 0.5f,
                        Colors = new Color[]
                        {
                            UiElements.ColorPrimary,
                            UiElements.ColorPrimaryDark,
                        }
                    },
                }.WithGestures((me, args, b) =>
                {
                    if (args.Type == TouchActionResult.Tapped)
                    {
                        action?.Invoke();
                    }
                    else if (args.Type == TouchActionResult.Down)
                    {
                        SetButtonPressed(me);
                    }
                    else if (args.Type == TouchActionResult.Up)
                    {
                        SetButtonReleased(me);
                        return null;
                    }

                    return me;
                });
            }
        }
    }

    public static class AmstradColors
    {
        public static readonly Color Black = Color.Parse("#000000");
        public static readonly Color Blue = Color.Parse("#0000FF");
        public static readonly Color Red = Color.Parse("#FF0000");
        public static readonly Color Magenta = Color.Parse("#FF00FF");
        public static readonly Color Green = Color.Parse("#00FF00");
        public static readonly Color Cyan = Color.Parse("#00FFFF");
        public static readonly Color Yellow = Color.Parse("#FFFF00");
        public static readonly Color White = Color.Parse("#FFFFFF");
        public static readonly Color Grey = Color.Parse("#808080");
        public static readonly Color BrightBlue = Color.Parse("#0080FF");
        public static readonly Color BrightRed = Color.Parse("#FF8080");
        public static readonly Color BrightMagenta = Color.Parse("#FF80FF");
        public static readonly Color BrightGreen = Color.Parse("#80FF80");
        public static readonly Color BrightCyan = Color.Parse("#80FFFF");
        public static readonly Color BrightYellow = Color.Parse("#FFFF80");
        public static readonly Color BrightWhite = Color.Parse("#C0C0C0");
        public static readonly Color DarkBlue = Color.Parse("#000080");
        public static readonly Color DarkRed = Color.Parse("#800000");
        public static readonly Color DarkMagenta = Color.Parse("#800080");
        public static readonly Color DarkGreen = Color.Parse("#008000");
        public static readonly Color DarkCyan = Color.Parse("#008080");
        public static readonly Color DarkYellow = Color.Parse("#808000");
        public static readonly Color DarkGrey = Color.Parse("#404040");
        public static readonly Color MidBlue = Color.Parse("#4040FF");
        public static readonly Color MidRed = Color.Parse("#FF4040");
        public static readonly Color MidGreen = Color.Parse("#40FF40");
        public static readonly Color MidCyan = Color.Parse("#40FFFF");

        // Optional: A method to get all colors as an array
        public static Color[] GetAllColors()
        {
            return new[]
            {
            Black, Blue, Red, Magenta, Green, Cyan, Yellow, White, Grey,
            BrightBlue, BrightRed, BrightMagenta, BrightGreen, BrightCyan, BrightYellow, BrightWhite,
            DarkBlue, DarkRed, DarkMagenta, DarkGreen, DarkCyan, DarkYellow, DarkGrey,
            MidBlue, MidRed, MidGreen, MidCyan
        };
        }
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Ui.Dialogs.cs ---
using AppoMobi.Specials;
using Breakout.Game.Dialogs;
using Breakout.Game.Input;
using Breakout.Helpers;
using DrawnUi.Controls;
using System.Globalization;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region DIALOGS

        void InitDialogs()
        {
            GameDialog.DefaultTemplate = DialogThemes.Game;
        }

        void ShowWelcomeDialog()
        {
#if WINDOWS || MACCATALYST
            var message = ResStrings.MessageWelcomeDesktop;
#else
            var message = ResStrings.MessageWelcome;
#endif
            GameDialog.Show(this,
                UiElements.DialogPrompt(message),
                ResStrings.StartGame.ToUpperInvariant(), onOk: () => { StartNewGamePlayer(); });
        }

        void ShowGameOverDialog()
        {
            PlaySound(Sound.Sad);

            // Show game over dialog
            var gameOverContent = UiElements.DialogPrompt(string.Format(ResStrings.MessageGameOver, Score));

            GameDialog.Show(this, gameOverContent, ResStrings.BtnPlayAgain.ToUpperInvariant(),
                onOk: () =>
                {
                    State = GameState.Playing;
                    ResetGame();
                });
        }

        async void ShowLevelCompleteDialog()
        {
            PlaySound(Sound.Joy);

            // Show level complete dialog
            var levelCompleteContent =
                UiElements.DialogPrompt(string.Format(ResStrings.MessageLevelComplete, Level - 1, Score, Level));
            if (await GameDialog.ShowAsync(this, levelCompleteContent, ResStrings.BtnContinue.ToUpperInvariant()))
            {
                // Start the new level
                State = GameState.Playing;
                StartNewLevel();
            }
        }

        /// <summary>
        /// Shows the options dialog with game settings like music toggle
        /// </summary>
        public void ShowOptions()
        {
            PlaySound(Sound.Dialog);

            _ = GameDialog.PopAll(this);

            // Pause the game if currently playing
            State = GameState.Paused;
            IsMovingLeft = false;
            IsMovingRight = false;

            // Create options dialog content
            var optionsContent = CreateOptionsDialogContent();

            void OnClose()
            {
                Tasks.StartDelayed(TimeSpan.FromMilliseconds(50), () =>
                {
                    TogglePause();
                });
            }

            // Show the dialog
            GameDialog.Show(this, optionsContent, ResStrings.BtnClose.ToUpperInvariant(), null,
                onOk: () =>
                {
                    OnClose();
                });
        }





        /// <summary>
        /// Creates the content for the options dialog
        ///
        ///
        ///
        /// 
        /// </summary>
        private SkiaControl CreateOptionsDialogContent()
        {
            // Create the options layout
            var optionsLayout = new SkiaLayout()
            {
                Tag = "Options",
                Type = LayoutType.Column,
                Spacing = 20,
                Padding = new Thickness(16,16,16,-12),
                HorizontalOptions = LayoutOptions.Fill,
                Children = new List<SkiaControl>
                {
                    // Title
                    new SkiaRichLabel()
                    {
                        Text = ResStrings.Options.ToUpperInvariant(),
                        FontFamily = AppFonts.Default,
                        FontSize = 24,
                        TextColor = AmstradColors.White,
                        HorizontalTextAlignment = DrawTextAlignment.Center,
                        HorizontalOptions = LayoutOptions.Fill,
                        UseCache = SkiaCacheType.Operations
                    },

                    // LANGUAGE setting row
                    new OptionWithTappable("LangFlag")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //SOUND FX
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Language.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,

                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },
                            new DisplayFlag()
                                {
                                    Tag="LangFlag",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    var lang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
                                    me.Lang = lang;
                                })
                                .OnTapped((me, a) =>
                                {
                                    //is this a real tap?
                                    if (a.Parameters.Event != null)
                                    {
                                        AppLanguage.SelectAndSet();
                                    }
                                    else
                                    {
                                        //controller
                                        AppLanguage.SelectNextAndSet();
                                    }
                                }),
                        }
                    },

                    // SOUND setting row
                    new OptionWithTappable("SoundSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //SOUND FX
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Sounds.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },
                            new GameSwitch()
                                {
                                    Tag="SoundSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.SoundsOn,
                                            AppSettings.SoundsOnDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    if (_audioService != null)
                                    {
                                        EnableSounds(state);
                                        AppSettings.Set(AppSettings.SoundsOn, state);
                                    }
                                }),
                        }
                    },

                    // Music setting row - selectable
                    new OptionWithTappable("MusicSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //MUSIC
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Music.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },

                            new GameSwitch()
                                {
                                    Tag = "MusicSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.MusicOn,
                                            AppSettings.MusicOnDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    if (_audioService != null)
                                    {
                                        AppSettings.Set(AppSettings.MusicOn, state);
                                        if (state)
                                        {
                                            if (PreviousState == GameState.Playing)
                                            {
                                                PlayMusicLooped(Level);
                                            }
                                            else
                                            {
                                                PlayMusicLooped(0);
                                            }
                                        }
                                        else
                                        {
                                            StopBackgroundMusic();
                                        }
                                    }
                                }),
                        }
                    },

                    // Press input mode for HUD
                    new OptionWithTappable("HudSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.PressHud.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },

                            new GameSwitch()
                                {
                                    Tag="HudSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.InputPressEnabled,
                                            AppSettings.InputPressEnabledDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    SetInputPressMode(state);
                                }),
                        }
                    },

                    //DEMO
                    UiElements.Button(ResStrings.DemoMode.ToUpperInvariant(), async () =>
                    {
                        StartNewGameDemo();
                    }).FillX().WithMargin(new Thickness(0,16,0,-16)),

                    //RESTART
                    UiElements.Button(ResStrings.NewGame.ToUpperInvariant(), async () =>
                    {
                        StartNewGamePlayer();
                    }).FillX().WithMargin(new Thickness(0,16,0,0)),

                }
            };

            return optionsLayout;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGameExtensions.cs ---
using SkiaSharp;

namespace Breakout.Game;

/// <summary>
/// Extension methods for the Breakout game
/// </summary>
public static class BreakoutGameExtensions
{
    /// <summary>
    /// Identifies the collision face based on overlap rectangle
    /// </summary>
    /// <param name="overlap">The overlap rectangle</param>
    /// <param name="targetRect">The target rectangle</param>
    /// <returns>The collision face (Top, Bottom, Left, Right)</returns>
    public static CollisionFace GetCollisionFace(this SKRect overlap, SKRect targetRect)
    {
        // Calculate penetration depths for each edge
        float leftPenetration = overlap.Right;
        float rightPenetration = targetRect.Width - overlap.Left;
        float topPenetration = overlap.Bottom;
        float bottomPenetration = targetRect.Height - overlap.Top;

        // Find minimum penetration
        float minPenetration = MathF.Min(
            MathF.Min(leftPenetration, rightPenetration),
            MathF.Min(topPenetration, bottomPenetration)
        );

        // Return face with minimum penetration
        if (minPenetration == leftPenetration)
            return CollisionFace.Left;
        else if (minPenetration == rightPenetration)
            return CollisionFace.Right;
        else if (minPenetration == topPenetration)
            return CollisionFace.Top;
        else
            return CollisionFace.Bottom;
    }
}

--- C:\code\DrawnUi\src\Game\Ai\AIDifficulty.cs ---
namespace Breakout.Game.Ai;

/// <summary>
/// Represents AI difficulty levels for demo play
/// </summary>
public enum AIDifficulty
{
    Easy,
    Medium,
    Hard,
    Perfect  // For testing - never misses
}

--- C:\code\DrawnUi\src\Game\Ai\AIPaddleController.cs ---
using Breakout.Game.Input;

namespace Breakout.Game.Ai
{
    /// <summary>
    /// Controls the paddle in demo mode, simulating a human player with variable skill
    /// </summary>
    public class AIPaddleController
    {
        private readonly BreakoutGame _game;
        private readonly Random _random = new Random();
        private double _targetX;
        private float _reactionTimer;
        private float _mistakeTimer;
        private float _decisionChangeTimer;
        private float _movementSmoothingTimer;
        private bool _makingMistake;
        private float _mistakeDirection;
        private bool _canFire = true;
        private bool _isMoving = false;
        private GameKey _lastMovementKey = GameKey.Stop;
        private float _idleWanderTimer = 0;
        private float _idleWanderInterval = 0.8f;
        private float _shootingTimer = 0;
        private float _shootingInterval = 0.3f; // Shoot every 300ms when in destroyer mode

        // AI characteristics
        private readonly float _reactionTimeMin;
        private readonly float _reactionTimeMax;
        private readonly float _accuracy;
        private readonly float _mistakeProbability;
        private readonly float _mistakeDurationMin;
        private readonly float _mistakeDurationMax;
        private float _decisionChangeInterval;
        private readonly float _serveDelay;
        private readonly float _movementSmoothingTime;

        /// <summary>
        /// Creates a new AI paddle controller with specified difficulty
        /// </summary>
        /// <param name="game">Reference to the main game</param>
        /// <param name="difficulty">AI difficulty level</param>
        public AIPaddleController(BreakoutGame game, AIDifficulty difficulty = AIDifficulty.Medium)
        {
            _game = game;

            // Set AI characteristics based on difficulty
            switch (difficulty)
            {
            case AIDifficulty.Easy:
            _reactionTimeMin = 0.5f;
            _reactionTimeMax = 1.2f;
            _accuracy = 0.6f;
            _mistakeProbability = 0.4f;
            _mistakeDurationMin = 0.8f;
            _mistakeDurationMax = 1.5f;
            _decisionChangeInterval = 1.0f;
            _serveDelay = 2.0f;
            _movementSmoothingTime = 0.3f;
            break;

            case AIDifficulty.Hard:
            _reactionTimeMin = 0.05f;  // Much faster reaction
            _reactionTimeMax = 0.15f;  // Reduced from 0.4f
            _accuracy = 0.98f;         // Increased from 0.9f
            _mistakeProbability = 0.02f; // Reduced from 0.1f
            _mistakeDurationMin = 0.1f;  // Reduced from 0.2f
            _mistakeDurationMax = 0.2f;  // Reduced from 0.5f
            _decisionChangeInterval = 3.0f; // Increased from 2.0f
            _serveDelay = 0.5f;        // Reduced from 0.8f
            _movementSmoothingTime = 0.05f; // Reduced from 0.1f
            break;

            case AIDifficulty.Medium:
            default:
            _reactionTimeMin = 0.25f;
            _reactionTimeMax = 0.7f;
            _accuracy = 0.75f;
            _mistakeProbability = 0.2f;
            _mistakeDurationMin = 0.4f;
            _mistakeDurationMax = 0.9f;
            _decisionChangeInterval = 1.5f;
            _serveDelay = 1.5f;
            _movementSmoothingTime = 0.2f;
            break;

            case AIDifficulty.Perfect:
            _reactionTimeMin = 0.01f;
            _reactionTimeMax = 0.02f;
            _accuracy = 1.0f;          // Perfect accuracy
            _mistakeProbability = 0.0f; // No mistakes
            _mistakeDurationMin = 0.0f;
            _mistakeDurationMax = 0.0f;
            _decisionChangeInterval = 5.0f;
            _serveDelay = 0.2f;
            _movementSmoothingTime = 0.01f;
            break;
            }

            ResetTimers();
        }

        /// <summary>
        /// Resets all AI decision timers
        /// </summary>
        public void ResetTimers()
        {
            _reactionTimer = GetRandomReactionTime();
            _mistakeTimer = 0;
            _decisionChangeTimer = _serveDelay; // Initial delay before serving
            _movementSmoothingTimer = 0;
            _makingMistake = false;
            _mistakeDirection = 0;
            _canFire = true;
            _isMoving = false;
            _lastMovementKey = GameKey.Stop;
            _idleWanderTimer = 0;
            _shootingTimer = 0;
        }

        /// <summary>
        /// Updates the AI paddle position based on ball trajectory and AI characteristics
        /// </summary>
        /// <param name="deltaTime">Time since last frame</param>
        public void UpdateAI(float deltaTime)
        {
            // Update shooting timer for destroyer mode
            _shootingTimer -= deltaTime;

            // If paddle has destroyer powerup, shoot at bricks
            if (_game.Paddle.Powerup == PowerupType.Destroyer && _shootingTimer <= 0)
            {
                _game.ApplyGameKey(GameKey.Fire);
                _shootingTimer = _shootingInterval + _random.NextSingle() * 0.2f;
            }

            // If no balls are moving, handle serving
            if (_game.ActiveBalls.Count == 0 || !_game.ActiveBalls.Any(b => b.IsMoving))
            {
                IdleWandering(deltaTime);
                _decisionChangeTimer -= deltaTime;
                if (_decisionChangeTimer <= 0 && _canFire)
                {
                    _game.ApplyGameKey(GameKey.Fire);
                    _canFire = false;
                    _decisionChangeTimer = _decisionChangeInterval;
                }
                return;
            }

            _canFire = true;
            _reactionTimer -= deltaTime;
            _movementSmoothingTimer -= deltaTime;

            // Handle mistakes
            if (_makingMistake)
            {
                _mistakeTimer -= deltaTime;
                if (_mistakeTimer <= 0)
                {
                    _makingMistake = false;
                    _reactionTimer = GetRandomReactionTime();

                    // Stop movement after mistake
                    StopMovement();
                }
                else
                {
                    // Apply mistake movement
                    if (_mistakeDirection < 0 && _lastMovementKey != GameKey.Left)
                    {
                        _game.ApplyGameKey(GameKey.Left);
                        _lastMovementKey = GameKey.Left;
                        _isMoving = true;
                    }
                    else if (_mistakeDirection > 0 && _lastMovementKey != GameKey.Right)
                    {
                        _game.ApplyGameKey(GameKey.Right);
                        _lastMovementKey = GameKey.Right;
                        _isMoving = true;
                    }
                    else if (_mistakeDirection == 0 && _isMoving)
                    {
                        StopMovement();
                    }
                    return;
                }
            }

            _decisionChangeTimer -= deltaTime;
            if (_decisionChangeTimer <= 0)
            {
                // Decide whether to make a mistake
                if (!_makingMistake && _random.NextDouble() < _mistakeProbability)
                {
                    _makingMistake = true;
                    _mistakeTimer = _random.NextSingle() *
                        (_mistakeDurationMax - _mistakeDurationMin) + _mistakeDurationMin;

                    // Either move in a random direction or stay still
                    if (_random.NextDouble() < 0.7)
                    {
                        _mistakeDirection = _random.NextDouble() < 0.5 ? -1 : 1;
                    }
                    else
                    {
                        _mistakeDirection = 0; // Stay still as a "mistake"
                    }
                }

                _decisionChangeInterval = 0.5f + _random.NextSingle();
                _decisionChangeTimer = _decisionChangeInterval;
            }

            // If making a mistake, continue with that
            if (_makingMistake)
            {
                if (_mistakeDirection < 0 && _lastMovementKey != GameKey.Left)
                {
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
                else if (_mistakeDirection > 0 && _lastMovementKey != GameKey.Right)
                {
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
                else if (_mistakeDirection == 0 && _isMoving)
                {
                    StopMovement();
                }
                return;
            }

            // Find the closest ball that's coming down
            var closestBall = _game.ActiveBalls
                .Where(ball => ball.IsMoving && MathF.Sin(ball.Angle) > 0) // Coming down
                .OrderBy(ball => ball.Top) // Closest to paddle
                .FirstOrDefault();

            if (closestBall != null)
            {
                // BALL IS COMING DOWN - PRIORITIZE BALL, but try powerups if safe
                if (_reactionTimer <= 0)
                {
                    // Calculate ball trajectory first
                    var ballX = closestBall.Left;
                    var ballY = closestBall.Top;
                    var paddleY = _game.Paddle.Top;

                    var ballVelX = MathF.Cos(closestBall.Angle) * BreakoutGame.BALL_SPEED * closestBall.SpeedRatio;
                    var ballVelY = MathF.Sin(closestBall.Angle) * BreakoutGame.BALL_SPEED * closestBall.SpeedRatio;

                    var timeToIntersect = (paddleY - ballY) / ballVelY;

                    if (timeToIntersect > 0)
                    {
                        var predictedX = ballX + ballVelX * timeToIntersect;
                        var accuracyBonus = _game.Paddle.Powerup == PowerupType.Destroyer ? 0.1f : 0f;
                        var effectiveAccuracy = Math.Min(1.0f, _accuracy + accuracyBonus);
                        var maxError = (1 - effectiveAccuracy) * _game.Paddle.Width;
                        var error = (_random.NextSingle() * 2 - 1) * maxError;

                        // Handle wall bounces
                        var halfGameWidth = _game.Width / 2;
                        while (predictedX < -halfGameWidth || predictedX > halfGameWidth)
                        {
                            if (predictedX < -halfGameWidth)
                                predictedX = -halfGameWidth - (predictedX + halfGameWidth);
                            else
                                predictedX = halfGameWidth - (predictedX - halfGameWidth);
                        }

                        _targetX = predictedX + error;
                        _reactionTimer = GetRandomReactionTime();

                        // Check if we have time to grab a powerup on the way
                        if (timeToIntersect > 2.0f && CheckForPowerupsToCollect())
                        {
                            // Go for powerup if we have plenty of time
                            return;
                        }
                        
                        // Otherwise focus on ball
                        MovePaddleTowardTarget();
                        return;
                    }
                }
            }
            else
            {
                // BALL IS FLYING UP - SAFE! PRIORITIZE POWERUPS!
                if (CheckForPowerupsToCollect())
                {
                    return; // Going for powerup
                }
                
                // No powerups, do some idle movement
                if (_movementSmoothingTimer <= 0)
                {
                    if (Math.Abs(_game.Paddle.Left) > _game.Paddle.Width && _random.NextDouble() < 0.2)
                    {
                        _targetX = _game.Paddle.Left > 0 ? -_game.Paddle.Width : _game.Paddle.Width;
                        MovePaddleTowardTarget();
                    }
                    else if (_isMoving && _random.NextDouble() < 0.3)
                    {
                        StopMovement();
                    }
                    _movementSmoothingTimer = _movementSmoothingTime;
                }
            }
        }

        /// <summary>
        /// Handles random paddle movement during idle periods (before serving)
        /// </summary>
        private void IdleWandering(float deltaTime)
        {
            _idleWanderTimer -= deltaTime;

            if (_idleWanderTimer <= 0)
            {
                _idleWanderTimer = _idleWanderInterval;
                _idleWanderInterval = 0.3f + _random.NextSingle() * 0.8f; // Random interval

                // Choose random movement or stop
                float decision = (float)_random.NextDouble();

                if (decision < 0.3f) // 30% chance to move left
                {
                    StopMovement();
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
                else if (decision < 0.6f) // 30% chance to move right
                {
                    StopMovement();
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
                else // 40% chance to stop
                {
                    StopMovement();
                }

                // Prevent paddle from going too far to edges while idle
                if (Math.Abs(_game.Paddle.Left) > _game.Width / 3f)
                {
                    // If too far right, move left
                    if (_game.Paddle.Left > 0)
                    {
                        StopMovement();
                        _game.ApplyGameKey(GameKey.Left);
                        _lastMovementKey = GameKey.Left;
                        _isMoving = true;
                    }
                    // If too far left, move right
                    else
                    {
                        StopMovement();
                        _game.ApplyGameKey(GameKey.Right);
                        _lastMovementKey = GameKey.Right;
                        _isMoving = true;
                    }
                }
            }
        }

        /// <summary>
        /// Moves paddle toward the calculated target position by applying appropriate keys
        /// </summary>
        private void MovePaddleTowardTarget()
        {
            if (_movementSmoothingTimer > 0)
                return;

            _movementSmoothingTimer = _movementSmoothingTime / 2; // Faster decision-making when chasing ball

            var distanceToTarget = _targetX - _game.Paddle.Left;

            // Add some "slop" - don't move for tiny differences (human-like behavior)
            var deadzone = _game.Paddle.Width * 0.15f;

            if (MathF.Abs((float)distanceToTarget) < deadzone)
            {
                // Close enough, stop movement
                if (_isMoving)
                {
                    StopMovement();
                }
                return;
            }

            // Move in the appropriate direction, but only send new command if direction changes
            if (distanceToTarget < 0)
            {
                if (_lastMovementKey != GameKey.Left)
                {
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
            }
            else
            {
                if (_lastMovementKey != GameKey.Right)
                {
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
            }
        }

        /// <summary>
        /// Stops paddle movement and updates state
        /// </summary>
        private void StopMovement()
        {
            _game.ApplyGameKey(GameKey.Stop);
            _lastMovementKey = GameKey.Stop;
            _isMoving = false;
        }

        private float GetRandomReactionTime()
        {
            return _random.NextSingle() * (_reactionTimeMax - _reactionTimeMin) + _reactionTimeMin;
        }

        /// <summary>
        /// Checks for falling powerups and decides whether to collect them
        /// </summary>
        private bool CheckForPowerupsToCollect()
        {
            PowerUpSprite targetPowerUp = null;
            double closestDistance = double.MaxValue;

            // Find ANY powerup that can be reached
            foreach (var view in _game.GameField.Views)
            {
                if (view is PowerUpSprite powerup && powerup.IsActive)
                {
                    var distance = Math.Abs(powerup.Left - _game.Paddle.Left);
                    var timeToReachPaddle = (powerup.Top - _game.Paddle.Top) / PowerUpSprite.FallSpeed;
                    
                    // Go for ANY powerup that's reachable - MUCH MORE AGGRESSIVE
                    if (timeToReachPaddle > 0.1f && distance < closestDistance)
                    {
                        closestDistance = distance;
                        targetPowerUp = powerup;
                    }
                }
            }

            // If we found any powerup, go for it aggressively
            if (targetPowerUp != null)
            {
                _targetX = targetPowerUp.Left;
                MovePaddleTowardTarget();
                return true; // Signal that we're going for a powerup
            }

            return false; // No powerups to collect
        }


    }
}

--- C:\code\DrawnUi\src\Game\Controls\DisplayFlag.cs ---
using AppoMobi.Specials;

namespace Breakout.Game;

public class DisplayFlag : SkiaLayout
{
    private string _lang;

    public string Lang
    {
        get => _lang;
        set
        {
            if (value == _lang) return;
            _lang = value;
            OnPropertyChanged();
        }
    }

    public DisplayFlag()
    {
        HeightRequest = 28;
        WidthRequest = 56;
        Children = new List<SkiaControl>()
        {
            new SkiaLayout()
            {
                Type = LayoutType.Row,
                VerticalOptions = LayoutOptions.Fill,
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 0,

                Children = new List<SkiaControl>()
                {
                    //flag icon
                    new SkiaShape()
                    {
                        Margin = new(0, 0, 2, 0),
                        StrokeColor = BreakoutGame.UiElements.ColorIconSecondary,
                        StrokeWidth = 1,
                        VerticalOptions = LayoutOptions.Fill,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children =
                        {
                            new SkiaSvg()
                                {
                                    VerticalOptions = LayoutOptions.Fill,
                                    HorizontalOptions = LayoutOptions.Fill,
                                    Aspect = TransformAspect.Fill
                                }
                                .ObserveProperty(this, nameof(Lang), me =>
                                {
                                    if (!string.IsNullOrEmpty(this.Lang))
                                    {
                                        var resKey = $"SvgFlag{this.Lang.ToTitleCase()}";
                                        me.SvgString = App.Current.Resources.Get<string>(resKey);
                                    }
                                }),
                        }
                    },


                    //dropdown icon
                    new SkiaSvg()
                    {
                        Margin = new Microsoft.Maui.Thickness(1, 1, 0, 0),
                        HorizontalOptions = LayoutOptions.Start,
                        TintColor = BreakoutGame.UiElements.ColorIconSecondary,
                        VerticalOptions = LayoutOptions.Fill,
                        WidthRequest = 10,
                        SvgString = App.Current.Resources.Get<string>("SvgDropdown")
                    }
                },
            }
        };
    }
}

--- C:\code\DrawnUi\src\Game\Controls\GameSwitch.cs ---
namespace Breakout.Game;

public class GameSwitch : SkiaSwitch
{
    public GameSwitch()
    {
        WidthRequest = 60;
        HeightRequest = 32;
        ColorFrameOff = BreakoutGame.UiElements.ColorIconSecondary;
        ColorFrameOn = BreakoutGame.UiElements.ColorPrimary;
        ColorThumbOff = AmstradColors.White;
        ColorThumbOn = AmstradColors.White;
        UseCache = SkiaCacheType.Operations;
    }
}

--- C:\code\DrawnUi\src\Game\Controls\HudArrows.cs ---
using Breakout.Game.Input;

namespace Breakout.Game;

public class HudArrows : SkiaGrid
{
    private BreakoutGame _game;
    private readonly HudController _controller;

    public HudArrows(BreakoutGame game)
    {
        _game = game;
        _controller = new HudController(game);
        _game.AddInputController(_controller);
    }

    public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args, GestureEventProcessingInfo apply)
    {
        if (_game.InputPressMode)
        {
            var hitbox = this.GetHitBox();
            var consumed = _controller.ProcessGestures(args, apply, hitbox, RenderingScale);
            if (consumed)
            {
                return this;
            }
        }

        return base.ProcessGestures(args, apply);
    }

    public override void OnWillDisposeWithChildren()
    {
        base.OnWillDisposeWithChildren();

        _game = null;
    }
}

--- C:\code\DrawnUi\src\Game\Controls\OptionWithTappable.cs ---
using AppoMobi.Maui.Gestures;
using Breakout.Game.Input;

namespace Breakout.Game;

/// <summary>
/// To support selected options inside dialog
/// </summary>
public class OptionWithTappable : SkiaLayout, IGameKeyHandler
{
    private readonly string _tag;
    private readonly SkiaControl _control;

    public OptionWithTappable(SkiaControl control)
    {
        _control = control;
    }

    public OptionWithTappable(string tag)
    {
        _tag = tag;
    }

    public bool HandleGameKey(GameKey key)
    {
        if (key == GameKey.Fire)
        {
            var control = _control;
            if (control == null)
            {
                control = FindViewByTag(_tag);
            }
            if (control != null)
            {
                var tap = new SkiaGesturesParameters()
                {
                    Type = TouchActionResult.Tapped
                };
                control.ProcessGestures(tap, GestureEventProcessingInfo.Empty);
            }
            return true;
        }

        return false;
    }
    public bool IsSelected { get; set; }
}

--- C:\code\DrawnUi\src\Game\Controls\SelectableGameButton.cs ---
using AppoMobi.Maui.Gestures;
using Breakout.Game.Input;

namespace Breakout.Game.Controls;

public class SelectableGameButton : SkiaShape, IGameKeyHandler
{
    public bool HandleGameKey(GameKey key)
    {
        if (key == GameKey.Fire)
        {
            var tap = new SkiaGesturesParameters()
            {
                Type = TouchActionResult.Tapped
            };
            ProcessGestures(tap, GestureEventProcessingInfo.Empty);
            return true;
        }

        return false;
    }

 
}

--- C:\code\DrawnUi\src\Game\Controls\StableCacheLayout.cs ---
namespace Breakout.Game;

public class StableCacheLayout : SkiaLayout
{
    private long _state;
    private long _stateCached;

    public override void OnScaleChanged()
    {
        _state++;

        base.OnScaleChanged();
    }

    protected override void OnCacheCreated()
    {
        base.OnCacheCreated();

        _stateCached = _state;
    }


    public override void OnChildrenChanged()
    {
        base.OnChildrenChanged();

        _state++;
    }

    public override void InvalidateCache()
    {
        if (_stateCached == _state)
        {
            return; // disable cache invalidation, we will need it built only once
        }

        base.InvalidateCache(); 
    }

}

--- C:\code\DrawnUi\src\Game\Dev\Test.cs ---
using AppoMobi.Maui.Gestures;
using SkiaSharp;

namespace Breakout.Game.Dev
{
    //public class Test : Canvas
    //{
    //    public Test()
    //    {
    //        RetainedMode = true;

    //        Gestures = GesturesMode.Enabled;
    //        HardwareAcceleration = HardwareAccelerationMode.Enabled;
    //        HorizontalOptions = LayoutOptions.Fill;
    //        VerticalOptions = LayoutOptions.Fill;
    //        BackgroundColor = Colors.DarkGrey;
    //        Content = new TouchLayout()
    //        {
    //        };
    //    }
    //}

    /// <summary>
    /// Just testing retained here. Could rewrite game to use retained rendering at some point.
    /// </summary>
    public class TouchLayout : SkiaLayout
    {
        private PointF? _tapped;
        private List<PointF> _brushStrokes = new List<PointF>();
        private float _brushSize = 30;
        private SKColor _brushColor = SKColors.Blue;

        public TouchLayout()
        {
            HorizontalOptions = LayoutOptions.Fill;
            VerticalOptions = LayoutOptions.Fill;
        }

        protected override void Paint(DrawingContext ctx)
        {
            base.Paint(ctx);

            if (_tapped != null)
            {
                var canvas = ctx.Context.Canvas;


                using var paint = new SKPaint
                {
                    IsAntialias = true,
                    Color = _brushColor,
                    Style = SKPaintStyle.Fill
                };

                canvas.DrawCircle(_tapped.Value.X, _tapped.Value.Y,
                    _brushSize, paint);

                // Add to our persistent collection
                _brushStrokes.Add(_tapped.Value);
                _tapped = null;

                // Alternate brush colors to make it easy to see each new tap
                if (_brushColor == SKColors.Blue)
                    _brushColor = SKColors.Red;
                else if (_brushColor == SKColors.Red)
                    _brushColor = SKColors.Green;
                else
                    _brushColor = SKColors.Blue;

                _tapped = null;
            }
        }

        public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args,
            GestureEventProcessingInfo apply)
        {
            if (args.Type == TouchActionResult.Tapped)
            {
                _tapped = args.Event.Location;


                return this;
            }

            return base.ProcessGestures(args, apply);
        }
    }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogAnimations.cs ---
namespace Breakout.Game.Dialogs;

/// <summary>
/// Animation definitions for dialog appearance and disappearance
/// </summary>
public class DialogAnimations
{
    public Func<SkiaLayout, CancellationToken, Task> BackdropAppearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> BackdropDisappearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> FrameAppearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> FrameDisappearing { get; set; }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogTemplate.cs ---
namespace Breakout.Game.Dialogs;

/// <summary>
/// Template system for customizing dialog appearance and behavior
/// </summary>
public class DialogTemplate
{
    public Func<GameDialog, SkiaControl, string, string, SkiaLayout> CreateDialogFrame { get; set; }
    public Func<SkiaLayout> CreateBackdrop { get; set; }
    public Func<string, SkiaControl> CreateButton { get; set; }
    public DialogAnimations Animations { get; set; }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogThemes.cs ---

namespace Breakout.Game.Dialogs
{
    /// <summary>
    /// Predefined dialog themes for easy customization
    /// </summary>
    public static class DialogThemes
    {
        #region MODERN

        /// <summary>
        /// Modern glass-like dialog theme with blur effects
        /// </summary>
        public static DialogTemplate Modern => new DialogTemplate
        {
            CreateBackdrop = () => new SkiaLayout
            {
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = Colors.Black.WithAlpha(0.5f)
            },

            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 40,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                MinimumHeightRequest = 50,
                Children = new List<SkiaControl>
                {
                    // Modern backdrop with blur
                    new SkiaShape
                    {
                        CornerRadius = 16,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        BackgroundColor = Colors.White.WithAlpha(0.9f),
                        //Shadow = new SkiaShadow 
                        //{ 
                        //    Color = Colors.Black.WithAlpha(0.3f), 
                        //    Blur = 20,
                        //    OffsetY = 8
                        //}
                    },

                    // Content container
                    new SkiaLayout
                    {
                        Type = LayoutType.Column,
                        Padding = 32,
                        Spacing = 24,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = CreateModernContentChildren(dialog, content, okText, cancelText)
                    }
                }
            },

            CreateButton = (text) => new SkiaButton
            {
                Text = text,
                FontSize = 16,
                TextColor = Colors.White,
                BackgroundColor = Colors.Blue,
                CornerRadius = 8,
                Padding = new Thickness(24, 12),
                MinimumWidthRequest = 100
            },

            Animations = new DialogAnimations
            {
                BackdropAppearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    backdrop.Opacity = 0;
                    await backdrop.FadeToAsync(1.0, 300, Easing.Linear, cancelSource);
                },

                FrameAppearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    frame.Scale = 0.8;
                    frame.Opacity = 0;
                    await Task.WhenAll(
                        frame.ScaleToAsync(1.0, 1.0, 400, Easing.CubicOut, cancelSource),
                        frame.FadeToAsync(1.0, 300, Easing.Linear, cancelSource)
                    );
                },

                BackdropDisappearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await backdrop.FadeToAsync(0.0, 200, Easing.Linear, cancelSource);
                },

                FrameDisappearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await Task.WhenAll(
                        frame.ScaleToAsync(0.9, 0.9, 200, Easing.CubicIn, cancelSource),
                        frame.FadeToAsync(0.0, 200, Easing.Linear, cancelSource)
                    );
                }
            }
        };


        private static List<SkiaControl> CreateModernContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                children.Add(content);
            }

            children.Add(CreateModernButtonLayout(dialog, okText, cancelText));
            return children;
        }


        private static SkiaLayout CreateModernButtonLayout(GameDialog dialog, string okText, string cancelText)
        {
            var okButton = CreateModernButton(okText, true);
            okButton.OnTapped(async me => await dialog.CloseWithOkAsync());

            var layout = new SkiaLayout
            {
                Type = LayoutType.Row,
                HorizontalOptions = LayoutOptions.Center,
                Spacing = 16,
                Children = { okButton }
            };

            if (!string.IsNullOrEmpty(cancelText))
            {
                var cancelButton = CreateModernButton(cancelText, false);
                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                layout.Add(cancelButton);
            }

            return layout;
        }

        private static SkiaButton CreateModernButton(string text, bool isPrimary)
        {
            return new SkiaButton
            {
                Text = text,
                FontSize = 16,
                TextColor = Colors.White,
                BackgroundColor = isPrimary ? Colors.Blue : Colors.Gray,
                CornerRadius = 8,
                Padding = new Thickness(24, 12),
                MinimumWidthRequest = 100
            };
        }

        #endregion

        #region RETRO

        /// <summary>
        /// Retro terminal-style dialog theme
        /// </summary>
        public static DialogTemplate Retro => new DialogTemplate
        {
            CreateBackdrop = () => new SkiaLayout
            {
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = Colors.Black.WithAlpha(0.8f)
            },

            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 60,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                Children = new List<SkiaControl>
                {
                    // Retro terminal background
                    new SkiaShape
                    {
                        CornerRadius = 0,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        BackgroundColor = Colors.Black,
                        StrokeColor = Colors.LimeGreen,
                        StrokeWidth = 2
                    },

                    // Content container
                    new SkiaLayout
                    {
                        Type = LayoutType.Column,
                        Padding = 24,
                        Spacing = 16,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = CreateRetroContentChildren(dialog, content, okText, cancelText)
                    }
                }
            },

            CreateButton = (text) => new SkiaButton
            {
                Text = text,
                FontSize = 14 * AppFonts.GameAdjustSize,
                FontFamily = AppFonts.GameAutoselect,
                TextColor = Colors.LimeGreen,
                BackgroundColor = Colors.Black,
                StrokeColor = Colors.LimeGreen,
                StrokeWidth = 1,
                Padding = new Thickness(16, 8),
                MinimumWidthRequest = 80
            },

            Animations = new DialogAnimations
            {
                BackdropAppearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    backdrop.Opacity = 0;
                    await backdrop.FadeToAsync(1.0, 150, Easing.Linear, cancelSource);
                },

                FrameAppearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    frame.Opacity = 0;
                    await frame.FadeToAsync(1.0, 200, Easing.Linear, cancelSource);
                },

                BackdropDisappearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await backdrop.FadeToAsync(0.0, 100, Easing.Linear, cancelSource);
                },

                FrameDisappearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await frame.FadeToAsync(0.0, 150, Easing.Linear, cancelSource);
                }
            }
        };

        private static List<SkiaControl> CreateRetroContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                // Style content for retro theme
                if (content is SkiaLabel label)
                {
                    label.TextColor = Colors.LimeGreen;
                    label.FontFamily = AppFonts.GameAutoselect;
                }

                children.Add(content);
            }

            children.Add(CreateRetroButtonLayout(dialog, okText, cancelText));
            return children;
        }

        private static SkiaLayout CreateRetroButtonLayout(GameDialog dialog, string okText, string cancelText)
        {
            var okButton = CreateRetroButton(okText, true);
            okButton.OnTapped(async me => await dialog.CloseWithOkAsync());

            var layout = new SkiaLayout
            {
                Type = LayoutType.Row,
                HorizontalOptions = LayoutOptions.Center,
                Spacing = 12,
                Children = { okButton }
            };

            if (!string.IsNullOrEmpty(cancelText))
            {
                var cancelButton = CreateRetroButton(cancelText, false);
                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                layout.Add(cancelButton);
            }

            return layout;
        }

        private static SkiaButton CreateRetroButton(string text, bool isPrimary)
        {
            return new SkiaButton
            {
                Text = text,
                FontSize = 14 * AppFonts.GameAdjustSize,
                FontFamily = AppFonts.GameAutoselect,
                TextColor = Colors.LimeGreen,
                BackgroundColor = Colors.Black,
                StrokeColor = Colors.LimeGreen,
                StrokeWidth = 1,
                Padding = new Thickness(16, 8),
                MinimumWidthRequest = 80
            };
        }

        #endregion

        #region GAME

        private static float gameRadius = 8;

        /// <summary>
        /// Game-specific dialog theme (recreates the original design exactly)
        /// </summary>
        public static DialogTemplate Game => new DialogTemplate
        {
            CreateBackdrop = () => null, // Original design doesn't use dimmer layer


            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 32,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                MinimumHeightRequest = 80,
                Children = new List<SkiaControl>
                {
                    //shape A - background texture for frosted effect plus shadow (cached layer)
                    new SkiaShape()
                    {
                        UseCache = SkiaCacheType.Image,
                        BackgroundColor = Color.Parse("#10ffffff"),
                        CornerRadius = gameRadius,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        StrokeColor = Colors.Red,
                        StrokeWidth = 2,
                        StrokeGradient = new SkiaGradient()
                        {
                            Opacity = 0.99f,
                            StartXRatio = 0.2f,
                            EndXRatio = 0.5f,
                            StartYRatio = 0.0f,
                            EndYRatio = 1f,
                            Colors = new Color[]
                            {
                                Color.Parse("#ffffff"),
                                Color.Parse("#999999"),
                            }
                        },
                        Children =
                        {
                            new SkiaImage()
                            {
                                Opacity = 0.25,
                                Source = "Images/glass.jpg",
                                HorizontalOptions = LayoutOptions.Fill,
                                VerticalOptions = LayoutOptions.Fill,
                            }
                        }
                    },

                    //shape B = backdrop
                    new SkiaShape()
                    {
                        CornerRadius = gameRadius,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        Children =
                        {
                            new SkiaBackdrop()
                            {
                                Blur = 4,
                                HorizontalOptions = LayoutOptions.Fill,
                                VerticalOptions = LayoutOptions.Fill,
                            }
                        }
                    },

                    // Content layout
                    new SkiaLayout()
                    {
                        ZIndex = 1,
                        HorizontalOptions = LayoutOptions.Fill,
                        UseCache = SkiaCacheType.Image,
                        Type = LayoutType.Column,
                        Padding = 20,
                        Spacing = 32,
                        Children = CreateGameContentChildren(dialog, content, okText, cancelText)
                    }
                }
            }
        };

        private static List<SkiaControl> CreateGameContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            // Add the main content
            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                children.Add(content);
            }

            var btnOk = BreakoutGame.UiElements.Button(okText, async () => await dialog.CloseWithOkAsync());
            btnOk.HorizontalOptions = LayoutOptions.Fill;
            
            // Create buttons layout exactly like the original
            var buttonsLayout = new SkiaLayout()
            {
                Type = LayoutType.Wrap,
                Margin = new(16, 0, 16, 0),
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 16,
                Children =
                {
                    // OK button using UiElements.Button (original design) with proper callback
                    btnOk
                }
            };

            // Cancel button (optional) - exactly like original
            if (!string.IsNullOrEmpty(cancelText))
            {
                btnOk.HorizontalOptions = LayoutOptions.Start;
                buttonsLayout.HorizontalOptions = LayoutOptions.Center;

                var cancelButton = new SkiaButton()
                {
                    Text = cancelText,
                    FontSize = 14 * AppFonts.GameAdjustSize,
                    FontFamily = AppFonts.GameAutoselect,
                    TextColor = Colors.White,
                    BackgroundColor = Colors.DarkRed,
                    WidthRequest = -1,
                    MinimumWidthRequest = 100,
                };

                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                buttonsLayout.Add(cancelButton);
            }

            children.Add(buttonsLayout);
            return children;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\Dialogs\GameDialog.cs ---
using Breakout.Game.Input;
using SkiaSharp;

namespace Breakout.Game.Dialogs
{
    /// <summary>
    /// A standalone dialog class with customizable templates and animations.
    /// Displays content with optional OK and Cancel buttons.
    /// </summary>
    public class GameDialog : SkiaLayout, IGameKeyHandler
    {
        // Navigation stack: container -> dialog
        private static readonly Dictionary<SkiaLayout, Stack<GameDialog>> _navigationStacks = new();

        // Template system for customizing dialog appearance
        public static DialogTemplate DefaultTemplate { get; set; }

        static GameDialog()
        {
            DefaultTemplate = DialogThemes.Modern;
        }

        // Legacy animation delegates (kept for backward compatibility)
        public static Func<SkiaLayout, SkiaLayout, SkiaLayout, CancellationToken, Task> DefaultAppearingAnimation
        {
            get;
            set;
        }

        public static Func<SkiaLayout, SkiaLayout, SkiaLayout, CancellationToken, Task> DefaultDisappearingAnimation
        {
            get;
            set;
        }

        public Action OnOkClicked { get; set; }
        public Action OnCancelClicked { get; set; }

        public SkiaControl Content;
        private string _okText;
        private string _cancelText;
        private SkiaLayout _parentContainer;
        private TaskCompletionSource<bool> _taskCompletionSource;
        private bool _isClosing;

        // References to dialog components for separate animations
        private SkiaLayout _dimmerLayer;
        private SkiaLayout _dialogFrame;

        private DialogTemplate _template;

        private GameDialog(SkiaControl content, string ok = null, string cancel = null,
            SkiaLayout parentContainer = null, DialogTemplate template = null)
        {
            Content = content;
            _okText = ok ?? ResStrings.BtnOk;
            _cancelText = cancel;
            _parentContainer = parentContainer;
            _template = template ?? DefaultTemplate;

            SetupDialog();
        }

        public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args,
            GestureEventProcessingInfo apply)
        {
            return base.ProcessGestures(args, apply);
        }

        /// <summary>
        /// Shows a dialog with the specified content and buttons.
        /// </summary>
        /// <param name="parentContainer">The parent container to add the dialog to</param>
        /// <param name="content">The content to display in the dialog</param>
        /// <param name="ok">OK button text (defaults to "OK")</param>
        /// <param name="cancel">Cancel button text (null = no cancel button)</param>
        /// <param name="onOk">Action to execute when OK is clicked</param>
        /// <param name="onCancel">Action to execute when Cancel is clicked</param>
        /// <param name="template">Custom template to use for this dialog (optional)</param>
        public static void Show(SkiaLayout parentContainer, SkiaControl content, string ok = null, string cancel = null,
            Action onOk = null, Action onCancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            dialog.OnOkClicked = onOk;
            dialog.OnCancelClicked = onCancel;

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();
        }

        /// <summary>
        /// Shows a dialog asynchronously and returns true if OK was clicked, false if Cancel was clicked.
        /// </summary>
        /// <param name="parentContainer">The parent container to add the dialog to</param>
        /// <param name="content">The content to display in the dialog</param>
        /// <param name="ok">OK button text (defaults to "OK")</param>
        /// <param name="cancel">Cancel button text (null = no cancel button)</param>
        /// <param name="template">Custom template to use for this dialog (optional)</param>
        /// <returns>Task that returns true for OK, false for Cancel</returns>
        public static Task<bool> ShowAsync(SkiaLayout parentContainer, SkiaControl content, string ok = null,
            string cancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);
            dialog._taskCompletionSource = new TaskCompletionSource<bool>();

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            // Note: OnOkClicked and OnCancelClicked will be handled by the CloseAsync method
            // The task completion will be set there

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();

            return dialog._taskCompletionSource.Task;
        }

        /// <summary>
        /// Closes the dialog with the specified result and optional animation.
        /// </summary>
        /// <param name="result">The result to return (true for OK, false for Cancel)</param>
        /// <param name="animate">Whether to animate the closing</param>
        public async Task CloseAsync(bool result, bool animate = true)
        {
            if (_isClosing) return;
            _isClosing = true;

            SelectionIndicatorRect = SKRect.Empty;

            if (animate)
            {
                await PlayDisappearingAnimation();
            }

            // Remove from parent
            _parentContainer?.RemoveSubView(this);

            // Remove from navigation stack
            if (_parentContainer != null && _navigationStacks.ContainsKey(_parentContainer))
            {
                var stack = _navigationStacks[_parentContainer];
                if (stack.Count > 0 && stack.Peek() == this)
                {
                    stack.Pop();
                }

                // Clean up empty stacks
                if (stack.Count == 0)
                {
                    _navigationStacks.Remove(_parentContainer);
                }
            }

            // Complete the task if it exists
            _taskCompletionSource?.SetResult(result);

            // Call the appropriate callback AFTER cleanup (user doesn't need to close dialog)
            if (result)
            {
                System.Diagnostics.Debug.WriteLine($"GameDialog: Calling OnOkClicked callback");
                OnOkClicked?.Invoke();
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"GameDialog: Calling OnCancelClicked callback");
                OnCancelClicked?.Invoke();
            }
        }

        /// <summary>
        /// Closes the dialog with OK result.
        /// </summary>
        public Task CloseWithOkAsync(bool animate = true) => CloseAsync(true, animate);

        /// <summary>
        /// Closes the dialog with Cancel result.
        /// </summary>
        public Task CloseWithCancelAsync(bool animate = true) => CloseAsync(false, animate);

        /// <summary>
        /// Plays the appearing animation when the dialog is shown.
        /// Override this method to customize the appearing animation.
        /// </summary>
        /// <param name="parent">The parent container</param>
        /// <param name="dimmer">The dimmer/background layer</param>
        /// <param name="frame">The dialog frame/content</param>
        /// <param name="cancellationToken">Cancellation token for the animation</param>
        protected virtual async Task PlayAppearingAnimation(SkiaLayout parent, SkiaLayout dimmer, SkiaLayout frame,
            CancellationToken cancellationToken = default)
        {
            // Check template animations first
            if (_template?.Animations?.FrameAppearing != null && _template?.Animations?.BackdropAppearing != null)
            {
                var tasks = new List<Task>();

                if (dimmer != null && _template.Animations.BackdropAppearing != null)
                {
                    tasks.Add(_template.Animations.BackdropAppearing(dimmer, cancellationToken));
                }

                if (frame != null && _template.Animations.FrameAppearing != null)
                {
                    tasks.Add(_template.Animations.FrameAppearing(frame, cancellationToken));
                }

                await Task.WhenAll(tasks);
            }
            // Fallback to legacy animation system
            else if (DefaultAppearingAnimation != null)
            {
                await DefaultAppearingAnimation(parent, dimmer, frame, cancellationToken);
            }
            else
            {
                // Default appearing animation: dimmer fades in, frame scales up with fade
                var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

                var tasks = new List<Task>();

                // Dimmer: Only fade in
                if (dimmer != null)
                {
                    dimmer.Opacity = 0.0;
                    tasks.Add(dimmer.FadeToAsync(1.0, 150, Easing.Linear, cancelSource));
                }

                foreach (var child in frame.Children)
                {
                    child.Scale = 0.8;
                    var frameScaleTask = child.ScaleToAsync(1.0, 1.0, 100, Easing.CubicOut, cancelSource);
                    tasks.Add(frameScaleTask);

                    if (child is not SkiaBackdrop)
                    {
                        child.Opacity = 0.0;
                        var frameFadeTask = child.FadeToAsync(1.0, 75, Easing.Linear, cancelSource);
                        tasks.Add(frameFadeTask);
                    }
                }

                // Frame: Scale up from center with fade in
                //frame.Scale = 0.8;
                //frame.Opacity = 0.0;
                //var frameScaleTask = frame.ScaleToAsync(1.0, 1.0, 5250, Easing.CubicOut, cancelSource);
                //var frameFadeTask = frame.FadeToAsync(1.0, 5200, Easing.Linear, cancelSource);

                await Task.WhenAll(tasks);
            }
        }

        /// <summary>
        /// Plays the disappearing animation when the dialog is closed.
        /// Override this method to customize the disappearing animation.
        /// </summary>
        /// <param name="parent">The parent container</param>
        /// <param name="dimmer">The dimmer/background layer</param>
        /// <param name="frame">The dialog frame/content</param>
        /// <param name="cancellationToken">Cancellation token for the animation</param>
        protected virtual async Task PlayDisappearingAnimation(SkiaLayout parent, SkiaLayout dimmer, SkiaLayout frame,
            CancellationToken cancellationToken = default)
        {
            // Check template animations first
            if (_template?.Animations?.FrameDisappearing != null && _template?.Animations?.BackdropDisappearing != null)
            {
                var tasks = new List<Task>();

                if (dimmer != null && _template.Animations.BackdropDisappearing != null)
                {
                    tasks.Add(_template.Animations.BackdropDisappearing(dimmer, cancellationToken));
                }

                if (frame != null && _template.Animations.FrameDisappearing != null)
                {
                    tasks.Add(_template.Animations.FrameDisappearing(frame, cancellationToken));
                }

                await Task.WhenAll(tasks);
            }
            // Fallback to legacy animation system
            else if (DefaultDisappearingAnimation != null)
            {
                await DefaultDisappearingAnimation(parent, dimmer, frame, cancellationToken);
            }
            else
            {
                // Default disappearing animation: dimmer fades out, frame scales down with fade
                var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

                var tasks = new List<Task>();


                // Dimmer: Only fade out
                if (dimmer != null)
                {
                    tasks.Add(dimmer.FadeToAsync(0.0, 150, Easing.Linear, cancelSource));
                }

                // Frame: Scale down with fade out
                tasks.Add(frame.ScaleToAsync(0.8, 0.8, 150, Easing.CubicIn, cancelSource));
                tasks.Add(frame.FadeToAsync(0.0, 150, Easing.Linear, cancelSource));

                await Task.WhenAll(tasks);
            }
        }

        /// <summary>
        /// Convenience method that calls PlayAppearingAnimation with proper parameters.
        /// </summary>
        private async Task PlayAppearingAnimation(CancellationToken cancellationToken = default)
        {
            await PlayAppearingAnimation(_parentContainer, _dimmerLayer, _dialogFrame, cancellationToken);
        }

        /// <summary>
        /// Convenience method that calls PlayDisappearingAnimation with proper parameters.
        /// </summary>
        private async Task PlayDisappearingAnimation(CancellationToken cancellationToken = default)
        {
            await PlayDisappearingAnimation(_parentContainer, _dimmerLayer, _dialogFrame, cancellationToken);
        }

        #region Navigation Stack Methods

        /// <summary>
        /// Pushes a dialog onto the navigation stack (equivalent to Show but adds to stack).
        /// </summary>
        public static void Push(SkiaLayout parentContainer, SkiaControl content, string ok = null, string cancel = null,
            Action onOk = null, Action onCancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            dialog.OnOkClicked = onOk;
            dialog.OnCancelClicked = onCancel;

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();
        }

        /// <summary>
        /// Pops the topmost dialog from the navigation stack.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task Pop(SkiaLayout parentContainer, bool animate = true)
        {
            if (!_navigationStacks.ContainsKey(parentContainer) || _navigationStacks[parentContainer].Count == 0)
                return;

            var dialog = _navigationStacks[parentContainer].Peek();
            await dialog.CloseAsync(false, animate); // No result, just close
        }

        /// <summary>
        /// Pops the topmost dialog asynchronously (waits for animation to finish).
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        /// <returns>Task that completes when the dialog is closed</returns>
        public static async Task PopAsync(SkiaLayout parentContainer, bool animate = true)
        {
            await Pop(parentContainer, animate);
        }

        /// <summary>
        /// Pops all dialogs from the navigation stack.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task PopAll(SkiaLayout parentContainer, bool animate = true)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return;

            var stack = _navigationStacks[parentContainer];
            var tasks = new List<Task>();

            while (stack.Count > 0)
            {
                var dialog = stack.Pop();
                tasks.Add(dialog.CloseAsync(false, animate));
            }

            await Task.WhenAll(tasks);
        }

        /// <summary>
        /// Pops all dialogs from the navigation stack and returns when all are closed.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task PopAllAsync(SkiaLayout parentContainer, bool animate = true)
        {
            await PopAll(parentContainer, animate);
        }

        /// <summary>
        /// Gets the number of dialogs in the navigation stack for the specified container.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <returns>Number of dialogs in the stack</returns>
        public static int GetStackCount(SkiaLayout parentContainer)
        {
            return _navigationStacks.ContainsKey(parentContainer) ? _navigationStacks[parentContainer].Count : 0;
        }

        /// <summary>
        /// Checks if any dialog is currently open (visible) for the specified container.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <returns>True if any dialog is currently open, false otherwise</returns>
        public static bool IsAnyDialogOpen(SkiaLayout parentContainer)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return false;

            var stack = _navigationStacks[parentContainer];
            if (stack.Count == 0)
                return false;

            return true;
        }

        #endregion

        public static GameDialog GetTopDialog(SkiaLayout parentContainer)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return null;

            var stack = _navigationStacks[parentContainer];
            if (stack.Count == 0)
                return null;

            return stack.Last();
        }

        protected virtual void SetupDialogWithTemplate()
        {
            // Create backdrop if template provides one
            if (_template.CreateBackdrop != null)
            {
                _dimmerLayer = _template.CreateBackdrop();
            }

            // Create dialog frame using template - pass dialog instance for callbacks
            if (_template.CreateDialogFrame != null)
            {
                _dialogFrame = _template.CreateDialogFrame(this, Content, _okText, _cancelText);
            }
            else
            {
                throw new InvalidOperationException("Template must provide CreateDialogFrame");
            }

            // Add children
            var children = new List<SkiaControl>();
            if (_dimmerLayer != null)
            {
                children.Add(_dimmerLayer);
            }

            children.Add(_dialogFrame);

            Children = children;
        }

        /// <summary>
        /// Public method for templates to close dialog with OK result
        /// </summary>
        public async Task CloseWithOkAsync()
        {
            await CloseWithOkAsync(animate: true);
        }

        /// <summary>
        /// Public method for templates to close dialog with Cancel result
        /// </summary>
        public async Task CloseWithCancelAsync()
        {
            await CloseWithCancelAsync(animate: true);
        }

        /// <summary>
        /// Finds all child views that implement IGameKeyHandler interface in the view hierarchy
        /// </summary>
        /// <returns>List of all found views implementing IGameKeyHandler</returns>
        public List<IGameKeyHandler> FindAllKeyHandlers(SkiaControl parent)
        {
            var handlers = new List<IGameKeyHandler>();

            if (parent is IGameKeyHandler selfHandler)
                handlers.Add(selfHandler);

            foreach (var view in parent.Views)
            {
                if (view is IGameKeyHandler handler)
                    handlers.Add(handler);

                // Manually recurse through child's Views
                var childHandlers = GetKeyHandlersFromViews(view.Views);
                handlers.AddRange(childHandlers);
            }

            return handlers;
        }

        private List<IGameKeyHandler> GetKeyHandlersFromViews(IEnumerable<SkiaControl> views)
        {
            var handlers = new List<IGameKeyHandler>();

            foreach (var view in views)
            {
                if (view is IGameKeyHandler handler)
                    handlers.Add(handler);

                var childHandlers = GetKeyHandlersFromViews(view.Views);
                handlers.AddRange(childHandlers);
            }

            return handlers;
        }

        protected void SetupDialog()
        {
            // Main dialog container
            HorizontalOptions = LayoutOptions.Fill;
            VerticalOptions = LayoutOptions.Fill;
            ZIndex = 200;

            // Always use template system (default is Game template which recreates original design)
            SetupDialogWithTemplate();

            var frameHandlers = FindAllKeyHandlers(_dialogFrame);
            foreach (var handler in frameHandlers)
            {
                KeyHandlers.Add(handler);
            }

            SelectionIndicator = new SkiaShape()
            {
                StrokeColor = Colors.Gold,
                StrokeWidth = 3,
                UseCache = SkiaCacheType.Operations,
            };
        }


        private List<IGameKeyHandler> KeyHandlers = new();
        private IGameKeyHandler SelectedKeyHandler;
        SKRect SelectionIndicatorRect = SKRect.Empty;
        SkiaShape SelectionIndicator;

        // Time-delay filtering
        private int DirectionalActionDelayMs = 200;
        private long _lastDirectionalActionTime = 0;

        private int ActionDelayMs = 750;
        private long _lastActionTime = 0;

        public bool HandleGameKey(GameKey key)
        {
            if (key == GameKey.Fire)
            {
                if (CanProcessAction())
                {
                    if (SelectedKeyHandler == null && KeyHandlers.Count > 1)
                    {
                        SelectNextHandler();
                        UpdateLastDirectionalActionTime();
                    }
                    else
                    {
                        if (SelectedKeyHandler != null)
                        {
                            var handled = SelectedKeyHandler.HandleGameKey(key);
                            UpdateLastActionTime();
                            return true;
                        }

                        //tap single default button/control
                        if (OnCancelClicked != null)
                        {
                            OnOkClicked?.Invoke();
                        }
                        else
                        {
                            _ = CloseAsync(true, true);
                        }
                        UpdateLastActionTime();
                    }
                }

                return true;
            }

            if (KeyHandlers.Count > 0)
            {
                if (key == GameKey.Left || key == GameKey.Up)
                {
                    if (CanProcessDirectionalAction())
                    {
                        SelectPreviousHandler();
                        UpdateLastDirectionalActionTime();
                    }
                }
                else if (key == GameKey.Right || key == GameKey.Down)
                {
                    if (CanProcessDirectionalAction())
                    {
                        SelectNextHandler();
                        UpdateLastDirectionalActionTime();
                    }
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if enough time has passed since the last action to allow processing a new one
        /// </summary>
        private bool CanProcessAction()
        {
            var currentTime = Environment.TickCount64;
            return currentTime - _lastActionTime >= ActionDelayMs;
        }

        /// <summary>
        /// Updates the timestamp of the last action
        /// </summary>
        private void UpdateLastActionTime()
        {
            _lastActionTime = Environment.TickCount64;
        }

        /// <summary>
        /// Checks if enough time has passed since the last directional action to allow processing a new one
        /// </summary>
        private bool CanProcessDirectionalAction()
        {
            var currentTime = Environment.TickCount64;
            return currentTime - _lastDirectionalActionTime >= DirectionalActionDelayMs;
        }

        /// <summary>
        /// Updates the timestamp of the last directional action
        /// </summary>
        private void UpdateLastDirectionalActionTime()
        {
            _lastDirectionalActionTime = Environment.TickCount64;
        }

        void SelectGameKeyHandler(IGameKeyHandler selected)
        {
            SelectionIndicatorRect = SKRect.Empty;
            if (selected != null)
            {
                SelectedKeyHandler = selected;
                if (SelectedKeyHandler is SkiaControl control)
                {
                    var expand = control.DrawingRect;
                    var ex = 3 * RenderingScale;
                    expand.Inflate(ex, ex);
                    SelectionIndicatorRect = expand;
                    var width = SelectionIndicatorRect.Width;
                    var height = SelectionIndicatorRect.Height;
                    SelectionIndicator.WidthRequest = width;
                    SelectionIndicator.HeightRequest = height;
                }
            }
        }

        protected override void Paint(DrawingContext ctx)
        {
            base.Paint(ctx);
            if (SelectionIndicatorRect != SKRect.Empty)
            {
                if (SelectionIndicator.NeedMeasure)
                {
                    SelectionIndicator.Measure((float)SelectionIndicator.WidthRequest,
                        (float)SelectionIndicator.HeightRequest, RenderingScale);
                    SelectionIndicator.Arrange(SelectionIndicatorRect, (float)SelectionIndicator.WidthRequest,
                        (float)SelectionIndicator.HeightRequest, RenderingScale);
                }

                SelectionIndicator.Render(ctx.WithDestination(SelectionIndicatorRect));
            }
        }

        private void SelectPreviousHandler()
        {
            if (KeyHandlers.Count == 0) return;
            int currentIndex = SelectedKeyHandler != null ? KeyHandlers.IndexOf(SelectedKeyHandler) : 0;
            int newIndex = currentIndex - 1;
            if (newIndex < 0)
                newIndex = KeyHandlers.Count - 1;
            SelectGameKeyHandler(KeyHandlers[newIndex]);
        }

        private void SelectNextHandler()
        {
            if (KeyHandlers.Count == 0) return;
            int currentIndex = SelectedKeyHandler != null ? KeyHandlers.IndexOf(SelectedKeyHandler) : -1;
            int newIndex = currentIndex + 1;
            if (newIndex >= KeyHandlers.Count)
                newIndex = 0;
            SelectGameKeyHandler(KeyHandlers[newIndex]);
        }
    }
}

--- C:\code\DrawnUi\src\Game\Input\EventType.cs ---
namespace Breakout.Game.Input;

public enum EventType
{
    KeyDown,
    KeyUp,
    Mouse,
    Joystick
}

--- C:\code\DrawnUi\src\Game\Input\GameControllerInput.cs ---
using Orbit.Input;

namespace Breakout.Game.Input;

public class GameControllerInput : IInputController
{
    private readonly BreakoutGame _game;
    private Orbit.Input.GameController _gameController;
    
    public GameControllerInput(BreakoutGame game)
    {
        _game = game;
        
        GameControllerManager.Current.GameControllerConnected += OnGameControllerConnected;
        
        _ = GameControllerManager.Current.StartDiscovery();
    }
    
    private void OnGameControllerConnected(object sender, GameControllerConnectedEventArgs args)
    {
        _gameController = args.GameController;
    }

    public void ProcessState()
    {
        if (_gameController is null)
        {
            return;
        }
        
        if (_gameController.LeftStick.XAxis.Value < -0.001f ||
            _gameController.Dpad.XAxis.Value < -0.001f)
        {
            _game.SendKey(GameKey.Left);
        }
        else if (_gameController.LeftStick.XAxis.Value > 0.001f ||
                 _gameController.Dpad.XAxis.Value > 0.001f)
        {
            _game.SendKey(GameKey.Right);
        }
        else
        {
            _game.SendKey(GameKey.Stop);
        }
        
        if (_gameController.LeftStick.YAxis.Value < -0.001f ||
            _gameController.Dpad.YAxis.Value > 0.001f)
        {
            _game.SendKey(GameKey.Up);
        }
        else if (_gameController.LeftStick.YAxis.Value > 0.001f ||
                 _gameController.Dpad.YAxis.Value < -0.001f)
        {
            _game.SendKey(GameKey.Down);
        }

        if (_gameController.South.Value)
        {
            _game.SendKey(GameKey.Fire);
        }
        
        if (_gameController.Pause.Value)
        {
            _game.SendKey(GameKey.Pause);
        }
    }

    public void Dispose()
    {
        _game?.Dispose();
        
        GameControllerManager.Current.GameControllerConnected -= OnGameControllerConnected;
    }
}

--- C:\code\DrawnUi\src\Game\Input\GameKey.cs ---
namespace Breakout.Game.Input;

/// <summary>
/// Game-dependent action keys
/// </summary>
public enum GameKey
{
    Unset,
    
    Demo,
    
    /// <summary>
    /// Will open options
    /// </summary>
    Pause,
    
    Fire,

    Left,
    Right,
    Up,
    Down,

    Stop,
}

--- C:\code\DrawnUi\src\Game\Input\HudController.cs ---
using System.Diagnostics;
using AppoMobi.Maui.Gestures;
using SkiaSharp;

namespace Breakout.Game.Input;

public class HudController : IInputController
{
    private readonly BreakoutGame _game;
    private bool _leftPressed = false;
    private bool _rightPressed = false;
    private Dictionary<long, bool> _touchSides = new Dictionary<long, bool>(); // true = left, false = right

    /// <summary>
    /// Initializes a new instance of the VirtualController class
    /// </summary>
    /// <param name="game">The breakout game instance</param>
    public HudController(BreakoutGame game)
    {
        _game = game;
    }

    /// <summary>
    /// Processes touch gestures and updates internal key state
    /// </summary>
    /// <param name="args">The gesture parameters</param>
    /// <param name="apply">The gesture processing info</param>
    /// <param name="hitbox">The hit box area for touch detection</param>
    /// <param name="scale">The rendering scale factor</param>
    /// <returns>True if gesture was consumed, false otherwise</returns>
    public bool ProcessGestures(SkiaGesturesParameters args, GestureEventProcessingInfo apply, SKRect hitbox,
        float scale)
    {
        if (!_game.InputPressMode)
            return false;

        var point = new SKPoint(args.Event.Location.X / scale, args.Event.Location.Y / scale);

        if (!hitbox.Contains(point))
            return false;

        bool isLeftSide = point.X < hitbox.Left + hitbox.Width / 2;

        if (args.Type == TouchActionResult.Down)
        {
            _touchSides[args.Event.Id] = isLeftSide;

            if (isLeftSide)
            {
                Debug.WriteLine("DOWN LEFT");
                _leftPressed = true;
            }
            else
            {
                Debug.WriteLine("DOWN RIGHT");
                _rightPressed = true;
            }

            return true;
        }
        else if (args.Type == TouchActionResult.Up)
        {
            if (_touchSides.TryGetValue(args.Event.Id, out bool wasLeftSide))
            {
                _touchSides.Remove(args.Event.Id);

                if (wasLeftSide)
                {
                    Debug.WriteLine("UP LEFT");
                    _leftPressed = false;
                }
                else
                {
                    Debug.WriteLine("UP RIGHT");
                    _rightPressed = false;
                }
            }

            if (!_leftPressed && !_rightPressed)
            {
                _game.SendKey(GameKey.Stop);
            }

            return true;
        }

        return false;
    }

    /// <summary>
    /// Called every frame to apply continuous key input based on current state
    /// </summary>
    public void ProcessState()
    {
        if (!_game.InputPressMode)
            return;

        if (_rightPressed && _leftPressed)
        {
            // Both pressed - prioritize the most recent one
            // For now, right takes priority when both are pressed
            _game.SendKey(GameKey.Right);
        }
        else if (_leftPressed)
        {
            _game.SendKey(GameKey.Left);
        }
        else if (_rightPressed)
        {
            _game.SendKey(GameKey.Right);
        }
    }

    /// <summary>
    /// Resets the virtual controller state
    /// </summary>
    public void Reset()
    {
        _leftPressed = false;
        _rightPressed = false;
        _touchSides.Clear();
    }

    public void Dispose()
    {
 
    }
}

--- C:\code\DrawnUi\src\Game\Input\IGameKeyHandler.cs ---
namespace Breakout.Game.Input
{
    /// <summary>
    /// Interface for controls that can handle GameKey input (like dialogs)
    /// </summary>
    public interface IGameKeyHandler
    {
        /// <summary>
        /// Process a game key input. Return true if handled, false to pass through.
        /// </summary>
        bool HandleGameKey(GameKey key);
    }
}

--- C:\code\DrawnUi\src\Game\Input\IInputController.cs ---
namespace Breakout.Game.Input;

public interface IInputController : IDisposable
{
    void ProcessState();
}

--- C:\code\DrawnUi\src\Game\Internals\CollisionFace.cs ---
namespace Breakout.Game;

/// <summary>
/// Enum representing the face of collision
/// </summary>
public enum CollisionFace
{
    None,
    Top,
    Bottom,
    Left,
    Right
}

public class Area : SkiaLayout
{
    
}

public class ScreenSplash : AppScreen
{

}

public class AppScreen : SkiaLayout
{

}

--- C:\code\DrawnUi\src\Game\Internals\GameState.cs ---
using SkiaSharp;

namespace Breakout.Game;

public enum GameState
{
    Unset,

    /// <summary>
    /// Welcome screen presented
    /// </summary>
    Ready,

    /// <summary>
    /// Game loop is running
    /// </summary>
    Playing,

    Paused,

    /// <summary>
    /// Game ended
    /// </summary>
    Ended,

    LevelComplete,
    
    DemoPlay
}


--- C:\code\DrawnUi\src\Game\Internals\IReusableSprite.cs ---
namespace Breakout.Game;

/// <summary>
/// Resusable model, to avoid GC
/// </summary>
public interface IReusableSprite
{
    bool IsActive { get; set; }

    Guid Uid { get; }

    void ResetAnimationState();

    Task AnimateDisappearing();
}

--- C:\code\DrawnUi\src\Game\Internals\IWithHitBox.cs ---
using SkiaSharp;

namespace Breakout.Game;

public interface IWithHitBox
{
    /// <summary>
    /// Calculate hitbox etc for the current frame
    /// </summary>
    /// <param name="time"></param>
    void UpdateState(long time, bool forceRecalculate=false);

    /// <summary>
    /// Precalculated
    /// </summary>
    SKRect HitBox { get; }
}

--- C:\code\DrawnUi\src\Game\Internals\MauiGameExtensions.cs ---
using SkiaSharp;

namespace Breakout.Game;

public static class MauiGameExtensions
{

    public static SKRect GetHitBox(this SkiaControl sprite)
    {
        if (sprite is SkiaControl control)
        {
            //real position even below/inside a cached layer
            //var position = control.GetFuturePositionOnCanvasInPoints();
            if (control.VisualLayer == null)
            {
                return SKRect.Empty;
            }

            //we can get position from layer as we do not ache above
            var position = control.VisualLayer.HitBoxWithTransforms.Units.Location;

            var hitBox = new SKRect(position.X, position.Y,
                (float)(position.X + control.Width), (float)(position.Y + control.Height));
            return hitBox;
        }

        return SKRect.Empty;
    }

    /// <summary>
    /// Detects intersection between two rectangles and returns the overlap area
    /// </summary>
    /// <param name="source">Source rectangle</param>
    /// <param name="target">Target rectangle</param>
    /// <param name="overlap">Output overlap rectangle</param>
    /// <returns>True if rectangles intersect, false otherwise</returns>
    public static bool IntersectsWith(this SKRect source, SKRect target, out SKRect overlap)
    {
        // Initialize overlap with empty rect
        overlap = SKRect.Empty;

        // Calculate potential overlap dimensions
        float left = Math.Max(source.Left, target.Left);
        float right = Math.Min(source.Right, target.Right);
        float top = Math.Max(source.Top, target.Top);
        float bottom = Math.Min(source.Bottom, target.Bottom);

        // Check if there's actually an overlap
        if (right <= left || bottom <= top)
        {
            return false;
        }

        // Create overlap rectangle relative to target position
        overlap = new SKRect(
            left - target.Left, // Normalize to target's left edge
            top - target.Top, // Normalize to target's top edge
            right - target.Left, // Normalize to target's left edge
            bottom - target.Top // Normalize to target's top edge
        );

        return true;
    }


}

--- C:\code\DrawnUi\src\Game\Internals\RaycastCollision.cs ---
using System.Numerics;
using SkiaSharp;

namespace Breakout.Game
{
    /// <summary>
    /// Implements raycasting collision detection for more accurate collision handling
    /// </summary>
    public static class RaycastCollision
    {
        // Minimum threshold for direction components to avoid division by very small numbers
        private const float MIN_DIRECTION_THRESHOLD = 0.0001f;

        /// <summary>
        /// Represents the result of a raycast collision
        /// </summary>
        public struct RaycastHit
        {
            public bool Collided { get; set; }
            public float Distance { get; set; }
            public Vector2 Point { get; set; }
            public Vector2 Normal { get; set; }
            public IWithHitBox Target { get; set; }
            public CollisionFace Face { get; set; }

            public static RaycastHit None => new RaycastHit { Collided = false };
        }

        /// <summary>
        /// Performs a raycast from the ball's current position in its movement direction
        /// </summary>
        /// <param name="origin">Current position of the ball</param>
        /// <param name="direction">Direction vector of ball's movement</param>
        /// <param name="distance">Distance to check for collision (based on ball's speed and deltaTime)</param>
        /// <param name="radius">Radius of the ball</param>
        /// <param name="targets">Collection of collision targets</param>
        /// <returns>Information about the collision if it occurred</returns>
        public static RaycastHit CastRay(Vector2 origin, Vector2 direction, float distance, float radius,
            IEnumerable<IWithHitBox> targets)
        {
            var closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            // Create multiple raycasts to simulate the ball's width
            // Main center ray
            var centerHit = CastSingleRay(origin, direction, distance, radius, targets);
            if (centerHit.Collided && centerHit.Distance < closestHit.Distance)
            {
                closestHit = centerHit;
            }

            // Calculate perpendicular vector to the direction for side rays
            Vector2 perpendicular = new Vector2(-direction.Y, direction.X);
            perpendicular = Vector2.Normalize(perpendicular) * radius * 0.8f; // 80% of radius for the side rays

            // Left side ray
            Vector2 leftOrigin = origin + perpendicular;
            var leftHit = CastSingleRay(leftOrigin, direction, distance, radius * 0.2f, targets);
            if (leftHit.Collided && leftHit.Distance < closestHit.Distance)
            {
                closestHit = leftHit;
            }

            // Right side ray
            Vector2 rightOrigin = origin - perpendicular;
            var rightHit = CastSingleRay(rightOrigin, direction, distance, radius * 0.2f, targets);
            if (rightHit.Collided && rightHit.Distance < closestHit.Distance)
            {
                closestHit = rightHit;
            }

            return closestHit.Collided ? closestHit : RaycastHit.None;
        }

        /// <summary>
        /// Casts a single ray against all targets
        /// </summary>
        private static RaycastHit CastSingleRay(Vector2 origin, Vector2 direction, float distance, float radius,
            IEnumerable<IWithHitBox> targets)
        {
            var closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            foreach (var target in targets)
            {
                if (target is BallSprite)
                    continue;

                var hit = TestRaycastAgainstRect(origin, direction, distance, radius, target.HitBox, target);

                if (hit.Collided && hit.Distance < closestHit.Distance)
                {
                    closestHit = hit;
                }
            }

            return closestHit.Collided ? closestHit : RaycastHit.None;
        }

        /// <summary>
        /// Tests if a ray collides with a rectangle
        /// </summary>
        private static RaycastHit TestRaycastAgainstRect(Vector2 origin, Vector2 direction, float maxDistance,
            float radius, SKRect rect, IWithHitBox target)
        {
            // Make sure we're using the correct HitBox from the target
            rect = target.HitBox;

            // Expand the rect by the ball's radius to account for the ball's size
            var expandedRect = new SKRect(
                rect.Left - radius,
                rect.Top - radius,
                rect.Right + radius,
                rect.Bottom + radius
            );

            // Points representing the expanded rectangle
            Vector2 rectMin = new Vector2(expandedRect.Left, expandedRect.Top);
            Vector2 rectMax = new Vector2(expandedRect.Right, expandedRect.Bottom);

            // Check if the origin is inside the expanded rectangle - this would cause negative distance
            bool originInsideRect = origin.X >= rectMin.X && origin.X <= rectMax.X &&
                                   origin.Y >= rectMin.Y && origin.Y <= rectMax.Y;

            if (originInsideRect)
            {
                // Return no collision if we're already inside - prevents the stuck bug
                return RaycastHit.None;
            }

            // Calculate distance to intersection points
            float tNear = float.NegativeInfinity;
            float tFar = float.PositiveInfinity;

            // Normal of the hit face
            Vector2 hitNormal = Vector2.Zero;
            CollisionFace hitFace = CollisionFace.None;

            // Check X axis intersection - FIXED threshold for shallow angles
            if (Math.Abs(direction.X) < MIN_DIRECTION_THRESHOLD)
            {
                // Ray is nearly parallel to X axis
                if (origin.X < rectMin.X || origin.X > rectMax.X)
                    return RaycastHit.None;
            }
            else
            {
                float tx1 = (rectMin.X - origin.X) / direction.X;
                float tx2 = (rectMax.X - origin.X) / direction.X;

                if (tx1 > tx2)
                {
                    float temp = tx1;
                    tx1 = tx2;
                    tx2 = temp;
                }

                tNear = Math.Max(tNear, tx1);
                tFar = Math.Min(tFar, tx2);

                if (tNear == tx1)
                {
                    hitNormal = new Vector2(-1, 0);
                    hitFace = CollisionFace.Left;
                }
                else if (tNear == tx2)
                {
                    hitNormal = new Vector2(1, 0);
                    hitFace = CollisionFace.Right;
                }

                if (tNear > tFar || tFar < 0)
                    return RaycastHit.None;
            }

            // Check Y axis intersection - FIXED threshold for shallow angles
            if (Math.Abs(direction.Y) < MIN_DIRECTION_THRESHOLD)
            {
                // Ray is nearly parallel to Y axis
                if (origin.Y < rectMin.Y || origin.Y > rectMax.Y)
                    return RaycastHit.None;
            }
            else
            {
                float ty1 = (rectMin.Y - origin.Y) / direction.Y;
                float ty2 = (rectMax.Y - origin.Y) / direction.Y;

                if (ty1 > ty2)
                {
                    float temp = ty1;
                    ty1 = ty2;
                    ty2 = temp;
                }

                float originalTNear = tNear;

                tNear = Math.Max(tNear, ty1);
                tFar = Math.Min(tFar, ty2);

                if (tNear > originalTNear)
                {
                    if (tNear == ty1)
                    {
                        hitNormal = new Vector2(0, -1);
                        hitFace = CollisionFace.Top;
                    }
                    else
                    {
                        hitNormal = new Vector2(0, 1);
                        hitFace = CollisionFace.Bottom;
                    }
                }

                if (tNear > tFar || tFar < 0)
                    return RaycastHit.None;
            }

            // Ensure we only detect collisions at positive distances
            if (tNear < 0 || tNear > maxDistance)
                return RaycastHit.None;

            // Calculate the hit point
            Vector2 hitPoint = origin + direction * tNear;

            return new RaycastHit
            {
                Collided = true,
                Distance = tNear,
                Point = hitPoint,
                Normal = hitNormal,
                Target = target,
                Face = hitFace
            };
        }

        /// <summary>
        /// Checks if a moving object (ball) would collide with walls using proper distance calculations
        /// </summary>
        public static RaycastHit CheckWallCollision(Vector2 position, Vector2 direction, float radius,
            float maxDistance, SKRect gameField)
        {
            RaycastHit closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            // Normalize direction to unit vector for distance calculations
            Vector2 normalizedDirection = Vector2.Normalize(direction);

            // Left wall collision
            if (normalizedDirection.X < -MIN_DIRECTION_THRESHOLD) // Moving left
            {
                float wallPosition = gameField.Left + radius; // Ball edge should not go below this X position
                float distanceToWall = position.X - wallPosition;

                if (distanceToWall > 0) // Not already past the wall
                {
                    // Calculate actual distance along the ray to reach the wall
                    float rayDistance = distanceToWall / -normalizedDirection.X;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        // Verify Y coordinate is within bounds
                        if (hitPoint.Y >= gameField.Top + radius && hitPoint.Y <= gameField.Bottom - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(1, 0);
                            closestHit.Face = CollisionFace.Left;
                            closestHit.Point = new Vector2(gameField.Left, hitPoint.Y);
                        }
                    }
                }
            }

            // Right wall collision
            if (normalizedDirection.X > MIN_DIRECTION_THRESHOLD) // Moving right
            {
                float wallPosition = gameField.Right - radius; // Ball edge should not go above this X position
                float distanceToWall = wallPosition - position.X;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / normalizedDirection.X;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.Y >= gameField.Top + radius && hitPoint.Y <= gameField.Bottom - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(-1, 0);
                            closestHit.Face = CollisionFace.Right;
                            closestHit.Point = new Vector2(gameField.Right, hitPoint.Y);
                        }
                    }
                }
            }

            // Top wall collision (ball hits top of screen - should bounce)
            if (normalizedDirection.Y < -MIN_DIRECTION_THRESHOLD) // Moving up
            {
                float wallPosition = gameField.Top + radius; // Ball edge should not go above this Y position
                float distanceToWall = position.Y - wallPosition;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / -normalizedDirection.Y;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.X >= gameField.Left + radius && hitPoint.X <= gameField.Right - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(0, 1);
                            closestHit.Face = CollisionFace.Bottom; // Ball hits bottom face of top wall
                            closestHit.Point = new Vector2(hitPoint.X, gameField.Top);
                        }
                    }
                }
            }

            // Bottom wall collision (ball hits bottom of screen - should lose life)
            if (normalizedDirection.Y > MIN_DIRECTION_THRESHOLD) // Moving down
            {
                float wallPosition = gameField.Bottom - radius; // Ball edge should not go below this Y position
                float distanceToWall = wallPosition - position.Y;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / normalizedDirection.Y;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.X >= gameField.Left + radius && hitPoint.X <= gameField.Right - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(0, -1);
                            closestHit.Face = CollisionFace.Top; // Ball hits top face of bottom wall
                            closestHit.Point = new Vector2(hitPoint.X, gameField.Bottom);
                        }
                    }
                }
            }

            return closestHit;
        }

        /// <summary>
        /// Reflects a vector off a surface with the given normal
        /// </summary>
        public static Vector2 Reflect(Vector2 direction, Vector2 normal)
        {
            return direction - 2 * Vector2.Dot(direction, normal) * normal;
        }
    }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPosition.cs ---
namespace Breakout.Game;

/// <summary>
/// Represents a position for a brick in the layout
/// </summary>
public class BrickPosition
{
    /// <summary>
    /// Column index
    /// </summary>
    public float Column { get; set; }

    /// <summary>
    /// Row index
    /// </summary>
    public float Row { get; set; }

    /// <summary>
    /// Preset ID to use for this brick
    /// </summary>
    public string PresetId { get; set; }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPreset.cs ---
namespace Breakout.Game
{
    /// <summary>
    /// Defines the properties of a brick preset
    /// </summary>
    public class BrickPreset
    {
        /// <summary>
        /// Unique identifier for the preset
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Visual color of the brick
        /// </summary>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Additional hits required beyond the first hit
        /// </summary>
        public int SupplementaryHitsToDestroy { get; set; }

        /// <summary>
        /// Whether the brick cannot be destroyed
        /// </summary>
        public bool Undestructible { get; set; }

        /// <summary>
        /// Score value when destroyed
        /// </summary>
        public int ScoreValue { get; set; }

        /// <summary>
        /// Human-readable description
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Base probability of appearance
        /// </summary>
        public float Probability { get; set; }

        /// <summary>
        /// Whether this brick type has special effects
        /// </summary>
        public bool IsSpecial { get; set; }

        /// <summary>
        /// Type of power-up this brick might drop
        /// </summary>
        public PowerupType PowerUpType { get; set; }
    }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPresets.cs ---
namespace Breakout.Game;

/// <summary>
/// Manages brick presets and their applications
/// </summary>
public static class BrickPresets
{
    /// <summary>
    /// Collection of all available brick presets
    /// </summary>
    public static Dictionary<string, BrickPreset> Presets;

    /// <summary>
    /// Static constructor to initialize presets
    /// </summary>
    static BrickPresets()
    {
        InitializePresets();
    }

    /// <summary>
    /// Gets all available presets
    /// </summary>
    public static IReadOnlyDictionary<string, BrickPreset> All => Presets;

    /// <summary>
    /// Initializes the standard brick presets
    /// </summary>
    private static void InitializePresets()
    {
        Presets = new Dictionary<string, BrickPreset>
        {
            // Standard bricks (1 hit)
            { "Standard_Red", new BrickPreset {
                Id = "Standard_Red",
                BackgroundColor = Colors.Magenta,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 50,
                Description = "Standard brick, 1 hit",
                Probability = 0.2f
            }},

            { "Standard_Blue", new BrickPreset {
                    Id = "Standard_Blue",
                    BackgroundColor = Colors.CornflowerBlue,
                    SupplementaryHitsToDestroy = 0,
                    ScoreValue = 10,
                    Description = "Standard brick, 1 hit",
                    Probability = 0.30f
            }},

            { "Standard_Green", new BrickPreset {
                Id = "Standard_Green",
                BackgroundColor = Colors.HotPink,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 10,
                Description = "Standard brick, 1 hit",
                Probability = 0.30f
            }},

            { "Standard_Orange", new BrickPreset {
                Id = "Standard_Orange",
                BackgroundColor = Colors.Orange,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 15,
                Description = "Standard brick, 1 hit",
                Probability = 0.20f
            }},

            { "Standard_Yellow", new BrickPreset {
                Id = "Standard_Yellow",
                BackgroundColor = Colors.Yellow,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 15,
                Description = "Standard brick, 1 hit",
                Probability = 0.15f
            }},

            // Reinforced bricks (2 hits)
            { "Reinforced_Brown", new BrickPreset {
                Id = "Reinforced_Brown",
                BackgroundColor = Colors.GreenYellow,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 20,
                Description = "???",
                Probability = 0.15f
            }},

            // Hard bricks (3 hits)
            { "Hard_DarkGray", new BrickPreset {
                Id = "Hard_DarkGray",
                BackgroundColor = Colors.DarkGreen,
                SupplementaryHitsToDestroy = 1,
                ScoreValue = 30,
                Description = "Hard brick, 3 hits",
            }},

            // Obstacle bricks (indestructible)
            { "Obstacle_Black", new BrickPreset {
                Id = "Obstacle_Black",
                BackgroundColor = Colors.DarkGray,
                Undestructible = true,
                ScoreValue = 0,
                Description = "Indestructible obstacle",
                Probability = 0.05f
            }},

            // Special bricks (with power-ups)
            { "Special_Green", new BrickPreset {
                Id = "Special_Green",
                BackgroundColor = Colors.LightGreen,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 25,
                IsSpecial = true,
                Description = "Drops paddle expander power-up",
                Probability = 0.07f
            }},

            { "Special_Blue", new BrickPreset {
                Id = "Special_Blue",
                BackgroundColor = Colors.LightBlue,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 25,
                IsSpecial = true,
                Description = "Drops slow ball power-up",
                Probability = 0.07f
            }},

            { "Special_Purple", new BrickPreset {
                Id = "Special_Purple",
                BackgroundColor = Colors.Purple,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 35,
                IsSpecial = true,
                PowerUpType = PowerupType.ExtraLife,
                Description = "Drops extralife power-up",
                Probability = 0.04f
            }},

            { "Special_Gold", new BrickPreset {
                Id = "Special_Gold",
                BackgroundColor = Colors.Gold,
                SupplementaryHitsToDestroy = 1,
                ScoreValue = 50,
                IsSpecial = true,
                Probability = 0.02f
            }}
        };
    }

    /// <summary>
    /// Applies a preset to a brick
    /// </summary>
    public static void ApplyPreset(BrickSprite brick, string presetId)
    {
        if (brick != null)
        {
            brick.ResetAnimationState();
            if (Presets.TryGetValue(presetId, out var preset))
            {
                brick.BackgroundColor = preset.BackgroundColor;
                brick.SupplementaryHitsToDestroy = preset.SupplementaryHitsToDestroy;
                brick.Undestructible = preset.Undestructible;

                // Additional properties could be set here if BrickSprite supports them
            }
        }
    }

    /// <summary>
    /// Gets a preset by ID
    /// </summary>
    public static BrickPreset GetPreset(string presetId)
    {
        return Presets.TryGetValue(presetId, out var preset) ? preset : null;
    }

    /// <summary>
    /// Gets all presets matching a filter
    /// </summary>
    public static List<BrickPreset> GetPresets(Func<BrickPreset, bool> filter)
    {
        return Presets.Values.Where(filter).ToList();
    }
}

--- C:\code\DrawnUi\src\Game\Levels\FormationType.cs ---
namespace Breakout.Game
{
    /// <summary>
    /// Represents a formation type for brick layouts
    /// </summary>
    public enum FormationType
    {
        Grid,           // Regular grid layout
        Pyramid,        // Triangular/pyramid shape
        Arch,           // Arch or multiple arches
        Diamond,
        Zigzag,
        Organic,        // Organic/irregular shape using noise
        Wave,
        Maze,           // Maze-like corridors and walls
    }
}

--- C:\code\DrawnUi\src\Game\Levels\LevelManager.cs ---
namespace Breakout.Game
{
    
    /// <summary>
    /// Manages level generation and difficulty progression
    /// </summary>
    public class LevelManager
    {
        #region Properties

        /// <summary>
        /// Current game level
        /// </summary>
        public int CurrentLevel { get; private set; } = 1;

        /// <summary>
        /// Current difficulty factor
        /// </summary>
        public float Difficulty { get; private set; } = 1.0f;

        /// <summary>
        /// Number of critical paths in path-based generations
        /// </summary>
        public int MaxPathsPerLevel { get; set; } = 3;

        /// <summary>
        /// Probability of reinforced bricks appearing
        /// </summary>
        public float ReinforcedBrickProbability { get; private set; } = 0.15f;

        /// <summary>
        /// Probability of obstacle bricks appearing
        /// </summary>
        public float ObstacleBrickProbability { get; private set; } = 0.05f;

        /// <summary>
        /// Probability of special bricks appearing
        /// </summary>
        public float SpecialBrickProbability { get; private set; } = 0.1f;

        /// <summary>
        /// Default brick height
        /// </summary>
        public float DefaultBrickHeight { get; set; } = 20f;

        /// <summary>
        /// Maximum columns in layout
        /// </summary>
        public int MaxColumns { get; set; } = BreakoutGame.MAX_BRICKS_COLUMNS;

        /// <summary>
        /// Maximum rows in layout
        /// </summary>
        public int MaxRows { get; set; } = BreakoutGame.MAX_BRICKS_ROWS;

        /// <summary>
        /// Horizontal spacing between bricks
        /// </summary>
        public float HorizontalSpacing { get; set; } = 4f;

        /// <summary>
        /// Vertical spacing between bricks
        /// </summary>
        public float VerticalSpacing { get; set; } = 6f;

        /// <summary>
        /// Space from top of play area
        /// </summary>
        public float TopMargin { get; set; } = 30f;

        /// <summary>
        /// Space from sides of play area
        /// </summary>
        public float SideMargin { get; set; } = 16f;

        /// <summary>
        /// Whether to allow variable brick sizes
        /// </summary>
        public bool AllowVariableBrickSizes { get; set; } = false;

        /// <summary>
        /// Base difficulty multiplier
        /// </summary>
        public float BaseDifficulty { get; set; } = 1.0f;

        /// <summary>
        /// How much difficulty increases per level
        /// </summary>
        public float DifficultyIncreasePerLevel { get; set; } = 0.15f;

        /// <summary>
        /// Base chance for indestructible bricks
        /// </summary>
        public float IndestructibleBrickBaseChance { get; set; } = 0.02f;

        /// <summary>
        /// Increase in indestructible chance per level
        /// </summary>
        public float IndestructibleBrickLevelScaling { get; set; } = 0.01f;

        /// <summary>
        /// Minimum level for indestructible bricks to appear
        /// </summary>
        public int MinimumLevelForIndestructible { get; set; } = 3;

        /// <summary>
        /// Maximum indestructible bricks per level
        /// </summary>
        public int MaxIndestructibleBricks { get; set; } = 5;

        /// <summary>
        /// Scale of noise function for organic shapes
        /// </summary>
        public float NoiseScale { get; set; } = 0.1f;

        /// <summary>
        /// Threshold for brick placement in noise-based generation
        /// </summary>
        public float NoiseThreshold { get; set; } = 0.5f;

        /// <summary>
        /// Smoothing iterations for organic shapes
        /// </summary>
        public int SmoothingPasses { get; set; } = 2;

        /// <summary>
        /// Random number generator
        /// </summary>
        private Random _random = new Random();

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new level manager
        /// </summary>
        public LevelManager()
        {
            // Default constructor
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Counts the number of breakable bricks in the generated level
        /// </summary>
        /// <param name="positions">The list of brick positions generated for the level</param>
        /// <returns>The number of bricks that can be destroyed</returns>
        public int CountBreakableBricks(List<BrickPosition> positions)
        {
            int breakableBricks = 0;

            foreach (var position in positions)
            {
                if (!string.IsNullOrEmpty(position.PresetId))
                {
                    var preset = BrickPresets.GetPreset(position.PresetId);

                    // Count as breakable if not undestructible and not special
                    if (preset != null && !preset.Undestructible)
                    {
                        breakableBricks++;
                    }
                }
            }

            return breakableBricks;
        }

        /// <summary>
        /// Generates a level with specified parameters
        /// </summary>
        public List<BrickPosition> GenerateLevel(
            int level,
            float availableWidth,
            float availableHeight,
            FormationType formation = FormationType.Grid,
            List<string> allowedPresets = null,
            Dictionary<string, float> presetProbabilityOverrides = null)
        {
            CurrentLevel = level;
            Difficulty = CalculateLevelDifficulty(level);

            // Calculate columns and rows based on level and available space
            int columns = DetermineColumns(level);
            int rows = DetermineRows(level);

            // Generate formation positions (rows may be adjusted by formation requirements)
            var positions = GenerateFormation(formation, columns, ref rows);

            // Filter allowed presets if specified
            var presets = FilterPresets(allowedPresets);

            // Apply difficulty and assign brick types
            AssignBrickTypes(positions, level, presets, presetProbabilityOverrides);

            // Return the positions (let the game create actual sprites)
            return positions;
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Calculates level difficulty based on level number
        /// </summary>
        private float CalculateLevelDifficulty(int level)
        {
            return BaseDifficulty + (level) * DifficultyIncreasePerLevel;
        }

        /// <summary>
        /// Determines number of columns based on level
        /// </summary>
        private int DetermineColumns(int level)
        {
            return MaxColumns;
        }

        /// <summary>
        /// Determines number of rows based on level
        /// </summary>
        private int DetermineRows(int level)
        {
            return Math.Min(BreakoutGame.MIN_BRICKS_ROWS + level, MaxRows);
        }

        /// <summary>
        /// Calculates brick width based on available space and columns
        /// </summary>
        private float CalculateBrickWidth(float availableWidth, int columns)
        {
            float totalSpacing = HorizontalSpacing * (columns + 1);
            float availableWidthForBricks = availableWidth - totalSpacing - (SideMargin * 2);
            return availableWidthForBricks / columns;
        }

        /// <summary>
        /// Filters presets based on allowed list
        /// </summary>
        private List<BrickPreset> FilterPresets(List<string> allowedPresets)
        {
            if (allowedPresets == null || allowedPresets.Count == 0)
            {
                // If no filter, use all presets
                return BrickPresets.All.Values.ToList();
            }

            return BrickPresets.GetPresets(p => allowedPresets.Contains(p.Id));
        }

        /// <summary>
        /// Gets the chance for indestructible bricks based on level
        /// </summary>
        private float GetIndestructibleBrickChance(int level)
        {
            if (level < MinimumLevelForIndestructible)
                return 0;

            return Math.Min(
                IndestructibleBrickBaseChance + ((level - MinimumLevelForIndestructible) * IndestructibleBrickLevelScaling),
                0.25f // Cap at 25% chance for game balance
            );
        }

        /// <summary>
        /// Determines if a position is strategic for obstacle placement
        /// </summary>
        private bool IsStrategicPosition(float row, float col, int maxCols)
        {
            // Key pathways (middle columns on higher rows)
            bool isKeyPathway = (col > maxCols / 3 && col < 2 * maxCols / 3) && row < 2;

            // Border positions that block access
            bool isBorder = col == 0 || col == maxCols - 1 || row == 0;

            // "Chokepoints" where the ball must pass
            bool isChokepoint = (Math.Abs(col - maxCols / 2) < 1) && row % 2 == 0;

            return isKeyPathway || isBorder || isChokepoint;
        }

        /// <summary>
        /// Selects a brick preset based on difficulty and random factors
        /// </summary>
        private string SelectBrickPresetByDifficulty(List<BrickPreset> presets, float difficulty,
            Dictionary<string, float> probabilityOverrides)
        {
            // Group presets by type
            var standardPresets = presets.Where(p => p.SupplementaryHitsToDestroy == 0 && !p.IsSpecial && !p.Undestructible).ToList();
            var reinforcedPresets = presets.Where(p => p.SupplementaryHitsToDestroy > 0 && !p.IsSpecial && !p.Undestructible).ToList();
            var specialPresets = presets.Where(p => p.IsSpecial).ToList();
            var obstaclePresets = presets.Where(p => p.Undestructible).ToList();

            // If no presets of a certain type, return null or a default
            if (standardPresets.Count == 0)
                return null;

            float randomValue = (float)_random.NextDouble();

            // Apply difficulty scaling to probabilities
            float reinforcedChance = ReinforcedBrickProbability * difficulty;
            float specialChance = SpecialBrickProbability;
            float obstacleChance = ObstacleBrickProbability * difficulty;

            // Apply any overrides
            if (probabilityOverrides != null)
            {
                foreach (var preset in reinforcedPresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        reinforcedChance = overrideProb;
                        break;
                    }
                }

                foreach (var preset in obstaclePresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        obstacleChance = overrideProb;
                        break;
                    }
                }

                foreach (var preset in specialPresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        specialChance = overrideProb;
                        break;
                    }
                }
            }

            // Select brick type based on probabilities
            if (obstaclePresets.Count > 0 && randomValue < obstacleChance)
            {
                return obstaclePresets[_random.Next(obstaclePresets.Count)].Id;
            }
            else if (reinforcedPresets.Count > 0 && randomValue < obstacleChance + reinforcedChance)
            {
                return reinforcedPresets[_random.Next(reinforcedPresets.Count)].Id;
            }
            else if (specialPresets.Count > 0 && randomValue < obstacleChance + reinforcedChance + specialChance)
            {
                return specialPresets[_random.Next(specialPresets.Count)].Id;
            }
            else
            {
                return standardPresets[_random.Next(standardPresets.Count)].Id;
            }
        }

        /// <summary>
        /// Assigns brick types to positions based on level difficulty
        /// </summary>
        private void AssignBrickTypes(List<BrickPosition> positions, int level, List<BrickPreset> presets,
            Dictionary<string, float> probabilityOverrides)
        {
            int indestructibleCount = 0;
            int maxCols = positions.Max(p => (int)p.Column) + 1;

            foreach (var position in positions)
            {
                // Check for strategic positions that might get indestructible bricks
                bool isStrategic = IsStrategicPosition(position.Row, position.Column, maxCols);

                // Calculate indestructible chance with strategic bonus
                float indestructibleChance = GetIndestructibleBrickChance(level);
                if (isStrategic)
                    indestructibleChance *= 2;

                // Assign indestructible if appropriate
                if (indestructibleCount < MaxIndestructibleBricks && _random.NextDouble() < indestructibleChance)
                {
                    var obstaclePresets = presets.Where(p => p.Undestructible).ToList();
                    if (obstaclePresets.Count > 0)
                    {
                        position.PresetId = obstaclePresets[_random.Next(obstaclePresets.Count)].Id;
                        indestructibleCount++;
                        continue;
                    }
                }

                // For other bricks, select by difficulty
                position.PresetId = SelectBrickPresetByDifficulty(presets, Difficulty, probabilityOverrides);
            }
        }



        /// <summary>
        /// Normalizes brick positions to ensure they start from column 0 (left-aligned)
        /// </summary>
        private void NormalizePositions(List<BrickPosition> positions)
        {
            if (positions == null || positions.Count == 0)
                return;

            float minColumn = positions.Min(p => p.Column);

            if (minColumn != 0)
            {
                float offset = -minColumn;
                foreach (var position in positions)
                {
                    position.Column += offset;
                }
            }
        }

        /// <summary>
        /// Adjusts the number of rows based on formation requirements
        /// </summary>
        private int AdjustRowsForFormation(FormationType formation, int requestedRows)
        {
            switch (formation)
            {
                case FormationType.Diamond:
                    // Diamond needs minimum 5 rows to form proper shape, max 12 for good proportions
                    return Math.Max(8, Math.Min(12, requestedRows));

                case FormationType.Arch:
                    // Arch needs minimum 5 rows for proper arch shape, max 12
                    return Math.Max(8, Math.Min(12, requestedRows));

                case FormationType.Wave:
                    // Wave needs minimum 6 rows for visible wave pattern, max 10
                    return Math.Max(6, Math.Min(10, requestedRows));

                case FormationType.Maze:
                    // Maze needs minimum 6 rows for corridors, max 15 for complexity
                    return Math.Max(6, Math.Min(15, requestedRows));

                case FormationType.Organic:
                    // Organic can work with any size but looks better with minimum 5 rows
                    return Math.Max(8, requestedRows);

                case FormationType.Zigzag:
                    // Zigzag needs minimum 4 rows for pattern, max 12
                    return Math.Max(6, Math.Min(12, requestedRows));

                case FormationType.Grid:
                default:
                    // Grid can work with any number of rows
                    return requestedRows;
            }
        }

        /// <summary>
        /// Generates formation based on specified type
        /// </summary>
        private List<BrickPosition> GenerateFormation(FormationType formation, int columns, ref int rows)
        {
            List<BrickPosition> positions;

            // Adjust rows based on formation requirements
            rows = AdjustRowsForFormation(formation, rows);

            switch (formation)
            {
                case FormationType.Pyramid:
                    positions = GeneratePyramidFormation(columns, rows);
                    break;
                case FormationType.Arch:
                    positions = GenerateArchFormation(columns, rows);
                    break;
                case FormationType.Diamond:
                    positions = GenerateDiamondFormation(columns, rows);
                    break;
                case FormationType.Zigzag:
                    positions = GenerateZigzagFormation(columns, rows);
                    break;
                //case FormationType.Spiral:
                //    positions = GenerateSpiralFormation(columns, rows);
                //    break;
                case FormationType.Organic:
                    positions = GenerateOrganicFormation(columns, rows);
                    break;
                case FormationType.Wave:
                    positions = GenerateWaveFormation(columns, rows);
                    break;
                case FormationType.Maze:
                    positions = GenerateMazeFormation(columns, rows);
                    break;
                case FormationType.Grid:
                default:
                    positions = GenerateGridFormation(columns, rows);
                    break;
            }

            NormalizePositions(positions);
            return positions;
        }

        #endregion

        #region Formation Generators

        /// <summary>
        /// Generates a standard grid formation
        /// </summary>
        private List<BrickPosition> GenerateGridFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = col,
                        Row = row,
                        PresetId = null // Will be assigned later
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a pyramid formation
        /// </summary>
        private List<BrickPosition> GeneratePyramidFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Calculate max width based on requested rows to ensure pyramid fits
            int maxWidth = Math.Min(columns, rows * 2 - 1); // Ensure pyramid can have the requested height

            // Center position offset
            float centerX = columns / 2f;

            for (int row = 0; row < rows; row++)
            {
                // Calculate how many bricks in this row (wider at bottom, narrower at top)
                int rowWidth = maxWidth - row * 2;
                if (rowWidth <= 0) break; // Safety check, but shouldn't happen with proper maxWidth

                // Calculate starting position to center the row
                float startX = centerX - (rowWidth / 2f);

                for (int col = 0; col < rowWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = startX + col,
                        Row = row,
                        PresetId = null // Will be assigned later
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates an arch formation
        /// </summary>
        private List<BrickPosition> GenerateArchFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Number of arches
            int numArches = Math.Max(1, columns / 6);

            // Width of each arch
            int archWidth = columns / numArches;

            // Height of arches
            int archHeight = Math.Min(rows, archWidth / 2);

            for (int archIdx = 0; archIdx < numArches; archIdx++)
            {
                float archCenterX = archIdx * archWidth + archWidth / 2f;

                // Create the arch
                for (int row = 0; row < archHeight; row++)
                {
                    // Calculate width at this row (wider at top)
                    float rowWidth = archWidth * (1 - (float)row / archHeight);

                    // Calculate starting position
                    float startX = archCenterX - rowWidth / 2;
                    float endX = archCenterX + rowWidth / 2;

                    // Add bricks along the row
                    for (float col = startX; col < endX; col++)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }

                // Add some supporting columns
                for (int row = archHeight; row < rows; row++)
                {
                    // Left support
                    positions.Add(new BrickPosition
                    {
                        Column = archCenterX - archWidth / 2,
                        Row = row,
                        PresetId = null
                    });

                    // Right support
                    positions.Add(new BrickPosition
                    {
                        Column = archCenterX + archWidth / 2 - 1,
                        Row = row,
                        PresetId = null
                    });
                }
            }

            return positions;
        }

        private List<BrickPosition> GenerateDiamondFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Define the center. For an even number of columns/rows, 
            // the center is between cells, so we use (columns - 1) / 2f, etc.
            float centerX = (columns - 1) / 2f;
            float centerY = (rows - 1) / 2f;

            // Decide how large the diamond should be horizontally and vertically.
            // If you want it to span the full grid width/height, use columns-1 and rows-1 as below.
            float horizontalRadius = (columns - 1) / 2f;
            float verticalRadius = (rows - 1) / 2f;

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    // Offsets from center
                    float dx = col - centerX;
                    float dy = row - centerY;

                    // Diamond equation in “centered” form:
                    //   |dx|/horizontalRadius + |dy|/verticalRadius <= 1
                    if ((Math.Abs(dx) / horizontalRadius) + (Math.Abs(dy) / verticalRadius) <= 1f)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null // assigned later
                        });
                    }
                }
            }

            return positions;
        }


        /// <summary>
        /// Generates a zigzag formation
        /// </summary>
        private List<BrickPosition> GenerateZigzagFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Number of zigzags
            int zigzagCount = Math.Max(2, rows / 3);

            // Width of each zigzag leg
            int legWidth = columns / 2;

            for (int zigzag = 0; zigzag < zigzagCount; zigzag++)
            {
                int rowStart = zigzag * 3;

                // Going right
                for (int col = 0; col < legWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = col,
                        Row = rowStart,
                        PresetId = null
                    });
                }

                // Going left
                for (int col = 0; col < legWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = columns - 1 - col,
                        Row = rowStart + 1,
                        PresetId = null
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates an organic formation using noise
        /// </summary>
        private List<BrickPosition> GenerateOrganicFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Create a noise seed
            float seedX = (float)_random.NextDouble() * 100;
            float seedY = (float)_random.NextDouble() * 100;

            // Create a boolean grid to track brick positions
            bool[,] hasBlock = new bool[columns, rows];

            // Fill using noise
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    // Generate perlin-like noise value
                    float noiseValue = GenerateNoiseValue(col * NoiseScale + seedX, row * NoiseScale + seedY);

                    // If noise value exceeds threshold, place a brick
                    if (noiseValue > NoiseThreshold)
                    {
                        hasBlock[col, row] = true;
                    }
                }
            }

            // Apply smoothing if needed
            if (SmoothingPasses > 0)
            {
                for (int pass = 0; pass < SmoothingPasses; pass++)
                {
                    hasBlock = SmoothOrganicGrid(hasBlock, columns, rows);
                }
            }

            // Convert grid to positions
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    if (hasBlock[col, row])
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a wave formation
        /// </summary>
        private List<BrickPosition> GenerateWaveFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Wave parameters
            float amplitude = rows / 5f;
            float frequency = 2 * (float)Math.PI / columns;
            int waves = 2;  // Number of complete waves

            for (int col = 0; col < columns; col++)
            {
                // Calculate wave height at this column
                float waveY = amplitude * (float)Math.Sin(frequency * waves * col);

                // Center wave vertically
                float centerY = rows / 2f;
                float baseY = centerY + waveY;

                // Place bricks above and below the wave curve
                for (int offset = -2; offset <= 2; offset++)
                {
                    float y = baseY + offset;
                    if (y >= 0 && y < rows)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = y,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a simple noise value (simple hash-based noise)
        /// </summary>
        private float GenerateNoiseValue(float x, float y)
        {
            // A simple hash-based noise function
            float n = x + y * 57;
            n = (n * 21.5453f) % 1.0f;
            return n;
        }

        /// <summary>
        /// Smooths an organic grid using cellular automata rules
        /// </summary>
        private bool[,] SmoothOrganicGrid(bool[,] grid, int width, int height)
        {
            bool[,] newGrid = new bool[width, height];

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    // Count alive neighbors
                    int neighbors = 0;
                    for (int nx = -1; nx <= 1; nx++)
                    {
                        for (int ny = -1; ny <= 1; ny++)
                        {
                            if (nx == 0 && ny == 0) continue;

                            int checkX = x + nx;
                            int checkY = y + ny;

                            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height)
                            {
                                if (grid[checkX, checkY])
                                    neighbors++;
                            }
                        }
                    }

                    // Apply cellular automata rules
                    if (grid[x, y])
                    {
                        // Cell is alive
                        newGrid[x, y] = neighbors >= 3;
                    }
                    else
                    {
                        // Cell is dead
                        newGrid[x, y] = neighbors >= 5;
                    }
                }
            }

            return newGrid;
        }

        /// <summary>
        /// Generates a maze-like formation with corridors and walls
        /// </summary>
        private List<BrickPosition> GenerateMazeFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Create maze using simple algorithm
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    bool placeBrick = false;

                    // Create maze walls - every 3rd column and row creates corridors
                    if (row % 3 == 0 || col % 3 == 0)
                    {
                        placeBrick = true;
                    }

                    // Add some random openings in walls (30% chance)
                    if (placeBrick && _random.NextDouble() < 0.3)
                    {
                        placeBrick = false;
                    }

                    // Add some random blocks in corridors (20% chance)
                    if (!placeBrick && _random.NextDouble() < 0.2)
                    {
                        placeBrick = true;
                    }

                    if (placeBrick)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\Levels\PowerUpType.cs ---
namespace Breakout.Game;

/// <summary>
/// Types of power-ups that can be dropped by special bricks
/// </summary>
public enum PowerupType
{
    None,
    Destroyer,
    StickyBall,
    ExpandPaddle,
    ShrinkPaddle,
    SlowBall,
    FastBall,
    MultiBall,
    ExtraLife,
    Fireball
}

--- C:\code\DrawnUi\src\Game\Sound\AudioMixerService.cs ---
using System.Diagnostics;
using System.Numerics;
using AppoMobi.Specials;
using Plugin.Maui.Audio;

namespace Breakout.Game;

/// <summary>
/// Game audio service using Plugin.Maui.Audio's AudioMixer for professional sound management
/// </summary>
public class AudioMixerService : IAudioService
{
    #region CONSTANTS

    /// <summary>
    /// Number of audio channels for sound effects
    /// </summary>
    private const int SOUND_EFFECT_CHANNELS = 8;

    #endregion

    #region SOUND DATA STORAGE

    // Store preloaded audio sources for use with AudioMixer
    private readonly Dictionary<string, MemoryAudioSource> _soundSources = new();

    #endregion

    #region PROPERTIES

    private float _masterVolume = 1.0f;
    private bool _isMuted;

    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    public float MasterVolume
    {
        get => _masterVolume;
        set
        {
            _masterVolume = Math.Clamp(value, 0f, 1f);
            UpdateAllChannelVolumes();
        }
    }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    public bool IsMuted
    {
        get => _isMuted;
        set
        {
            _isMuted = value;
            UpdateAllChannelVolumes();
            UpdateBackgroundMusicVolume();
        }
    }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    public bool IsBackgroundMusicPlaying => _backgroundMusicPlayer?.IsPlaying == true;

    #endregion

    #region FIELDS

    // Audio management using AudioMixer
    private readonly IAudioManager _audioManager;
    private readonly AudioMixer _audioMixer;

    // Background music tracking
    private IAudioPlayer _backgroundMusicPlayer;
    private float _backgroundMusicVolume = 0.3f;

    // Sound effect management
    private int _currentSoundChannel = 0;

    #endregion

    #region CONSTRUCTOR

    /// <summary>
    /// Initializes a new game audio service using AudioMixer
    /// </summary>
    /// <param name="audioManager">The MAUI Audio manager instance</param>
    public AudioMixerService(IAudioManager audioManager)
    {
        _audioManager = audioManager ?? throw new ArgumentNullException(nameof(audioManager));
        _audioMixer = new AudioMixer(audioManager, SOUND_EFFECT_CHANNELS);
    }

    #endregion

    #region PRELOADING

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    public async Task<bool> PreloadSoundAsync(string soundId, string filePath)
    {
        try
        {
            // Load audio data into memory
            byte[] audioData;
            using (var stream = await FileSystem.OpenAppPackageFileAsync(filePath))
            using (var memoryStream = new MemoryStream())
            {
                await stream.CopyToAsync(memoryStream);
                audioData = memoryStream.ToArray();
            }

            // Create audio source from data
            var audioSource = new MemoryAudioSource(audioData);
            _soundSources[soundId] = audioSource;

            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error preloading '{soundId}': {ex}");
            return false;
        }
    }

    #endregion

    #region SOUND PLAYBACK

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false)
    {
        if (_audioMixer == null)
            return;

        Tasks.StartDelayed(TimeSpan.FromMicroseconds(1), () =>
        {
            if (IsMuted)
                volume = 0f;
            else
                volume *= MasterVolume;

            if (!_soundSources.TryGetValue(soundId, out var audioSource))
            {
                Debug.WriteLine($"Sound '{soundId}' not preloaded");
                return;
            }

            try
            {
                // Get next available channel (round-robin)
                int channelIndex = _currentSoundChannel;
                _currentSoundChannel = (_currentSoundChannel + 1) % SOUND_EFFECT_CHANNELS;

                // Play sound on the selected channel
                _audioMixer.Play(channelIndex, audioSource, loop);
                _audioMixer.SetVolume(channelIndex, volume);
                _audioMixer.SetBalance(channelIndex, balance);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error playing sound '{soundId}': {ex}");
            }
        });
    }

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false)
    {
        if (IsMuted)
            volume = 0f;
        else
            volume *= MasterVolume;

        var (balance, adjustedVolume) = _audioMixer.PositionInSpace(position, volume, 0f);

        PlaySound(soundId, adjustedVolume, balance, loop);
    }

    #endregion

    #region BACKGROUND MUSIC

    public async void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        try
        {
            // Stream directly from file using Plugin.Maui.Audio
            var fileStream = await FileSystem.OpenAppPackageFileAsync(filePath);
            _backgroundMusicPlayer = _audioManager.CreatePlayer(fileStream);
            _backgroundMusicPlayer.Loop = true;
            UpdateBackgroundMusicVolume();
            _backgroundMusicPlayer.Play();

            Debug.WriteLine($"Started background music streaming from '{filePath}' using AudioMixer");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error starting background music from file '{filePath}': {ex}");
        }
    }


    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void StartBackgroundMusic(string soundId, float volume = 0.3f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        if (_soundSources.TryGetValue(soundId, out var audioSource))
        {
            _backgroundMusicPlayer = _audioManager.CreatePlayer(audioSource.GetAudioStream());
            _backgroundMusicPlayer.Loop = true;
            UpdateBackgroundMusicVolume();
            _backgroundMusicPlayer.Play();
        }
    }

    /// <summary>
    /// Stops background music playback
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                _backgroundMusicPlayer.Stop();
                _backgroundMusicPlayer.Dispose();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error stopping background music: {ex}");
            }
            finally
            {
                _backgroundMusicPlayer = null;
            }
        }
    }

    #endregion

    #region VOLUME MANAGEMENT

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void SetSoundVolume(string soundId, float volume)
    {
        volume = Math.Clamp(volume, 0f, 1f);

        // Special handling for background music
        if (soundId == "background")
        {
            _backgroundMusicVolume = volume;
            UpdateBackgroundMusicVolume();
            return;
        }

        // Note: For sound effects, we can't easily adjust volume for specific sound IDs
        // since the AudioMixer manages channels independently. This would require tracking
        // which sounds are playing on which channels, which adds complexity.
        Debug.WriteLine(
            $"SetSoundVolume for '{soundId}' - individual sound volume control not supported with AudioMixer");
    }

    /// <summary>
    /// Updates the volume of all sound effect channels based on master volume and mute state
    /// </summary>
    private void UpdateAllChannelVolumes()
    {
        float effectiveVolume = IsMuted ? 0f : MasterVolume;

        for (int i = 0; i < SOUND_EFFECT_CHANNELS; i++)
        {
            try
            {
                var channel = _audioMixer.GetChannel(i);
                if (channel.IsPlaying)
                {
                    _audioMixer.SetVolume(i, effectiveVolume);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating channel {i} volume: {ex}");
            }
        }
    }

    /// <summary>
    /// Updates background music volume based on settings
    /// </summary>
    private void UpdateBackgroundMusicVolume()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                float effectiveVolume = IsMuted ? 0f : _backgroundMusicVolume * MasterVolume;
                _backgroundMusicPlayer.Volume = effectiveVolume;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating background music volume: {ex}");
            }
        }
    }

    #endregion

    #region DISPOSAL

    /// <summary>
    /// Cleans up all resources used by the audio service
    /// </summary>
    public void Dispose()
    {
        StopBackgroundMusic();
        _audioMixer?.Dispose();

        foreach (var audioSource in _soundSources.Values)
        {
            try
            {
                audioSource?.Dispose();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error disposing audio source: {ex}");
            }
        }

        _soundSources.Clear();
    }

    #endregion
}

--- C:\code\DrawnUi\src\Game\Sound\GameAudioSource.cs ---
using Plugin.Maui.Audio;

namespace Breakout.Game;

public interface IGameAudioSource : IAudioSource, IDisposable
{
}

/// <summary>
/// Preloaded IAudioSource for sound effects (small files, zero-lag playback)
/// </summary>
internal class GameAudioSource : IGameAudioSource
{
    private readonly byte[] _audioData;
    private MemoryStream _stream;

    public GameAudioSource(byte[] audioData)
    {
        _audioData = audioData ?? throw new ArgumentNullException(nameof(audioData));
        _stream = new MemoryStream(_audioData, false); // Read-only
    }

    public Stream GetAudioStream()
    {
        // Reset position and return the same stream
        _stream.Position = 0;
        return _stream;
    }

    public void Dispose()
    {
        _stream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sound\IAudioService.cs ---
using System.Numerics;

namespace Breakout.Game;

/// <summary>
/// Interface for game audio services to enable easy switching between implementations
/// </summary>
public interface IAudioService : IDisposable
{
    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    float MasterVolume { get; set; }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    bool IsMuted { get; set; }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    bool IsBackgroundMusicPlaying { get; }

    void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f);

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    Task<bool> PreloadSoundAsync(string soundId, string filePath);

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false);

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false);

    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    void StartBackgroundMusic(string soundId, float volume = 0.3f);

    /// <summary>
    /// Stops background music playback
    /// </summary>
    void StopBackgroundMusic();

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    void SetSoundVolume(string soundId, float volume);
}

--- C:\code\DrawnUi\src\Game\Sound\MemoryAudioSource.cs ---
namespace Breakout.Game;

/// <summary>
/// Simple audio source implementation for memory-based audio data, reuses stream
/// </summary>
internal class MemoryAudioSource : IGameAudioSource
{
    private readonly byte[] _audioData;
    private readonly MemoryStream _reusableStream;

    public MemoryAudioSource(byte[] audioData)
    {
        _audioData = audioData ?? throw new ArgumentNullException(nameof(audioData));
        _reusableStream = new MemoryStream(_audioData, false); // Read-only
    }

    public Stream GetAudioStream()
    {
        // Reset position and return the same stream
        _reusableStream.Position = 0;
        return _reusableStream;
    }

    public void Dispose()
    {
        _reusableStream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sound\SoundFlowAudioService.cs ---
#if ANDROID

using AppoMobi.Specials;
using SoundFlow.Abstracts;
using SoundFlow.Backends.MiniAudio;
using SoundFlow.Components;
using SoundFlow.Enums;
using SoundFlow.Interfaces;
using SoundFlow.Providers;
using System.Diagnostics;
using System.Numerics;

namespace Breakout.Game;

/// <summary>
/// Game audio service using SoundFlow for high-performance cross-platform audio management
/// </summary>
public class SoundFlowAudioService : IAudioService
{
    #region CONSTANTS

    /// <summary>
    /// Number of audio channels for sound effects
    /// </summary>
    private const int SOUND_EFFECT_CHANNELS = 8;

    /// <summary>
    /// Sample rate for audio engine (48kHz for high quality)
    /// </summary>
    private const int SAMPLE_RATE = 48000;

    #endregion

    #region SOUND DATA STORAGE

    // Store preloaded audio data for use with SoundFlow
    private readonly Dictionary<string, byte[]> _soundData = new();

    // Track active sound players for sound effects
    private readonly List<SoundPlayer> _soundEffectPlayers = new();

    // Object pool for memory streams to reduce GC pressure
    private readonly Queue<MemoryStream> _memoryStreamPool = new();
    private readonly object _poolLock = new();

    #endregion

    #region PROPERTIES

    private float _masterVolume = 1.0f;
    private bool _isMuted;

    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    public float MasterVolume
    {
        get => _masterVolume;
        set
        {
            _masterVolume = Math.Clamp(value, 0f, 1f);
            UpdateAllVolumes();
        }
    }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    public bool IsMuted
    {
        get => _isMuted;
        set
        {
            _isMuted = value;
            UpdateAllVolumes();
        }
    }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    public bool IsBackgroundMusicPlaying => _backgroundMusicPlayer?.State == PlaybackState.Playing;

    #endregion

    #region FIELDS

    // SoundFlow audio engine and mixer
    private readonly AudioEngine _audioEngine;
    private readonly Mixer _masterMixer;

    // Background music tracking
    private SoundPlayerBase _backgroundMusicPlayer;
    private float _backgroundMusicVolume = 0.3f;

    // Sound effect management
    private int _currentSoundChannel = 0;

    // Disposal tracking
    private bool _disposed = false;

    #endregion

    #region CONSTRUCTOR

    /// <summary>
    /// Initializes a new game audio service using SoundFlow
    /// </summary>
    public SoundFlowAudioService()
    {
        try
        {
            // Initialize SoundFlow audio engine with MiniAudio backend
            _audioEngine = new MiniAudioEngine(SAMPLE_RATE, Capability.Playback);
            _masterMixer = Mixer.Master;

            Debug.WriteLine($"SoundFlow audio engine initialized with {SAMPLE_RATE}Hz sample rate");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error initializing SoundFlow audio engine: {ex}");
            throw;
        }
    }

    #endregion

    #region PRELOADING

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    public async Task<bool> PreloadSoundAsync(string soundId, string filePath)
    {
        try
        {
            // Load audio data into memory
            byte[] audioData;
            using (var stream = await FileSystem.OpenAppPackageFileAsync(filePath))
            using (var memoryStream = new MemoryStream())
            {
                await stream.CopyToAsync(memoryStream);
                audioData = memoryStream.ToArray();
            }

            // Store the raw audio data
            _soundData[soundId] = audioData;

            Debug.WriteLine($"Preloaded sound '{soundId}' from '{filePath}' ({audioData.Length} bytes)");
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error preloading '{soundId}': {ex}");
            return false;
        }
    }

    #endregion

    #region SOUND PLAYBACK

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false)
    {
        if (_disposed || _audioEngine == null)
            return;

        //Tasks.StartDelayed(TimeSpan.FromMicroseconds(1), () =>
        //{
            try
            {
                if (IsMuted)
                    volume = 0f;
                else
                    volume *= MasterVolume;

                if (!_soundData.TryGetValue(soundId, out var audioData))
                {
                    Debug.WriteLine($"Sound '{soundId}' not preloaded");
                    return;
                }

                // Create a new SoundPlayer for this sound effect using pooled memory stream
                var memoryStream = GetPooledMemoryStream(audioData);
                var dataProvider = new StreamDataProvider(memoryStream);
                var player = new SoundPlayer(dataProvider);

                // Configure the player
                player.Volume = volume;
                player.IsLooping = loop;

                // Add to master mixer
                _masterMixer.AddComponent(player);

                // Track the player for cleanup
                _soundEffectPlayers.Add(player);

                // Start playback
                player.Play();

                // Clean up finished players periodically
                CleanupFinishedPlayers();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error playing sound '{soundId}': {ex}");
            }
        //});
    }

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false)
    {
        if (IsMuted)
            volume = 0f;
        else
            volume *= MasterVolume;

        // Simple spatial audio calculation
        // Distance attenuation and stereo panning based on X position
        float distance = position.Length();
        float attenuatedVolume = volume / (1.0f + distance * 0.1f); // Simple distance attenuation
        float balance = Math.Clamp(position.X * 0.5f, -1.0f, 1.0f); // Pan based on X position

        PlaySound(soundId, attenuatedVolume, balance, loop);
    }

    #endregion

    #region BACKGROUND MUSIC

 

    public class SFPlayer : SoundPlayerBase
    {
        /// <summary>A sound player that plays audio from a data provider.</summary>
        public SFPlayer(ISoundDataProvider dataProvider) : base (dataProvider)
        {
            _dataProvider = dataProvider;
        }

        private readonly ISoundDataProvider _dataProvider;

        protected override void HandleEndOfStream(Span<float> remainingOutputBuffer)
        {
            if (!_dataProvider.CanSeek)
            {
                //basically we wouldn't be able to loop as we don't know the end
                var check = $"{Time} / {Duration}  {LoopStartSamples} / {LoopEndSamples}  |  {LoopEndSeconds}";
                Debug.WriteLine(check);
            }
            base.HandleEndOfStream(remainingOutputBuffer);
        }

        /// <inheritdoc />
        public override string Name { get; set; }
    }

    /// <summary>
    /// Starts background music playback directly from file (streaming, memory-efficient)
    /// </summary>
    /// <param name="filePath">Path to the background music file</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public async void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        try
        {
            // Stream directly from file instead of loading into memory
            var fileStream = await FileSystem.OpenAppPackageFileAsync(filePath);
            var dataProvider = new StreamDataProvider(fileStream);
            _backgroundMusicPlayer = new SFPlayer(dataProvider);

            _backgroundMusicPlayer.IsLooping = true;
            UpdateBackgroundMusicVolume();

            _masterMixer.AddComponent(_backgroundMusicPlayer);
            _backgroundMusicPlayer.Play();

            Debug.WriteLine($"Started background music streaming from '{filePath}'");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error starting background music from file '{filePath}': {ex}");
        }
    }


    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void StartBackgroundMusic(string soundId, float volume = 0.3f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        if (_soundData.TryGetValue(soundId, out var audioData))
        {
            try
            {
                var memoryStream = GetPooledMemoryStream(audioData);
                var dataProvider = new StreamDataProvider(memoryStream);
                _backgroundMusicPlayer = new SoundPlayer(dataProvider);

                _backgroundMusicPlayer.IsLooping = true;
                UpdateBackgroundMusicVolume();

                _masterMixer.AddComponent(_backgroundMusicPlayer);
                _backgroundMusicPlayer.Play();

                Debug.WriteLine($"Started background music '{soundId}'");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error starting background music '{soundId}': {ex}");
            }
        }
        else
        {
            Debug.WriteLine($"Background music '{soundId}' not preloaded");
        }
    }

    /// <summary>
    /// Stops background music playback
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                _backgroundMusicPlayer.Stop();
                _masterMixer.RemoveComponent(_backgroundMusicPlayer);
                Debug.WriteLine("Stopped background music");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error stopping background music: {ex}");
            }
            finally
            {
                _backgroundMusicPlayer = null;
            }
        }
    }

    #endregion

    #region VOLUME MANAGEMENT

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void SetSoundVolume(string soundId, float volume)
    {
        volume = Math.Clamp(volume, 0f, 1f);

        // Special handling for background music
        if (soundId == "background")
        {
            _backgroundMusicVolume = volume;
            UpdateBackgroundMusicVolume();
            return;
        }

        // Note: For sound effects, individual volume control is complex with SoundFlow
        // since each sound creates a new player. This would require tracking
        // which sounds are playing, which adds complexity.
        Debug.WriteLine($"SetSoundVolume for '{soundId}' - individual sound volume control not implemented");
    }

    /// <summary>
    /// Updates all audio volumes based on master volume and mute state
    /// </summary>
    private void UpdateAllVolumes()
    {
        UpdateBackgroundMusicVolume();

        // Update sound effect volumes
        foreach (var player in _soundEffectPlayers.ToList())
        {
            if (player != null)
            {
                try
                {
                    float effectiveVolume = IsMuted ? 0f : MasterVolume;
                    player.Volume = effectiveVolume;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error updating sound effect volume: {ex}");
                }
            }
        }
    }

    /// <summary>
    /// Updates background music volume based on settings
    /// </summary>
    private void UpdateBackgroundMusicVolume()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                float effectiveVolume = IsMuted ? 0f : _backgroundMusicVolume * MasterVolume;
                _backgroundMusicPlayer.Volume = effectiveVolume;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating background music volume: {ex}");
            }
        }
    }

    #endregion

    #region MEMORY MANAGEMENT

    /// <summary>
    /// Gets a pooled memory stream to reduce GC pressure
    /// </summary>
    /// <param name="audioData">Audio data to initialize the stream with</param>
    /// <returns>A memory stream containing the audio data</returns>
    private MemoryStream GetPooledMemoryStream(byte[] audioData)
    {
        MemoryStream stream;

        lock (_poolLock)
        {
            if (_memoryStreamPool.Count > 0)
            {
                stream = _memoryStreamPool.Dequeue();
                stream.SetLength(0);
                stream.Position = 0;
            }
            else
            {
                stream = new MemoryStream();
            }
        }

        stream.Write(audioData, 0, audioData.Length);
        stream.Position = 0;
        return stream;
    }

    /// <summary>
    /// Returns a memory stream to the pool for reuse
    /// </summary>
    /// <param name="stream">The stream to return to the pool</param>
    private void ReturnMemoryStreamToPool(MemoryStream stream)
    {
        if (stream == null) return;

        lock (_poolLock)
        {
            // Limit pool size to prevent excessive memory usage
            if (_memoryStreamPool.Count < 10)
            {
                stream.SetLength(0);
                stream.Position = 0;
                _memoryStreamPool.Enqueue(stream);
            }
            else
            {
                stream.Dispose();
            }
        }
    }

    #endregion

    #region CLEANUP

    /// <summary>
    /// Cleans up finished sound effect players to prevent memory leaks
    /// </summary>
    private void CleanupFinishedPlayers()
    {
        try
        {
            var playersToRemove = new List<SoundPlayer>();

            foreach (var player in _soundEffectPlayers.ToList())
            {
                if (player == null || player.State == PlaybackState.Stopped)
                {
                    playersToRemove.Add(player);
                }
            }

            foreach (var player in playersToRemove)
            {
                _soundEffectPlayers.Remove(player);

                if (player != null)
                {
                    try
                    {
                        _masterMixer.RemoveComponent(player);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error removing sound effect player: {ex}");
                    }
                }
            }

            // Limit the number of tracked players to prevent excessive memory usage
            if (_soundEffectPlayers.Count > SOUND_EFFECT_CHANNELS * 2)
            {
                var oldestPlayers = _soundEffectPlayers.Take(_soundEffectPlayers.Count - SOUND_EFFECT_CHANNELS).ToList();
                foreach (var player in oldestPlayers)
                {
                    _soundEffectPlayers.Remove(player);
                    if (player != null)
                    {
                        try
                        {
                            player.Stop();
                            _masterMixer.RemoveComponent(player);
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Error stopping old sound effect player: {ex}");
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error during player cleanup: {ex}");
        }
    }

    #endregion

    #region DISPOSAL

    /// <summary>
    /// Cleans up all resources used by the audio service
    /// </summary>
    public void Dispose()
    {
        if (_disposed)
            return;

        try
        {
            Debug.WriteLine("Disposing SoundFlow audio service...");

            // Stop background music
            StopBackgroundMusic();

            // Stop and dispose all sound effect players
            foreach (var player in _soundEffectPlayers.ToList())
            {
                if (player != null)
                {
                    try
                    {
                        player.Stop();
                        _masterMixer.RemoveComponent(player);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error stopping sound effect player: {ex}");
                    }
                }
            }
            _soundEffectPlayers.Clear();

            // Clear sound data
            _soundData.Clear();

            // Clear memory stream pool
            lock (_poolLock)
            {
                while (_memoryStreamPool.Count > 0)
                {
                    var stream = _memoryStreamPool.Dequeue();
                    stream?.Dispose();
                }
            }

            // Dispose audio engine
            _audioEngine?.Dispose();

            Debug.WriteLine("SoundFlow audio service disposed successfully");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error disposing SoundFlow audio service: {ex}");
        }
        finally
        {
            _disposed = true;
        }
    }

    #endregion
}

#endif

--- C:\code\DrawnUi\src\Game\Sound\StreamingAudioSource.cs ---
using System.Diagnostics;

namespace Breakout.Game;

/// <summary>
/// Streaming IAudioSource for background music (large files, loaded on-demand)
/// </summary>
internal class StreamingAudioSource : IGameAudioSource
{
    private readonly string _filePath;
    private Stream _currentStream;

    public StreamingAudioSource(string filePath)
    {
        _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
    }

    public Stream GetAudioStream()
    {
        // Create a new stream each time for background music (file streaming)
        // This allows the AudioMixer to handle the music file without loading it all into memory
        try
        {
            return FileSystem.OpenAppPackageFileAsync(_filePath).Result;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error opening music file '{_filePath}': {ex}");
            return Stream.Null;
        }
    }

    public void Dispose()
    {
        _currentStream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\BallSprite.cs ---
using System.Numerics;
using SkiaSharp;

namespace Breakout.Game;

public class BallSprite : SkiaShape, IWithHitBox, IReusableSprite
{

    //BackgroundColor="#dddddd"
    public BallSprite()
    {
        UseCache = SkiaCacheType.GPU;
        HeightRequest = 15;
        HorizontalOptions = LayoutOptions.Center;
        VerticalOptions = LayoutOptions.End;
        Type = ShapeType.Circle;
        StrokeColor = Colors.White;
        StrokeWidth = 2;
        LockRatio = 1;
        BackgroundColor = Colors.Aqua;
        SpeedRatio = 1;
        IsActive = true;
        BevelType = BevelType.Bevel;
        Bevel = new SkiaBevel()
        {
            Depth = 4,
            LightColor = Colors.White,
            ShadowColor = Color.Parse("#333333"),
            Opacity = 0.33
        };
    }

    public static BallSprite Create()
    {
        return new();
    }

    public bool IsActive { get; set; }

    private bool _isFireball = false;
    public bool IsFireball
    {
        get => _isFireball;
        set
        {
            if (_isFireball != value)
            {
                _isFireball = value;
                UpdateFireballAppearance();
            }
        }
    }

    private void UpdateFireballAppearance()
    {
        if (_isFireball)
        {
            // Fireball appearance: red/orange with fiery glow
            BackgroundColor = Colors.Red;
            StrokeColor = Colors.Orange;
            StrokeWidth = 3;
        }
        else
        {
            // Normal ball appearance
            BackgroundColor = Colors.Aqua;
            StrokeColor = Colors.White;
            StrokeWidth = 2;
        }
    }

    public float Angle
    {
        get => _angle;
        set
        {
            _angle = ClampAngleFromHorizontal(value);
            TrackAngleForOscillation(_angle);
        }
    }


    public float SpeedRatio { get; set; }

    public bool IsMoving
    {
        get => _isMoving;
        set
        {
            if (value == _isMoving) return;
            _isMoving = value;
            OnPropertyChanged();
        }
    }

    public void ResetAnimationState()
    {
    }

    public async Task AnimateDisappearing()
    {
    }

    public void UpdateState(long time, bool force=false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    long _stateUpdated;
    public SKRect HitBox { get; set; }

    // New interpolation fields
    private float _lastMoveX;
    private float _lastMoveY;
    private float _interpolationFactor = 0.5f; // Smoothing factor
    private float _angle;
    private bool _isMoving;

    // Angle oscillation detection for unsticking
    private float _angleHistory1 = float.NaN;
    private float _angleHistory2 = float.NaN;
    private float _angleHistory3 = float.NaN;
    private int _oscillationCount = 0;

    /// <summary>
    /// Change the current position offset by the provided amount in points
    /// </summary>
    public void MoveOffset(double x, double y)
    {
        Left += x;
        Top += y;
        //Repaint();
    }

    /// <summary>
    /// Replaces the current position offset by the provided amount in points
    /// </summary>
    public void SetOffset(double x, double y)
    {
        Left = x;
        Top = y;
        //Repaint();
    }

    public void SetOffsetX(double x)
    {
        Left = x;
        //Repaint();
    }

    public void SetOffsetY(double y)
    {
        Top = y;
        //Repaint();
    }

    public void UpdatePosition(float deltaSeconds)
    {
        // Ensure delta is capped and positive
        if (deltaSeconds <= 0 || !IsMoving)
            return;

        // Calculate new movement
        float moveX = BreakoutGame.BALL_SPEED * SpeedRatio * MathF.Cos(Angle) * deltaSeconds;
        float moveY = BreakoutGame.BALL_SPEED * SpeedRatio * MathF.Sin(Angle) * deltaSeconds;

        //// Interpolate movement for smoother transition
        //moveX = float.Lerp(_lastMoveX, moveX, _interpolationFactor);
        //moveY = float.Lerp(_lastMoveY, moveY, _interpolationFactor);
        //_lastMoveX = moveX;
        //_lastMoveY = moveY;

        // Apply interpolated movement
        Left += moveX;
        Top += moveY;

        //Repaint();
    }

    /// <summary>
    /// Returns the current movement direction as a normalized vector
    /// </summary>
    public Vector2 Direction => new Vector2(MathF.Cos(Angle), MathF.Sin(Angle));

    /// <summary>
    /// Returns the ball's center position as a Vector2
    /// </summary>
    public Vector2 Position => new Vector2(HitBox.MidX, HitBox.MidY);

    /// <summary>
    /// Sets the ball's direction from a Vector2 (automatically normalizes)
    /// </summary>
    public void SetDirection(Vector2 direction)
    {
        if (direction == Vector2.Zero)
            return;

        Vector2 normalized = Vector2.Normalize(direction);
        Angle = MathF.Atan2(normalized.Y, normalized.X);
    }

    /// <summary>
    /// Clamps an angle (in radians) to ensure it is at least a minimum deviation
    /// away from the horizontal axes (0, +/- PI, +/- 2*PI, etc.).
    /// </summary>
    /// <param name="angle">The input angle in radians.</param>
    /// <param name="minAngleFromHorizontal">
    /// The minimum desired angle (in radians) between the output angle and the
    /// nearest horizontal axis. Must be positive and less than PI/2 (90 degrees).
    /// </param>
    /// <returns>
    /// The adjusted angle (in radians), guaranteed to be at least minAngleFromHorizontal
    /// away from any horizontal axis. The returned angle will be normalized to the range (-PI, PI].
    /// </returns>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown if minAngleFromHorizontal is not within the valid range (0, PI/2).
    /// </exception>
    public static float ClampAngleFromHorizontal(float angle, float minAngleFromHorizontal = MathF.PI / 10.0f)
    {
        // --- Input Validation ---
        if (minAngleFromHorizontal <= 0 || minAngleFromHorizontal >= MathF.PI / 2.0f)
        {
            throw new ArgumentOutOfRangeException(nameof(minAngleFromHorizontal),
                "Must be positive and less than PI/2 radians.");
        }

        // --- Normalize angle to the range (-PI, PI] for easier comparison ---
        // This simplifies checking against 0 and +/- PI
        float twoPi = 2.0f * MathF.PI;
        float normalizedAngle = angle % twoPi; // Bring angle within (-2*PI, 2*PI)

        // Adjust to (-PI, PI] range
        if (normalizedAngle <= -MathF.PI)
        {
            normalizedAngle += twoPi;
        }
        else if (normalizedAngle > MathF.PI)
        {
            normalizedAngle -= twoPi;
        }
        // Now normalizedAngle is guaranteed to be in the interval (-PI, PI]

        // --- Check if the angle is too close to horizontal ---
        bool tooCloseToZero = MathF.Abs(normalizedAngle) < minAngleFromHorizontal;
        bool tooCloseToPi = MathF.Abs(normalizedAngle) > (MathF.PI - minAngleFromHorizontal);

        if (tooCloseToZero || tooCloseToPi)
        {
            // --- Adjust the angle ---
            // Determine the sign to preserve the general direction (up/down)
            float sign = MathF.Sign(normalizedAngle);

            // Handle the edge case where normalizedAngle is exactly 0
            if (sign == 0)
            {
                // If the original angle was 0 or a multiple of 2*PI, it normalized to 0.
                // We need a consistent direction to nudge it. Let's default to positive (up/right quadrant).
                // You might adjust this based on game context if 0 needs special handling.
                sign = 1;
            }

            if (tooCloseToZero)
            {
                // If it was near 0, set it to the minimum angle away from 0
                return sign * minAngleFromHorizontal;
            }
            else // tooCloseToPi
            {
                // If it was near +/- PI, set it to the minimum angle away from +/- PI
                return sign * (MathF.PI - minAngleFromHorizontal);
            }
        }
        else
        {
            // Angle is not too horizontal, return the normalized version
            return normalizedAngle;
        }
    }

    /// <summary>
    /// Track angle changes to detect oscillation (ball stuck between surfaces)
    /// </summary>
    private void TrackAngleForOscillation(float newAngle)
    {
        // Only track if ball is moving
        if (!IsMoving)
        {
            ResetOscillationTracking();
            return;
        }

        // Shift history: 3 -> 2 -> 1 -> new
        _angleHistory3 = _angleHistory2;
        _angleHistory2 = _angleHistory1;
        _angleHistory1 = newAngle;

        // Check for oscillation pattern (need at least 3 angles)
        if (!float.IsNaN(_angleHistory3))
        {
            CheckForOscillation();
        }
    }

    /// <summary>
    /// Check if ball is stuck in angle oscillation pattern
    /// </summary>
    private void CheckForOscillation()
    {
        const float angleTolerance = 0.01f; // Small tolerance for floating point comparison

        // Check if we have a 2-angle oscillation pattern
        bool isOscillating =
            (MathF.Abs(_angleHistory1 - _angleHistory3) < angleTolerance) && // Current matches 2 steps ago
            (MathF.Abs(_angleHistory2 - _angleHistory1) > angleTolerance);   // But different from previous

        if (isOscillating)
        {
            _oscillationCount++;

            // If oscillating for 6+ frames, we're stuck!
            if (_oscillationCount >= 6)
            {
                UnstickBall();
            }
        }
        else
        {
            _oscillationCount = 0; // Reset counter if pattern breaks
        }
    }

    /// <summary>
    /// Unstick the ball by adding a small random angle adjustment
    /// </summary>
    private void UnstickBall()
    {
        // Add small random nudge to break oscillation
        var random = new Random();
        float nudge = (float)(random.NextDouble() - 0.5) * 0.4f; // ±0.2 radians (~±11 degrees)

        _angle = ClampAngleFromHorizontal(_angle + nudge);

        // Reset tracking
        ResetOscillationTracking();

        // Optional: Boost speed slightly to help escape
        SpeedRatio = Math.Max(SpeedRatio, 1.0f);
    }

    /// <summary>
    /// Reset oscillation tracking
    /// </summary>
    private void ResetOscillationTracking()
    {
        _angleHistory1 = float.NaN;
        _angleHistory2 = float.NaN;
        _angleHistory3 = float.NaN;
        _oscillationCount = 0;
    }

}

--- C:\code\DrawnUi\src\Game\Sprites\BrickSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class BrickSprite : SkiaShape, IWithHitBox, IReusableSprite
{
    public static BrickSprite Create()
    {
        return new BrickSprite
        {
            UseCache = SkiaCacheType.Operations,
            BackgroundColor = Colors.Red,
            CornerRadius = 6,
            WidthRequest = 50,
            HeightRequest = 24,
            StrokeColor = Colors.White,
            StrokeWidth = 2,
            BevelType = BevelType.Bevel,
            Bevel = new SkiaBevel()
            {
                Depth = 4,
                LightColor = Colors.White,
                ShadowColor = Color.Parse("#333333"),
                Opacity = 0.33
            },
            ZIndex = 4
        };
    }

    public bool HitBoxInvalidated { get; set; }
    public bool IsActive { get; set; }

    public void ResetAnimationState()
    {
        try
        {
            this.CancelDisappearing?.Cancel();
        }
        catch
        {
        }

        Opacity = 1;
        Scale = 1;
    }

    /// <summary>
    /// Cancellation token for sprite removal animations.
    /// </summary>
    public CancellationTokenSource CancelDisappearing { get; set; }

    public async Task AnimateDisappearing()
    {
        this.CancelDisappearing?.Cancel();
        using var cancel = new CancellationTokenSource();
        CancelDisappearing = cancel;
        await FadeToAsync(0, 200, Easing.SpringOut, cancel);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (_stateUpdated != time || force)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
            HitBoxInvalidated = false;
        }
    }

    private long _stateUpdated;

    /// <summary>
    /// In POINTS
    /// </summary>
    public SKRect HitBox { get; private set; }

    /// <summary>
    /// By default it's 0 means 1 hit required to destroy
    /// </summary>
    public int SupplementaryHitsToDestroy { get; set; }

    /// <summary>
    /// By default it's false
    /// </summary>
    public bool Undestructible { get; set; }

    public BrickPreset Preset { get; set; }
}

--- C:\code\DrawnUi\src\Game\Sprites\BulletSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class BulletSprite : StableCacheLayout, IWithHitBox, IReusableSprite
{
    public static float Speed = 500f;

    public static BulletSprite Create()
    {
        return new BulletSprite
        {
            Tag = "Bullet",
            WidthRequest = BreakoutGame.PADDLE_WIDTH,
            UseCache = SkiaCacheType.Operations,
            SpeedRatio = 1,
            ZIndex = 2,
            HeightRequest = 16,
            //same as player
            HorizontalOptions = LayoutOptions.Center,
            VerticalOptions = LayoutOptions.End,
            Children =
            {
                CreateLazer(),
                CreateLazer().EndX(),
            }
        };
    }

    static SkiaShape CreateLazer()
    {
        return new SkiaShape()
        {
            WidthRequest = 5,
            CornerRadius = 2,
            BackgroundColor = Color.Parse("#ffff4444"),
            StrokeColor = Color.Parse("#ffff0000"),
            StrokeWidth = 1,
            VerticalOptions = LayoutOptions.Fill,
        };
    }

    public bool IsActive { get; set; }
    public float SpeedRatio { get; set; }

    public void ResetAnimationState()
    {
        Opacity = 1;
        Scale = 1;
    }

    public async Task AnimateDisappearing()
    {
        await FadeToAsync(0, 100);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    private long _stateUpdated;
    public SKRect HitBox { get; private set; }
}

--- C:\code\DrawnUi\src\Game\Sprites\LifeSprite.cs ---
using Breakout.Game.Input;

namespace Breakout.Game;

public class LifeSprite : SkiaShape
{
    public LifeSprite()
    {
        Margin = new Thickness(1,1,3,3);
        WidthRequest = 26;
        HeightRequest = 7.5;
        StrokeColor = Color.Parse("#CCCCFF");
        StrokeWidth = -1;
        CornerRadius = 4;
        BackgroundColor = Colors.DarkOrange;
        Children = new List<SkiaControl>()
        {
            new SkiaShape()
            {
                CornerRadius = 2,
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = AmstradColors.BrightGreen,
                Margin = new(5, 1.5),
                BevelType = BevelType.Emboss,
                Bevel = new SkiaBevel()
                {
                    Depth = 2,
                    LightColor = Colors.White,
                    ShadowColor = Color.Parse("#333333"),
                    Opacity = 0.33,
                }
            }
        };
        //Shadows = new List<SkiaShadow>()
        //{
        //    new SkiaShadow()
        //    {
        //        X = 2, Y = 2, Color = Colors.DarkBlue, Blur = 0
        //    }
        //} ;
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\PaddleSprite.cs ---
using Breakout.Game.Input;
using SkiaSharp;

namespace Breakout.Game;

public class PaddleSprite : SkiaShape, IWithHitBox //, IReusableSprite
{
    public static float Speed = BreakoutGame.PADDLE_SPEED;

    Color ColorA = Colors.DarkOrange;
    private Color ColorB = AmstradColors.BrightGreen;

    public PaddleSprite()
    {
        UseCache = SkiaCacheType.GPU;
        HeightRequest = 16;
        CornerRadius = 8;
        BackgroundColor = ColorA;
        HorizontalOptions = LayoutOptions.Center;
        VerticalOptions = LayoutOptions.End;
        Type = ShapeType.Rectangle;
        StrokeColor = Color.Parse("#CCCCFF");
        StrokeWidth = 2;
        SpeedRatio = 1;
        IsActive = true;
        BevelType = BevelType.Bevel;
        Bevel = new SkiaBevel()
        {
            Depth = 4,
            LightColor = Colors.White,
            ShadowColor = Color.Parse("#333333"),
            Opacity = 0.33,
        };
        Children = new List<SkiaControl>()
            {
                new SkiaShape()
                {
                    CornerRadius = 2,
                    HorizontalOptions = LayoutOptions.Fill,
                    VerticalOptions = LayoutOptions.Fill,
                    BackgroundColor = ColorB,
                    Margin = new(14, 3),
                    BevelType = BevelType.Emboss,
                    Bevel = new SkiaBevel()
                    {
                        Depth = 2,
                        LightColor = Colors.White,
                        ShadowColor = Color.Parse("#333333"),
                        Opacity = 0.33,
                    }
                }
            }
            ;

        ApplyPowerup(PowerupType.None);

        //Powerup = PowerupType.StickyBall;
    }

    public float Angle { get; set; }

    private PowerupType _powerup;

    public PowerupType Powerup
    {
        get { return _powerup; }
        set
        {
            if (value != _powerup)
            {
                _powerup = value;
                ApplyPowerup(value);
            }
        }
    }

    public float PowerupDuration { get; set; }

    /// <summary>
    /// Update look upon powerups
    /// </summary>
    protected void ApplyPowerup(PowerupType powerup)
    {
        //DURATION
        if (powerup == PowerupType.None)
        {
            PowerupDuration = 0;
        }
        else
        {
            PowerupDuration = BreakoutGame.POWERUP_DURATION;
        }

        // Remove incorrect speed logic - ball speed should be handled in BreakoutGame
        // SpeedRatio should remain 1 for paddle

        //SIZE
        if (Powerup == PowerupType.ExpandPaddle)
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH * 1.33;
        }
        else
        if (Powerup == PowerupType.ShrinkPaddle)
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH / 1.33;
        }
        else
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH;
        }

        //COLORS
        if (Powerup == PowerupType.Destroyer)
        {
            BackgroundColor = AmstradColors.Red;
        }
        else
        if (Powerup == PowerupType.StickyBall)
        {
            BackgroundColor = Colors.DarkCyan;
        }
        else
        {
            BackgroundColor = ColorA;
        }
    }

    public bool IsActive { get; set; }

    public static PaddleSprite Create()
    {
        return new();
    }

    public void ResetAnimationState()
    {
    }

    public async Task AnimateDisappearing()
    {
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    long _stateUpdated;
    public SKRect HitBox { get; set; }
    public float SpeedRatio { get; set; }

    public void UpdatePosition(float deltaTime)
    {
        // we are not updating it here, but in the game loop
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\PowerupSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class PowerUpSprite : SkiaShape, IWithHitBox, IReusableSprite
{
    public static float FallSpeed = BreakoutGame.POWERUP_SPEED;

    private SkiaLabel _letterLabel;

    public static PowerUpSprite Create()
    {
        var powerup = new PowerUpSprite();
        powerup.Initialize();
        return powerup;
    }

    private void Initialize()
    {
        UseCache = SkiaCacheType.Operations;
        WidthRequest = 34;
        HeightRequest = 18;
        CornerRadius = 4;
        BackgroundColor = Colors.Purple;
        StrokeColor = Colors.White;
        StrokeWidth = 2;
        SpeedRatio = 1;
        IsActive = false;
        ZIndex = 3;

        _letterLabel = new SkiaLabel
        {
            Text = "?",
            UseCache = SkiaCacheType.Operations,
            FontSize = 10,
            TextColor = Colors.White,
            FontFamily = "FontSystem",
            HorizontalOptions = LayoutOptions.Center,
            VerticalOptions = LayoutOptions.Center
        };

        Children = new List<SkiaControl> { _letterLabel };
    }

    public PowerupType Type { get; set; }
    public bool IsActive { get; set; }
    public float SpeedRatio { get; set; }

    public void SetPowerupType(PowerupType type)
    {
        Type = type;

        // Set letter and color based on type
        switch (type)
        {
            case PowerupType.Destroyer:
                _letterLabel.Text = "A";
                BackgroundColor = Colors.Red;
                _letterLabel.TextColor = WhiteColor;
                break;
            case PowerupType.ExpandPaddle:
                _letterLabel.Text = "E";
                BackgroundColor = Colors.BlueViolet;
                _letterLabel.TextColor = WhiteColor;
                break;
            case PowerupType.StickyBall:
                _letterLabel.Text = "C";
                BackgroundColor = Colors.Cyan;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.ShrinkPaddle:
                _letterLabel.Text = "R";
                BackgroundColor = Colors.Yellow;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.SlowBall:
                _letterLabel.Text = "S";
                BackgroundColor = Colors.White;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.FastBall:
                _letterLabel.Text = "F";
                BackgroundColor = Colors.CornflowerBlue;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.MultiBall:
                _letterLabel.Text = "M";
                BackgroundColor = Colors.DarkGreen;
                _letterLabel.TextColor = Colors.White;
                break;
            case PowerupType.ExtraLife:
                _letterLabel.Text = "L";
                BackgroundColor = Colors.GreenYellow;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.Fireball:
                _letterLabel.Text = "B";
                BackgroundColor = Colors.Crimson;
                _letterLabel.TextColor = WhiteColor;
                break;

            default:
                _letterLabel.Text = "?";
                BackgroundColor = Colors.White;
                _letterLabel.TextColor = BlackColor;
                break;
        }

        StrokeColor = BackgroundColor.MakeLighter(50f);
    }

    public void UpdateRotation(float deltaTime)
    {
        // Rotate the letter for visual effect
        if (_letterLabel != null)
        {
            LetterRotation += 180 * deltaTime; // Rotate 180 degrees per second
            if (LetterRotation > 360)
                LetterRotation -= 360;
        }
    }

    double LetterRotation
    {
        get { return _letterLabel.RotationX; }
        set { _letterLabel.RotationX = value; }
    }

    public void ResetAnimationState()
    {
        Opacity = 1;
        Scale = 1;
        if (_letterLabel != null)
            LetterRotation = 0;
    }

    public async Task AnimateDisappearing()
    {
        await FadeToAsync(0, 150);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    private long _stateUpdated;
    public SKRect HitBox { get; private set; }
}

--- C:\code\DrawnUi\src\Helpers\AppFonts.cs ---
namespace Breakout.Resources.Fonts;

public static class AppFonts
{
    /// <summary>
    /// Dialogs, default text
    /// </summary>
    public const string Default = "FontText";

    /// <summary>
    /// Score, buttons, game-style
    /// </summary>
    public const string Game = "FontGame";
    public const string GameKo = "FontGameKo";
    public const string GameZh = "FontGameZh";

    public static string GameAutoselect
    {
        get
        {
            if (!string.IsNullOrEmpty(_useGameFont))
            {
                return _useGameFont;
            }
            return Game;
        }
    }

    public static double GameAdjustSize
    {
        get
        {
            if (_adjustGameFont<=0)
            {
                return 1;
            }
            return _adjustGameFont;
        }
    }

    private static double _adjustGameFont;
    private static string _useGameFont;
    public static void UseGameFont(string value, double scale = 1.0)
    {
        _useGameFont = value;
        _adjustGameFont=scale;
    }

    public static MauiAppBuilder AddAppFonts(this MauiAppBuilder builder)
    {

        builder.ConfigureFonts(fonts =>
        {
            fonts.AddFont("ZenMaruGothic-Bold.ttf", AppFonts.Default); //dialogs
            fonts.AddFont("DelaGothicOne-Regular.ttf", AppFonts.Game); //score, buttons
            fonts.AddFont("BlackHanSans-Regular.ttf", AppFonts.GameKo); 
            fonts.AddFont("MaShanZheng-Regular.ttf", AppFonts.GameZh); 
            fonts.AddFont("amstrad_cpc464.ttf", "FontSystem");
        });

        return builder;
    }

}

--- C:\code\DrawnUi\src\Helpers\AppLanguage.cs ---
using AppoMobi.Specials;
using Breakout.Helpers;
using System.Globalization;

namespace Breakout.Resources.Fonts;

public static class AppLanguage
{
    /// <summary>
    /// Enabled languages
    /// </summary>
    public static List<string> EnabledLanguages = new List<string>
    {
        "en", //FIRST is fallback
        "de",
        "es",
        "fr",
        "it",
        "ru",
        "ja",
        "ko",
        "zh",
    };

    /// <summary>
    /// Applies the selected language or detects device language on first start
    /// </summary>
    public static void ApplySelected()
    {
        if (Preferences.Get("FirstStart", true) ||
            AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault) == string.Empty)
        {
            // detect the device language
            var deviceLanguage = CultureInfo.CurrentUICulture.TwoLetterISOLanguageName;

            if (!EnabledLanguages.Contains(deviceLanguage))
            {
                var fallback = EnabledLanguages.First();
                Set(fallback);
            }
            else
            {
                Set(deviceLanguage);
            }

            Preferences.Set("FirstStart", false);
        }
        else
        {
            var lang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
            Set(lang);
        }
    }

    public static void Set(string lang)
    {
        ResStrings.Culture = CultureInfo.CreateSpecificCulture(lang);
        Thread.CurrentThread.CurrentCulture = ResStrings.Culture;
        Thread.CurrentThread.CurrentUICulture = ResStrings.Culture;

        AppSettings.Set(AppSettings.Lang, lang);

        switch (lang)
        {
            case "zh":
                AppFonts.UseGameFont(AppFonts.GameZh, 1.1);
                break;
            case "ko":
                AppFonts.UseGameFont(AppFonts.GameKo, 1.1);
                break;
            default:
                AppFonts.UseGameFont(AppFonts.Game);
                break;
        }
    }

    public static void RestartWith(string lang)
    {
        Set(lang);

        MainThread.BeginInvokeOnMainThread(() => { App.Current.MainPage = new NavigationPage(new MainPage()); });
    }

    static List<KeyValuePair<string, string>> DisplayLanguages;

    public static void SetAndApply(string lang)
    {
        Set(lang);

        Super.OnFrame +=
            OnFrame; //will change language on rendering thread if different from main
    }

    private static void OnFrame(object o, EventArgs a)
    {
        Super.OnFrame -= OnFrame;
        Thread.CurrentThread.CurrentUICulture = ResStrings.Culture;

        //soft refresh
        BreakoutGame.Instance.RedrawFromOptions();

        //mimic HotReload
        //MainPage.Instance.Build(); // reload game completely as if HotReload hit
    }

    /// <summary>
    /// Cycles to the next enabled language and applies it
    /// </summary>
    public static void SelectNextAndSet()
    {
        var currentLang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
        var currentIndex = EnabledLanguages.IndexOf(currentLang);

        var nextIndex = (currentIndex + 1) % EnabledLanguages.Count;
        var nextLang = EnabledLanguages[nextIndex];

        SetAndApply(nextLang);
    }

    public static void SelectAndSet()
    {
        var languages = EnabledLanguages;
        if (languages.Count() > 2)
        {
            if (DisplayLanguages == null)
            {
                DisplayLanguages = new();
                foreach (var lang in languages)
                {
                    var culture = CultureInfo.CreateSpecificCulture(lang);
                    var title = culture.NativeName.ToTitleCase().ToTitleCase("(");
                    DisplayLanguages.Add(new(lang, title));
                }
            }

            MainThread.BeginInvokeOnMainThread(async () =>
            {
                var options = DisplayLanguages.Select(c => c.Value).ToArray();
                
                //block game input from keys
                BreakoutGame.Instance.Pause();

                var result =
                    await App.Current.MainPage.DisplayActionSheet(ResStrings.Language, ResStrings.BtnCancel, null,
                        options);

                BreakoutGame.Instance.Resume();

                if (!string.IsNullOrEmpty(result))
                {
                    var selectedIndex = options.FindIndex(result);
                    if (selectedIndex >= 0)
                    {
                        var lang = languages[selectedIndex];
                        if (lang != AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault))
                        {
                            SetAndApply(lang);
                        }
                    }
                }
            });

        }
    }
}

--- C:\code\DrawnUi\src\Helpers\AppSettings.cs ---
namespace Breakout.Helpers;

public static class AppSettings
{
    public static readonly string Lang = "lang";
    public static readonly string LangDefault = string.Empty;

    public static readonly string MusicOn = "mus";
    public static readonly bool MusicOnDefault = true;

    public static readonly string SoundsOn = "fx";
    public static readonly bool SoundsOnDefault = true;

    public static readonly string InputPressEnabled = "press";
    public static readonly bool InputPressEnabledDefault = false;

    public static T Get<T>(string key, T defaultValue)
    {
        return Preferences.Default.Get(key, defaultValue);
    }

    public static void Set<T>(string key, T value)
    {
        Preferences.Default.Set(key, value);
    }
}

--- C:\code\DrawnUi\src\Helpers\HotPreview.cs ---
using Breakout.Game;
using DrawnUi.Views;

#if PREVIEWS

namespace Breakout.Helpers
{
    using Microsoft.Maui.ApplicationModel;
    using HotPreview;
    using HotPreview.App.Maui;
    using HotPreview.SharedModel;
    using HotPreview.SharedModel.App;
    using System;
    using System.Threading.Tasks;

    /// <summary>
    /// Customizable MauiPreviewNavigatorService
    /// </summary>
    public class PreviewService : MauiPreviewNavigatorService
    {
        /// <summary>
        /// One-line for initialization
        /// </summary>
        public static void Initialize()
        {
            MauiPreviewApplication.Instance.PreviewNavigatorService = new PreviewService();
        }

        /// <summary>
        /// Can be customized
        /// </summary>
        public static Func<INavigation> NavigateFrom = () => { return Application.Current!.MainPage!.Navigation; };

        public override Task NavigateToPreviewAsync(UIComponentReflection uiComponent, PreviewReflection preview)
        {
            return MainThread.InvokeOnMainThreadAsync(async () =>
            {
                object previewUI = preview.Create();

                if (uiComponent.Kind == UIComponentKind.Control)
                {
                    ContentPage controlsPage = new ContentPage
                    {
                        Content = (View)previewUI
                    };

                    await NavigateFrom().PushAsync(controlsPage, NavigateAnimationsEnabled);
                }
                else
                {
                    if (previewUI is RoutePreview routePreview)
                    {
                        Window mainWindow = Application.Current!.Windows[0];
                        Shell shell = mainWindow?.Page as Shell;


                        if (shell is null)
                        {
                            throw new InvalidOperationException("Main window doesn't use Shell");
                        }

                        await shell.GoToAsync(routePreview.Route, NavigateAnimationsEnabled);
                    }
                    else if (previewUI is ContentPage contentPage)
                    {
                        await NavigateFrom().PushAsync(contentPage, NavigateAnimationsEnabled);
                    }
                }
            });
        }
    }
}

#endif

--- C:\code\DrawnUi\src\Platforms\Android\MainActivity.cs ---
using Android.App;
using Android.Content.PM;
using Android.OS;

namespace Breakout;

[Activity(Theme = "@style/MainTheme", MainLauncher = true, 
    LaunchMode = LaunchMode.SingleTop, 
    ConfigurationChanges = ConfigChanges.ScreenSize | 
                           ConfigChanges.Orientation
                           | ConfigChanges.UiMode | ConfigChanges.ScreenLayout | 
                           ConfigChanges.SmallestScreenSize | ConfigChanges.Density, 
    ScreenOrientation = ScreenOrientation.SensorPortrait)]

public class MainActivity : MauiAppCompatActivity
{
}

--- C:\code\DrawnUi\src\Platforms\Android\MainApplication.cs ---
using Android.App;
using Android.Runtime;

namespace Breakout;

[Application]
public class MainApplication : MauiApplication
{
	public MainApplication(IntPtr handle, JniHandleOwnership ownership)
		: base(handle, ownership)
	{
	}

	protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\iOS\AppDelegate.cs ---
using Foundation;

namespace Breakout;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
	protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\iOS\Program.cs ---
using ObjCRuntime;
using UIKit;

namespace Breakout;

public class Program
{
	// This is the main entry point of the application.
	static void Main(string[] args)
	{
		// if you want to use a different Application Delegate class from "AppDelegate"
		// you can specify it here.
		UIApplication.Main(args, null, typeof(AppDelegate));
	}
}

--- C:\code\DrawnUi\src\Platforms\MacCatalyst\AppDelegate.cs ---
using Foundation;

namespace Breakout;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
	protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\MacCatalyst\Program.cs ---
using ObjCRuntime;
using UIKit;

namespace Breakout;

public class Program
{
	// This is the main entry point of the application.
	static void Main(string[] args)
	{
		// if you want to use a different Application Delegate class from "AppDelegate"
		// you can specify it here.
		UIApplication.Main(args, null, typeof(AppDelegate));
	}
}

--- C:\code\DrawnUi\src\Platforms\Tizen\Main.cs ---
using System;
using Microsoft.Maui;
using Microsoft.Maui.Hosting;

namespace Breakout;

class Program : MauiApplication
{
	protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();

	static void Main(string[] args)
	{
		var app = new Program();
		app.Run(args);
	}
}

--- C:\code\DrawnUi\src\Platforms\Windows\App.xaml.cs ---
using Microsoft.UI.Xaml;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace Breakout.WinUI;

/// <summary>
/// Provides application-specific behavior to supplement the default Application class.
/// </summary>
public partial class App : MauiWinUIApplication
{
	/// <summary>
	/// Initializes the singleton application object.  This is the first line of authored code
	/// executed, and as such is the logical equivalent of main() or WinMain().
	/// </summary>
	public App()
	{
		this.InitializeComponent();
	}

	protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}


--- C:\code\DrawnUi\src\Resources\Strings\ResStrings.Designer.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Breakout.Resources.Strings {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class ResStrings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ResStrings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Breakout.Resources.Strings.ResStrings", typeof(ResStrings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to About.
        /// </summary>
        public static string AboutApp {
            get {
                return ResourceManager.GetString("AboutApp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add.
        /// </summary>
        public static string Add {
            get {
                return ResourceManager.GetString("Add", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Address.
        /// </summary>
        public static string Address {
            get {
                return ResourceManager.GetString("Address", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All.
        /// </summary>
        public static string All {
            get {
                return ResourceManager.GetString("All", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Amount.
        /// </summary>
        public static string Amount {
            get {
                return ResourceManager.GetString("Amount", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Are You sure?.
        /// </summary>
        public static string AreYouSure {
            get {
                return ResourceManager.GetString("AreYouSure", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forgot password?.
        /// </summary>
        public static string AuthForgotPasswordQuestion {
            get {
                return ResourceManager.GetString("AuthForgotPasswordQuestion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Login.
        /// </summary>
        public static string AuthLogin {
            get {
                return ResourceManager.GetString("AuthLogin", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remember me.
        /// </summary>
        public static string AuthRememberMe {
            get {
                return ResourceManager.GetString("AuthRememberMe", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Balance.
        /// </summary>
        public static string Balance {
            get {
                return ResourceManager.GetString("Balance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Birthday.
        /// </summary>
        public static string Birthday {
            get {
                return ResourceManager.GetString("Birthday", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Apply.
        /// </summary>
        public static string BtnApply {
            get {
                return ResourceManager.GetString("BtnApply", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cancel.
        /// </summary>
        public static string BtnCancel {
            get {
                return ResourceManager.GetString("BtnCancel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Close.
        /// </summary>
        public static string BtnClose {
            get {
                return ResourceManager.GetString("BtnClose", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Connect.
        /// </summary>
        public static string BtnConnect {
            get {
                return ResourceManager.GetString("BtnConnect", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Continue.
        /// </summary>
        public static string BtnContinue {
            get {
                return ResourceManager.GetString("BtnContinue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Create.
        /// </summary>
        public static string BtnCreate {
            get {
                return ResourceManager.GetString("BtnCreate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disconnect.
        /// </summary>
        public static string BtnDisconnect {
            get {
                return ResourceManager.GetString("BtnDisconnect", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Go Back.
        /// </summary>
        public static string BtnGoBack {
            get {
                return ResourceManager.GetString("BtnGoBack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to OK.
        /// </summary>
        public static string BtnOk {
            get {
                return ResourceManager.GetString("BtnOk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Play Again.
        /// </summary>
        public static string BtnPlayAgain {
            get {
                return ResourceManager.GetString("BtnPlayAgain", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask A Question.
        /// </summary>
        public static string BtnQuestion {
            get {
                return ResourceManager.GetString("BtnQuestion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Quit.
        /// </summary>
        public static string BtnQuit {
            get {
                return ResourceManager.GetString("BtnQuit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reset.
        /// </summary>
        public static string BtnReset {
            get {
                return ResourceManager.GetString("BtnReset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Save.
        /// </summary>
        public static string BtnSave {
            get {
                return ResourceManager.GetString("BtnSave", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Share.
        /// </summary>
        public static string BtnShare {
            get {
                return ResourceManager.GetString("BtnShare", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start.
        /// </summary>
        public static string BtnStart {
            get {
                return ResourceManager.GetString("BtnStart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stop.
        /// </summary>
        public static string BtnStop {
            get {
                return ResourceManager.GetString("BtnStop", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Camera.
        /// </summary>
        public static string Camera {
            get {
                return ResourceManager.GetString("Camera", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cameras.
        /// </summary>
        public static string Cameras {
            get {
                return ResourceManager.GetString("Cameras", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change Balance.
        /// </summary>
        public static string ChangeBalance {
            get {
                return ResourceManager.GetString("ChangeBalance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Please confirm this action!.
        /// </summary>
        public static string ConfirmAction {
            get {
                return ResourceManager.GetString("ConfirmAction", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Confirmation Needed.
        /// </summary>
        public static string ConfirmationNeeded {
            get {
                return ResourceManager.GetString("ConfirmationNeeded", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Are you sure you want to delete this entry?.
        /// </summary>
        public static string ConfirmDelete {
            get {
                return ResourceManager.GetString("ConfirmDelete", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dashboard.
        /// </summary>
        public static string Dashboard {
            get {
                return ResourceManager.GetString("Dashboard", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Date.
        /// </summary>
        public static string Date {
            get {
                return ResourceManager.GetString("Date", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Days.
        /// </summary>
        public static string Days {
            get {
                return ResourceManager.GetString("Days", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delete.
        /// </summary>
        public static string Delete {
            get {
                return ResourceManager.GetString("Delete", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delete.
        /// </summary>
        public static string Deleting {
            get {
                return ResourceManager.GetString("Deleting", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Demo.
        /// </summary>
        public static string DemoMode {
            get {
                return ResourceManager.GetString("DemoMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Description.
        /// </summary>
        public static string Description {
            get {
                return ResourceManager.GetString("Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Difficulty.
        /// </summary>
        public static string Difficulty {
            get {
                return ResourceManager.GetString("Difficulty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit.
        /// </summary>
        public static string Edit {
            get {
                return ResourceManager.GetString("Edit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edited.
        /// </summary>
        public static string Edited {
            get {
                return ResourceManager.GetString("Edited", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Edit List.
        /// </summary>
        public static string EditList {
            get {
                return ResourceManager.GetString("EditList", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to E-mail.
        /// </summary>
        public static string Email {
            get {
                return ResourceManager.GetString("Email", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to End.
        /// </summary>
        public static string End {
            get {
                return ResourceManager.GetString("End", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Error.
        /// </summary>
        public static string Error {
            get {
                return ResourceManager.GetString("Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Europe.
        /// </summary>
        public static string Europe {
            get {
                return ResourceManager.GetString("Europe", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event.
        /// </summary>
        public static string Event {
            get {
                return ResourceManager.GetString("Event", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Events.
        /// </summary>
        public static string Events {
            get {
                return ResourceManager.GetString("Events", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter.
        /// </summary>
        public static string Filter {
            get {
                return ResourceManager.GetString("Filter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filtered.
        /// </summary>
        public static string Filtered {
            get {
                return ResourceManager.GetString("Filtered", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to First Name.
        /// </summary>
        public static string FirstName {
            get {
                return ResourceManager.GetString("FirstName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Full Name.
        /// </summary>
        public static string FullName {
            get {
                return ResourceManager.GetString("FullName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Group.
        /// </summary>
        public static string Group {
            get {
                return ResourceManager.GetString("Group", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Group.
        /// </summary>
        public static string Groups {
            get {
                return ResourceManager.GetString("Groups", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to History.
        /// </summary>
        public static string History {
            get {
                return ResourceManager.GetString("History", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Home.
        /// </summary>
        public static string Home {
            get {
                return ResourceManager.GetString("Home", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to  h.
        /// </summary>
        public static string HoursShort {
            get {
                return ResourceManager.GetString("HoursShort", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Info.
        /// </summary>
        public static string Info {
            get {
                return ResourceManager.GetString("Info", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interaction.
        /// </summary>
        public static string Interaction {
            get {
                return ResourceManager.GetString("Interaction", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language.
        /// </summary>
        public static string Language {
            get {
                return ResourceManager.GetString("Language", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last Name.
        /// </summary>
        public static string LastName {
            get {
                return ResourceManager.GetString("LastName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Leads.
        /// </summary>
        public static string Leads {
            get {
                return ResourceManager.GetString("Leads", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lvl.
        /// </summary>
        public static string Lev {
            get {
                return ResourceManager.GetString("Lev", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Level.
        /// </summary>
        public static string Level {
            get {
                return ResourceManager.GetString("Level", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lives.
        /// </summary>
        public static string Lives {
            get {
                return ResourceManager.GetString("Lives", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Log Out.
        /// </summary>
        public static string LogOut {
            get {
                return ResourceManager.GetString("LogOut", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Manager.
        /// </summary>
        public static string Manager {
            get {
                return ResourceManager.GetString("Manager", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Managers.
        /// </summary>
        public static string Managers {
            get {
                return ResourceManager.GetString("Managers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 🎉 Amazing! You&apos;ve conquered all levels! 🎉
        ///Final Score: {0}
        ///You&apos;re a Breakout Master!.
        /// </summary>
        public static string MessageGameComplete {
            get {
                return ResourceManager.GetString("MessageGameComplete", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 😔 Game Over! 💔
        ///Final Score: {0}
        ///Ready for another round?.
        /// </summary>
        public static string MessageGameOver {
            get {
                return ResourceManager.GetString("MessageGameOver", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 🎯 Level {0} Complete! 🎉
        ///Score: {1}
        ///Get ready for Level {2}!.
        /// </summary>
        public static string MessageLevelComplete {
            get {
                return ResourceManager.GetString("MessageLevelComplete", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 💥 Welcome to Bricks Breaker! 🏓
        ///🏆 Smash all bricks, victory awaits!.
        /// </summary>
        public static string MessageWelcome {
            get {
                return ResourceManager.GetString("MessageWelcome", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 💥 Welcome to Bricks Breaker! 🏓
        ///Use mouse/keyboard to control. 
        ///🏆 Smash all bricks, victory awaits!.
        /// </summary>
        public static string MessageWelcomeDesktop {
            get {
                return ResourceManager.GetString("MessageWelcomeDesktop", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Messenger.
        /// </summary>
        public static string Messenger {
            get {
                return ResourceManager.GetString("Messenger", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Middle Name.
        /// </summary>
        public static string MiddleName {
            get {
                return ResourceManager.GetString("MiddleName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Music.
        /// </summary>
        public static string Music {
            get {
                return ResourceManager.GetString("Music", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to My Profile.
        /// </summary>
        public static string MyProfile {
            get {
                return ResourceManager.GetString("MyProfile", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Name.
        /// </summary>
        public static string Name {
            get {
                return ResourceManager.GetString("Name", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to New Game.
        /// </summary>
        public static string NewGame {
            get {
                return ResourceManager.GetString("NewGame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No.
        /// </summary>
        public static string No {
            get {
                return ResourceManager.GetString("No", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to None.
        /// </summary>
        public static string None {
            get {
                return ResourceManager.GetString("None", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unallowed.
        /// </summary>
        public static string NoRights {
            get {
                return ResourceManager.GetString("NoRights", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Notes.
        /// </summary>
        public static string Notes {
            get {
                return ResourceManager.GetString("Notes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Off.
        /// </summary>
        public static string Off {
            get {
                return ResourceManager.GetString("Off", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Office.
        /// </summary>
        public static string Office {
            get {
                return ResourceManager.GetString("Office", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Offices.
        /// </summary>
        public static string Offices {
            get {
                return ResourceManager.GetString("Offices", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On.
        /// </summary>
        public static string On {
            get {
                return ResourceManager.GetString("On", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Options.
        /// </summary>
        public static string Options {
            get {
                return ResourceManager.GetString("Options", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Order.
        /// </summary>
        public static string Order {
            get {
                return ResourceManager.GetString("Order", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Order.
        /// </summary>
        public static string OrderBy {
            get {
                return ResourceManager.GetString("OrderBy", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Newer first.
        /// </summary>
        public static string OrderNewFirst {
            get {
                return ResourceManager.GetString("OrderNewFirst", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Older first.
        /// </summary>
        public static string OrderOldFirst {
            get {
                return ResourceManager.GetString("OrderOldFirst", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Orders.
        /// </summary>
        public static string Orders {
            get {
                return ResourceManager.GetString("Orders", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delivered to client.
        /// </summary>
        public static string OrderStatus_Issued {
            get {
                return ResourceManager.GetString("OrderStatus_Issued", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Processing.
        /// </summary>
        public static string OrderStatus_Received {
            get {
                return ResourceManager.GetString("OrderStatus_Received", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sent to office.
        /// </summary>
        public static string OrderStatus_Sent {
            get {
                return ResourceManager.GetString("OrderStatus_Sent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Password.
        /// </summary>
        public static string Password {
            get {
                return ResourceManager.GetString("Password", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Past Due.
        /// </summary>
        public static string PastDue {
            get {
                return ResourceManager.GetString("PastDue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Phone.
        /// </summary>
        public static string PhoneNumber {
            get {
                return ResourceManager.GetString("PhoneNumber", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Press Back once again to exit...
        /// </summary>
        public static string PressBACKOnceAgain {
            get {
                return ResourceManager.GetString("PressBACKOnceAgain", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Press HUD.
        /// </summary>
        public static string PressHud {
            get {
                return ResourceManager.GetString("PressHud", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Press Mode.
        /// </summary>
        public static string PressMode {
            get {
                return ResourceManager.GetString("PressMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price.
        /// </summary>
        public static string Price {
            get {
                return ResourceManager.GetString("Price", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Product.
        /// </summary>
        public static string Product {
            get {
                return ResourceManager.GetString("Product", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Products.
        /// </summary>
        public static string Products {
            get {
                return ResourceManager.GetString("Products", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Push.
        /// </summary>
        public static string Push {
            get {
                return ResourceManager.GetString("Push", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pushes.
        /// </summary>
        public static string Pushes {
            get {
                return ResourceManager.GetString("Pushes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Quantity.
        /// </summary>
        public static string Quantity {
            get {
                return ResourceManager.GetString("Quantity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Region.
        /// </summary>
        public static string Region {
            get {
                return ResourceManager.GetString("Region", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Regions.
        /// </summary>
        public static string Regions {
            get {
                return ResourceManager.GetString("Regions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove.
        /// </summary>
        public static string Remove {
            get {
                return ResourceManager.GetString("Remove", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Request.
        /// </summary>
        public static string Request {
            get {
                return ResourceManager.GetString("Request", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Requests.
        /// </summary>
        public static string Requests {
            get {
                return ResourceManager.GetString("Requests", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reset Password.
        /// </summary>
        public static string ResetPassword {
            get {
                return ResourceManager.GetString("ResetPassword", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rows per page.
        /// </summary>
        public static string RowsPerPage {
            get {
                return ResourceManager.GetString("RowsPerPage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Score.
        /// </summary>
        public static string Score {
            get {
                return ResourceManager.GetString("Score", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search.
        /// </summary>
        public static string Search {
            get {
                return ResourceManager.GetString("Search", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Select.
        /// </summary>
        public static string Select {
            get {
                return ResourceManager.GetString("Select", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shop.
        /// </summary>
        public static string Shop {
            get {
                return ResourceManager.GetString("Shop", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sounds.
        /// </summary>
        public static string Sounds {
            get {
                return ResourceManager.GetString("Sounds", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start.
        /// </summary>
        public static string Start {
            get {
                return ResourceManager.GetString("Start", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start Game.
        /// </summary>
        public static string StartGame {
            get {
                return ResourceManager.GetString("StartGame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Paused.
        /// </summary>
        public static string StatePaused {
            get {
                return ResourceManager.GetString("StatePaused", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Status.
        /// </summary>
        public static string Status {
            get {
                return ResourceManager.GetString("Status", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Other.
        /// </summary>
        public static string StudyPlanType_Other {
            get {
                return ResourceManager.GetString("StudyPlanType_Other", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Success!.
        /// </summary>
        public static string Success {
            get {
                return ResourceManager.GetString("Success", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to System Settings.
        /// </summary>
        public static string SystemSettings {
            get {
                return ResourceManager.GetString("SystemSettings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Teacher.
        /// </summary>
        public static string Teacher {
            get {
                return ResourceManager.GetString("Teacher", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Teachers.
        /// </summary>
        public static string Teachers {
            get {
                return ResourceManager.GetString("Teachers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text.
        /// </summary>
        public static string Text {
            get {
                return ResourceManager.GetString("Text", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time.
        /// </summary>
        public static string Time {
            get {
                return ResourceManager.GetString("Time", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Title.
        /// </summary>
        public static string Title {
            get {
                return ResourceManager.GetString("Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Admin Panel.
        /// </summary>
        public static string TitleDesk {
            get {
                return ResourceManager.GetString("TitleDesk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Translation.
        /// </summary>
        public static string Translation {
            get {
                return ResourceManager.GetString("Translation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type.
        /// </summary>
        public static string Type {
            get {
                return ResourceManager.GetString("Type", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unset.
        /// </summary>
        public static string Unset {
            get {
                return ResourceManager.GetString("Unset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User.
        /// </summary>
        public static string User {
            get {
                return ResourceManager.GetString("User", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Username.
        /// </summary>
        public static string UserName {
            get {
                return ResourceManager.GetString("UserName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Users.
        /// </summary>
        public static string Users {
            get {
                return ResourceManager.GetString("Users", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} field not filled.
        /// </summary>
        public static string ValidationFieldRequired {
            get {
                return ResourceManager.GetString("ValidationFieldRequired", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Required field.
        /// </summary>
        public static string ValidationRequired {
            get {
                return ResourceManager.GetString("ValidationRequired", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Demo.
        /// </summary>
        public static string VendorTitle {
            get {
                return ResourceManager.GetString("VendorTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Version.
        /// </summary>
        public static string Version {
            get {
                return ResourceManager.GetString("Version", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Welcome.
        /// </summary>
        public static string Welcome {
            get {
                return ResourceManager.GetString("Welcome", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Word.
        /// </summary>
        public static string Word {
            get {
                return ResourceManager.GetString("Word", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Words.
        /// </summary>
        public static string Words {
            get {
                return ResourceManager.GetString("Words", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Wrong username or password.
        /// </summary>
        public static string WrongPassword {
            get {
                return ResourceManager.GetString("WrongPassword", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Yes.
        /// </summary>
        public static string Yes {
            get {
                return ResourceManager.GetString("Yes", resourceCulture);
            }
        }
    }
}

=== feature FILES ===

