                            FontFamily = AppFonts.GameAutoselect,
                            TextColor = Colors.White,
                        }
                    },
                    FillGradient = new SkiaGradient()
                    {
                        StartXRatio = 0,
                        EndXRatio = 1,
                        StartYRatio = 0,
                        EndYRatio = 0.5f,
                        Colors = new Color[]
                        {
                            UiElements.ColorPrimary,
                            UiElements.ColorPrimaryDark,
                        }
                    },
                }.WithGestures((me, args, b) =>
                {
                    if (args.Type == TouchActionResult.Tapped)
                    {
                        action?.Invoke();
                    }
                    else if (args.Type == TouchActionResult.Down)
                    {
                        SetButtonPressed(me);
                    }
                    else if (args.Type == TouchActionResult.Up)
                    {
                        SetButtonReleased(me);
                        return null;
                    }

                    return me;
                });
            }
        }
    }

    public static class AmstradColors
    {
        public static readonly Color Black = Color.Parse("#000000");
        public static readonly Color Blue = Color.Parse("#0000FF");
        public static readonly Color Red = Color.Parse("#FF0000");
        public static readonly Color Magenta = Color.Parse("#FF00FF");
        public static readonly Color Green = Color.Parse("#00FF00");
        public static readonly Color Cyan = Color.Parse("#00FFFF");
        public static readonly Color Yellow = Color.Parse("#FFFF00");
        public static readonly Color White = Color.Parse("#FFFFFF");
        public static readonly Color Grey = Color.Parse("#808080");
        public static readonly Color BrightBlue = Color.Parse("#0080FF");
        public static readonly Color BrightRed = Color.Parse("#FF8080");
        public static readonly Color BrightMagenta = Color.Parse("#FF80FF");
        public static readonly Color BrightGreen = Color.Parse("#80FF80");
        public static readonly Color BrightCyan = Color.Parse("#80FFFF");
        public static readonly Color BrightYellow = Color.Parse("#FFFF80");
        public static readonly Color BrightWhite = Color.Parse("#C0C0C0");
        public static readonly Color DarkBlue = Color.Parse("#000080");
        public static readonly Color DarkRed = Color.Parse("#800000");
        public static readonly Color DarkMagenta = Color.Parse("#800080");
        public static readonly Color DarkGreen = Color.Parse("#008000");
        public static readonly Color DarkCyan = Color.Parse("#008080");
        public static readonly Color DarkYellow = Color.Parse("#808000");
        public static readonly Color DarkGrey = Color.Parse("#404040");
        public static readonly Color MidBlue = Color.Parse("#4040FF");
        public static readonly Color MidRed = Color.Parse("#FF4040");
        public static readonly Color MidGreen = Color.Parse("#40FF40");
        public static readonly Color MidCyan = Color.Parse("#40FFFF");

        // Optional: A method to get all colors as an array
        public static Color[] GetAllColors()
        {
            return new[]
            {
            Black, Blue, Red, Magenta, Green, Cyan, Yellow, White, Grey,
            BrightBlue, BrightRed, BrightMagenta, BrightGreen, BrightCyan, BrightYellow, BrightWhite,
            DarkBlue, DarkRed, DarkMagenta, DarkGreen, DarkCyan, DarkYellow, DarkGrey,
            MidBlue, MidRed, MidGreen, MidCyan
        };
        }
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGame.Ui.Dialogs.cs ---
using AppoMobi.Specials;
using Breakout.Game.Dialogs;
using Breakout.Game.Input;
using Breakout.Helpers;
using DrawnUi.Controls;
using System.Globalization;

namespace Breakout.Game
{
    public partial class BreakoutGame : MauiGame
    {
        #region DIALOGS

        void InitDialogs()
        {
            GameDialog.DefaultTemplate = DialogThemes.Game;
        }

        void ShowWelcomeDialog()
        {
#if WINDOWS || MACCATALYST
            var message = ResStrings.MessageWelcomeDesktop;
#else
            var message = ResStrings.MessageWelcome;
#endif
            GameDialog.Show(this,
                UiElements.DialogPrompt(message),
                ResStrings.StartGame.ToUpperInvariant(), onOk: () => { StartNewGamePlayer(); });
        }

        void ShowGameOverDialog()
        {
            PlaySound(Sound.Sad);

            // Show game over dialog
            var gameOverContent = UiElements.DialogPrompt(string.Format(ResStrings.MessageGameOver, Score));

            GameDialog.Show(this, gameOverContent, ResStrings.BtnPlayAgain.ToUpperInvariant(),
                onOk: () =>
                {
                    State = GameState.Playing;
                    ResetGame();
                });
        }

        async void ShowLevelCompleteDialog()
        {
            PlaySound(Sound.Joy);

            // Show level complete dialog
            var levelCompleteContent =
                UiElements.DialogPrompt(string.Format(ResStrings.MessageLevelComplete, Level - 1, Score, Level));
            if (await GameDialog.ShowAsync(this, levelCompleteContent, ResStrings.BtnContinue.ToUpperInvariant()))
            {
                // Start the new level
                State = GameState.Playing;
                StartNewLevel();
            }
        }

        /// <summary>
        /// Shows the options dialog with game settings like music toggle
        /// </summary>
        public void ShowOptions()
        {
            PlaySound(Sound.Dialog);

            _ = GameDialog.PopAll(this);

            // Pause the game if currently playing
            State = GameState.Paused;
            IsMovingLeft = false;
            IsMovingRight = false;

            // Create options dialog content
            var optionsContent = CreateOptionsDialogContent();

            void OnClose()
            {
                Tasks.StartDelayed(TimeSpan.FromMilliseconds(50), () =>
                {
                    TogglePause();
                });
            }

            // Show the dialog
            GameDialog.Show(this, optionsContent, ResStrings.BtnClose.ToUpperInvariant(), null,
                onOk: () =>
                {
                    OnClose();
                });
        }





        /// <summary>
        /// Creates the content for the options dialog
        ///
        ///
        ///
        ///
        /// </summary>
        private SkiaControl CreateOptionsDialogContent()
        {
            // Create the options layout
            var optionsLayout = new SkiaLayout()
            {
                Tag = "Options",
                Type = LayoutType.Column,
                Spacing = 20,
                Padding = new Thickness(16,16,16,-12),
                HorizontalOptions = LayoutOptions.Fill,
                Children = new List<SkiaControl>
                {
                    // Title
                    new SkiaRichLabel()
                    {
                        Text = ResStrings.Options.ToUpperInvariant(),
                        FontFamily = AppFonts.Default,
                        FontSize = 24,
                        TextColor = AmstradColors.White,
                        HorizontalTextAlignment = DrawTextAlignment.Center,
                        HorizontalOptions = LayoutOptions.Fill,
                        UseCache = SkiaCacheType.Operations
                    },

                    // LANGUAGE setting row
                    new OptionWithTappable("LangFlag")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //SOUND FX
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Language.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,

                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },
                            new DisplayFlag()
                                {
                                    Tag="LangFlag",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    var lang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
                                    me.Lang = lang;
                                })
                                .OnTapped((me, a) =>
                                {
                                    //is this a real tap?
                                    if (a.Parameters.Event != null)
                                    {
                                        AppLanguage.SelectAndSet();
                                    }
                                    else
                                    {
                                        //controller
                                        AppLanguage.SelectNextAndSet();
                                    }
                                }),
                        }
                    },

                    // SOUND setting row
                    new OptionWithTappable("SoundSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //SOUND FX
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Sounds.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },
                            new GameSwitch()
                                {
                                    Tag="SoundSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.SoundsOn,
                                            AppSettings.SoundsOnDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    if (_audioService != null)
                                    {
                                        EnableSounds(state);
                                        AppSettings.Set(AppSettings.SoundsOn, state);
                                    }
                                }),
                        }
                    },

                    // Music setting row - selectable
                    new OptionWithTappable("MusicSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            //MUSIC
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.Music.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },

                            new GameSwitch()
                                {
                                    Tag = "MusicSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.MusicOn,
                                            AppSettings.MusicOnDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    if (_audioService != null)
                                    {
                                        AppSettings.Set(AppSettings.MusicOn, state);
                                        if (state)
                                        {
                                            if (PreviousState == GameState.Playing)
                                            {
                                                PlayMusicLooped(Level);
                                            }
                                            else
                                            {
                                                PlayMusicLooped(0);
                                            }
                                        }
                                        else
                                        {
                                            StopBackgroundMusic();
                                        }
                                    }
                                }),
                        }
                    },

                    // Press input mode for HUD
                    new OptionWithTappable("HudSwitch")
                    {
                        Type = LayoutType.Row,
                        Spacing = 15,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = new List<SkiaControl>
                        {
                            new SkiaRichLabel()
                            {
                                Text = ResStrings.PressHud.ToUpperInvariant(),
                                FontFamily = AppFonts.Default,
                                FontSize = 18,
                                TextColor = AmstradColors.White,
                                VerticalOptions = LayoutOptions.Center,
                                HorizontalOptions = LayoutOptions.Start,
                                UseCache = SkiaCacheType.Operations,
                            },

                            new GameSwitch()
                                {
                                    Tag="HudSwitch",
                                    HorizontalOptions = LayoutOptions.End,
                                    VerticalOptions = LayoutOptions.Center,
                                }
                                .Initialize(me =>
                                {
                                    if (_audioService != null)
                                    {
                                        me.IsToggled = AppSettings.Get(AppSettings.InputPressEnabled,
                                            AppSettings.InputPressEnabledDefault);
                                    }
                                })
                                .OnToggled((me, state) =>
                                {
                                    SetInputPressMode(state);
                                }),
                        }
                    },

                    //DEMO
                    UiElements.Button(ResStrings.DemoMode.ToUpperInvariant(), async () =>
                    {
                        StartNewGameDemo();
                    }).FillX().WithMargin(new Thickness(0,16,0,-16)),

                    //RESTART
                    UiElements.Button(ResStrings.NewGame.ToUpperInvariant(), async () =>
                    {
                        StartNewGamePlayer();
                    }).FillX().WithMargin(new Thickness(0,16,0,0)),

                }
            };

            return optionsLayout;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\BreakoutGameExtensions.cs ---
using SkiaSharp;

namespace Breakout.Game;

/// <summary>
/// Extension methods for the Breakout game
/// </summary>
public static class BreakoutGameExtensions
{
    /// <summary>
    /// Identifies the collision face based on overlap rectangle
    /// </summary>
    /// <param name="overlap">The overlap rectangle</param>
    /// <param name="targetRect">The target rectangle</param>
    /// <returns>The collision face (Top, Bottom, Left, Right)</returns>
    public static CollisionFace GetCollisionFace(this SKRect overlap, SKRect targetRect)
    {
        // Calculate penetration depths for each edge
        float leftPenetration = overlap.Right;
        float rightPenetration = targetRect.Width - overlap.Left;
        float topPenetration = overlap.Bottom;
        float bottomPenetration = targetRect.Height - overlap.Top;

        // Find minimum penetration
        float minPenetration = MathF.Min(
            MathF.Min(leftPenetration, rightPenetration),
            MathF.Min(topPenetration, bottomPenetration)
        );

        // Return face with minimum penetration
        if (minPenetration == leftPenetration)
            return CollisionFace.Left;
        else if (minPenetration == rightPenetration)
            return CollisionFace.Right;
        else if (minPenetration == topPenetration)
            return CollisionFace.Top;
        else
            return CollisionFace.Bottom;
    }
}

--- C:\code\DrawnUi\src\Game\Ai\AIDifficulty.cs ---
namespace Breakout.Game.Ai;

/// <summary>
/// Represents AI difficulty levels for demo play
/// </summary>
public enum AIDifficulty
{
    Easy,
    Medium,
    Hard,
    Perfect  // For testing - never misses
}

--- C:\code\DrawnUi\src\Game\Ai\AIPaddleController.cs ---
using Breakout.Game.Input;

namespace Breakout.Game.Ai
{
    /// <summary>
    /// Controls the paddle in demo mode, simulating a human player with variable skill
    /// </summary>
    public class AIPaddleController
    {
        private readonly BreakoutGame _game;
        private readonly Random _random = new Random();
        private double _targetX;
        private float _reactionTimer;
        private float _mistakeTimer;
        private float _decisionChangeTimer;
        private float _movementSmoothingTimer;
        private bool _makingMistake;
        private float _mistakeDirection;
        private bool _canFire = true;
        private bool _isMoving = false;
        private GameKey _lastMovementKey = GameKey.Stop;
        private float _idleWanderTimer = 0;
        private float _idleWanderInterval = 0.8f;
        private float _shootingTimer = 0;
        private float _shootingInterval = 0.3f; // Shoot every 300ms when in destroyer mode

        // AI characteristics
        private readonly float _reactionTimeMin;
        private readonly float _reactionTimeMax;
        private readonly float _accuracy;
        private readonly float _mistakeProbability;
        private readonly float _mistakeDurationMin;
        private readonly float _mistakeDurationMax;
        private float _decisionChangeInterval;
        private readonly float _serveDelay;
        private readonly float _movementSmoothingTime;

        /// <summary>
        /// Creates a new AI paddle controller with specified difficulty
        /// </summary>
        /// <param name="game">Reference to the main game</param>
        /// <param name="difficulty">AI difficulty level</param>
        public AIPaddleController(BreakoutGame game, AIDifficulty difficulty = AIDifficulty.Medium)
        {
            _game = game;

            // Set AI characteristics based on difficulty
            switch (difficulty)
            {
            case AIDifficulty.Easy:
            _reactionTimeMin = 0.5f;
            _reactionTimeMax = 1.2f;
            _accuracy = 0.6f;
            _mistakeProbability = 0.4f;
            _mistakeDurationMin = 0.8f;
            _mistakeDurationMax = 1.5f;
            _decisionChangeInterval = 1.0f;
            _serveDelay = 2.0f;
            _movementSmoothingTime = 0.3f;
            break;

            case AIDifficulty.Hard:
            _reactionTimeMin = 0.05f;  // Much faster reaction
            _reactionTimeMax = 0.15f;  // Reduced from 0.4f
            _accuracy = 0.98f;         // Increased from 0.9f
            _mistakeProbability = 0.02f; // Reduced from 0.1f
            _mistakeDurationMin = 0.1f;  // Reduced from 0.2f
            _mistakeDurationMax = 0.2f;  // Reduced from 0.5f
            _decisionChangeInterval = 3.0f; // Increased from 2.0f
            _serveDelay = 0.5f;        // Reduced from 0.8f
            _movementSmoothingTime = 0.05f; // Reduced from 0.1f
            break;

            case AIDifficulty.Medium:
            default:
            _reactionTimeMin = 0.25f;
            _reactionTimeMax = 0.7f;
            _accuracy = 0.75f;
            _mistakeProbability = 0.2f;
            _mistakeDurationMin = 0.4f;
            _mistakeDurationMax = 0.9f;
            _decisionChangeInterval = 1.5f;
            _serveDelay = 1.5f;
            _movementSmoothingTime = 0.2f;
            break;

            case AIDifficulty.Perfect:
            _reactionTimeMin = 0.01f;
            _reactionTimeMax = 0.02f;
            _accuracy = 1.0f;          // Perfect accuracy
            _mistakeProbability = 0.0f; // No mistakes
            _mistakeDurationMin = 0.0f;
            _mistakeDurationMax = 0.0f;
            _decisionChangeInterval = 5.0f;
            _serveDelay = 0.2f;
            _movementSmoothingTime = 0.01f;
            break;
            }

            ResetTimers();
        }

        /// <summary>
        /// Resets all AI decision timers
        /// </summary>
        public void ResetTimers()
        {
            _reactionTimer = GetRandomReactionTime();
            _mistakeTimer = 0;
            _decisionChangeTimer = _serveDelay; // Initial delay before serving
            _movementSmoothingTimer = 0;
            _makingMistake = false;
            _mistakeDirection = 0;
            _canFire = true;
            _isMoving = false;
            _lastMovementKey = GameKey.Stop;
            _idleWanderTimer = 0;
            _shootingTimer = 0;
        }

        /// <summary>
        /// Updates the AI paddle position based on ball trajectory and AI characteristics
        /// </summary>
        /// <param name="deltaTime">Time since last frame</param>
        public void UpdateAI(float deltaTime)
        {
            // Update shooting timer for destroyer mode
            _shootingTimer -= deltaTime;

            // If paddle has destroyer powerup, shoot at bricks
            if (_game.Paddle.Powerup == PowerupType.Destroyer && _shootingTimer <= 0)
            {
                _game.ApplyGameKey(GameKey.Fire);
                _shootingTimer = _shootingInterval + _random.NextSingle() * 0.2f;
            }

            // If no balls are moving, handle serving
            if (_game.ActiveBalls.Count == 0 || !_game.ActiveBalls.Any(b => b.IsMoving))
            {
                IdleWandering(deltaTime);
                _decisionChangeTimer -= deltaTime;
                if (_decisionChangeTimer <= 0 && _canFire)
                {
                    _game.ApplyGameKey(GameKey.Fire);
                    _canFire = false;
                    _decisionChangeTimer = _decisionChangeInterval;
                }
                return;
            }

            _canFire = true;
            _reactionTimer -= deltaTime;
            _movementSmoothingTimer -= deltaTime;

            // Handle mistakes
            if (_makingMistake)
            {
                _mistakeTimer -= deltaTime;
                if (_mistakeTimer <= 0)
                {
                    _makingMistake = false;
                    _reactionTimer = GetRandomReactionTime();

                    // Stop movement after mistake
                    StopMovement();
                }
                else
                {
                    // Apply mistake movement
                    if (_mistakeDirection < 0 && _lastMovementKey != GameKey.Left)
                    {
                        _game.ApplyGameKey(GameKey.Left);
                        _lastMovementKey = GameKey.Left;
                        _isMoving = true;
                    }
                    else if (_mistakeDirection > 0 && _lastMovementKey != GameKey.Right)
                    {
                        _game.ApplyGameKey(GameKey.Right);
                        _lastMovementKey = GameKey.Right;
                        _isMoving = true;
                    }
                    else if (_mistakeDirection == 0 && _isMoving)
                    {
                        StopMovement();
                    }
                    return;
                }
            }

            _decisionChangeTimer -= deltaTime;
            if (_decisionChangeTimer <= 0)
            {
                // Decide whether to make a mistake
                if (!_makingMistake && _random.NextDouble() < _mistakeProbability)
                {
                    _makingMistake = true;
                    _mistakeTimer = _random.NextSingle() *
                        (_mistakeDurationMax - _mistakeDurationMin) + _mistakeDurationMin;

                    // Either move in a random direction or stay still
                    if (_random.NextDouble() < 0.7)
                    {
                        _mistakeDirection = _random.NextDouble() < 0.5 ? -1 : 1;
                    }
                    else
                    {
                        _mistakeDirection = 0; // Stay still as a "mistake"
                    }
                }

                _decisionChangeInterval = 0.5f + _random.NextSingle();
                _decisionChangeTimer = _decisionChangeInterval;
            }

            // If making a mistake, continue with that
            if (_makingMistake)
            {
                if (_mistakeDirection < 0 && _lastMovementKey != GameKey.Left)
                {
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
                else if (_mistakeDirection > 0 && _lastMovementKey != GameKey.Right)
                {
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
                else if (_mistakeDirection == 0 && _isMoving)
                {
                    StopMovement();
                }
                return;
            }

            // Find the closest ball that's coming down
            var closestBall = _game.ActiveBalls
                .Where(ball => ball.IsMoving && MathF.Sin(ball.Angle) > 0) // Coming down
                .OrderBy(ball => ball.Top) // Closest to paddle
                .FirstOrDefault();

            if (closestBall != null)
            {
                // BALL IS COMING DOWN - PRIORITIZE BALL, but try powerups if safe
                if (_reactionTimer <= 0)
                {
                    // Calculate ball trajectory first
                    var ballX = closestBall.Left;
                    var ballY = closestBall.Top;
                    var paddleY = _game.Paddle.Top;

                    var ballVelX = MathF.Cos(closestBall.Angle) * BreakoutGame.BALL_SPEED * closestBall.SpeedRatio;
                    var ballVelY = MathF.Sin(closestBall.Angle) * BreakoutGame.BALL_SPEED * closestBall.SpeedRatio;

                    var timeToIntersect = (paddleY - ballY) / ballVelY;

                    if (timeToIntersect > 0)
                    {
                        var predictedX = ballX + ballVelX * timeToIntersect;
                        var accuracyBonus = _game.Paddle.Powerup == PowerupType.Destroyer ? 0.1f : 0f;
                        var effectiveAccuracy = Math.Min(1.0f, _accuracy + accuracyBonus);
                        var maxError = (1 - effectiveAccuracy) * _game.Paddle.Width;
                        var error = (_random.NextSingle() * 2 - 1) * maxError;

                        // Handle wall bounces
                        var halfGameWidth = _game.Width / 2;
                        while (predictedX < -halfGameWidth || predictedX > halfGameWidth)
                        {
                            if (predictedX < -halfGameWidth)
                                predictedX = -halfGameWidth - (predictedX + halfGameWidth);
                            else
                                predictedX = halfGameWidth - (predictedX - halfGameWidth);
                        }

                        _targetX = predictedX + error;
                        _reactionTimer = GetRandomReactionTime();

                        // Check if we have time to grab a powerup on the way
                        if (timeToIntersect > 2.0f && CheckForPowerupsToCollect())
                        {
                            // Go for powerup if we have plenty of time
                            return;
                        }

                        // Otherwise focus on ball
                        MovePaddleTowardTarget();
                        return;
                    }
                }
            }
            else
            {
                // BALL IS FLYING UP - SAFE! PRIORITIZE POWERUPS!
                if (CheckForPowerupsToCollect())
                {
                    return; // Going for powerup
                }

                // No powerups, do some idle movement
                if (_movementSmoothingTimer <= 0)
                {
                    if (Math.Abs(_game.Paddle.Left) > _game.Paddle.Width && _random.NextDouble() < 0.2)
                    {
                        _targetX = _game.Paddle.Left > 0 ? -_game.Paddle.Width : _game.Paddle.Width;
                        MovePaddleTowardTarget();
                    }
                    else if (_isMoving && _random.NextDouble() < 0.3)
                    {
                        StopMovement();
                    }
                    _movementSmoothingTimer = _movementSmoothingTime;
                }
            }
        }

        /// <summary>
        /// Handles random paddle movement during idle periods (before serving)
        /// </summary>
        private void IdleWandering(float deltaTime)
        {
            _idleWanderTimer -= deltaTime;

            if (_idleWanderTimer <= 0)
            {
                _idleWanderTimer = _idleWanderInterval;
                _idleWanderInterval = 0.3f + _random.NextSingle() * 0.8f; // Random interval

                // Choose random movement or stop
                float decision = (float)_random.NextDouble();

                if (decision < 0.3f) // 30% chance to move left
                {
                    StopMovement();
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
                else if (decision < 0.6f) // 30% chance to move right
                {
                    StopMovement();
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
                else // 40% chance to stop
                {
                    StopMovement();
                }

                // Prevent paddle from going too far to edges while idle
                if (Math.Abs(_game.Paddle.Left) > _game.Width / 3f)
                {
                    // If too far right, move left
                    if (_game.Paddle.Left > 0)
                    {
                        StopMovement();
                        _game.ApplyGameKey(GameKey.Left);
                        _lastMovementKey = GameKey.Left;
                        _isMoving = true;
                    }
                    // If too far left, move right
                    else
                    {
                        StopMovement();
                        _game.ApplyGameKey(GameKey.Right);
                        _lastMovementKey = GameKey.Right;
                        _isMoving = true;
                    }
                }
            }
        }

        /// <summary>
        /// Moves paddle toward the calculated target position by applying appropriate keys
        /// </summary>
        private void MovePaddleTowardTarget()
        {
            if (_movementSmoothingTimer > 0)
                return;

            _movementSmoothingTimer = _movementSmoothingTime / 2; // Faster decision-making when chasing ball

            var distanceToTarget = _targetX - _game.Paddle.Left;

            // Add some "slop" - don't move for tiny differences (human-like behavior)
            var deadzone = _game.Paddle.Width * 0.15f;

            if (MathF.Abs((float)distanceToTarget) < deadzone)
            {
                // Close enough, stop movement
                if (_isMoving)
                {
                    StopMovement();
                }
                return;
            }

            // Move in the appropriate direction, but only send new command if direction changes
            if (distanceToTarget < 0)
            {
                if (_lastMovementKey != GameKey.Left)
                {
                    _game.ApplyGameKey(GameKey.Left);
                    _lastMovementKey = GameKey.Left;
                    _isMoving = true;
                }
            }
            else
            {
                if (_lastMovementKey != GameKey.Right)
                {
                    _game.ApplyGameKey(GameKey.Right);
                    _lastMovementKey = GameKey.Right;
                    _isMoving = true;
                }
            }
        }

        /// <summary>
        /// Stops paddle movement and updates state
        /// </summary>
        private void StopMovement()
        {
            _game.ApplyGameKey(GameKey.Stop);
            _lastMovementKey = GameKey.Stop;
            _isMoving = false;
        }

        private float GetRandomReactionTime()
        {
            return _random.NextSingle() * (_reactionTimeMax - _reactionTimeMin) + _reactionTimeMin;
        }

        /// <summary>
        /// Checks for falling powerups and decides whether to collect them
        /// </summary>
        private bool CheckForPowerupsToCollect()
        {
            PowerUpSprite targetPowerUp = null;
            double closestDistance = double.MaxValue;

            // Find ANY powerup that can be reached
            foreach (var view in _game.GameField.Views)
            {
                if (view is PowerUpSprite powerup && powerup.IsActive)
                {
                    var distance = Math.Abs(powerup.Left - _game.Paddle.Left);
                    var timeToReachPaddle = (powerup.Top - _game.Paddle.Top) / PowerUpSprite.FallSpeed;

                    // Go for ANY powerup that's reachable - MUCH MORE AGGRESSIVE
                    if (timeToReachPaddle > 0.1f && distance < closestDistance)
                    {
                        closestDistance = distance;
                        targetPowerUp = powerup;
                    }
                }
            }

            // If we found any powerup, go for it aggressively
            if (targetPowerUp != null)
            {
                _targetX = targetPowerUp.Left;
                MovePaddleTowardTarget();
                return true; // Signal that we're going for a powerup
            }

            return false; // No powerups to collect
        }


    }
}

--- C:\code\DrawnUi\src\Game\Controls\DisplayFlag.cs ---
using AppoMobi.Specials;

namespace Breakout.Game;

public class DisplayFlag : SkiaLayout
{
    private string _lang;

    public string Lang
    {
        get => _lang;
        set
        {
            if (value == _lang) return;
            _lang = value;
            OnPropertyChanged();
        }
    }

    public DisplayFlag()
    {
        HeightRequest = 28;
        WidthRequest = 56;
        Children = new List<SkiaControl>()
        {
            new SkiaLayout()
            {
                Type = LayoutType.Row,
                VerticalOptions = LayoutOptions.Fill,
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 0,

                Children = new List<SkiaControl>()
                {
                    //flag icon
                    new SkiaShape()
                    {
                        Margin = new(0, 0, 2, 0),
                        StrokeColor = BreakoutGame.UiElements.ColorIconSecondary,
                        StrokeWidth = 1,
                        VerticalOptions = LayoutOptions.Fill,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children =
                        {
                            new SkiaSvg()
                                {
                                    VerticalOptions = LayoutOptions.Fill,
                                    HorizontalOptions = LayoutOptions.Fill,
                                    Aspect = TransformAspect.Fill
                                }
                                .ObserveProperty(this, nameof(Lang), me =>
                                {
                                    if (!string.IsNullOrEmpty(this.Lang))
                                    {
                                        var resKey = $"SvgFlag{this.Lang.ToTitleCase()}";
                                        me.SvgString = App.Current.Resources.Get<string>(resKey);
                                    }
                                }),
                        }
                    },


                    //dropdown icon
                    new SkiaSvg()
                    {
                        Margin = new Microsoft.Maui.Thickness(1, 1, 0, 0),
                        HorizontalOptions = LayoutOptions.Start,
                        TintColor = BreakoutGame.UiElements.ColorIconSecondary,
                        VerticalOptions = LayoutOptions.Fill,
                        WidthRequest = 10,
                        SvgString = App.Current.Resources.Get<string>("SvgDropdown")
                    }
                },
            }
        };
    }
}

--- C:\code\DrawnUi\src\Game\Controls\GameSwitch.cs ---
namespace Breakout.Game;

public class GameSwitch : SkiaSwitch
{
    public GameSwitch()
    {
        WidthRequest = 60;
        HeightRequest = 32;
        ColorFrameOff = BreakoutGame.UiElements.ColorIconSecondary;
        ColorFrameOn = BreakoutGame.UiElements.ColorPrimary;
        ColorThumbOff = AmstradColors.White;
        ColorThumbOn = AmstradColors.White;
        UseCache = SkiaCacheType.Operations;
    }
}

--- C:\code\DrawnUi\src\Game\Controls\HudArrows.cs ---
using Breakout.Game.Input;

namespace Breakout.Game;

public class HudArrows : SkiaGrid
{
    private BreakoutGame _game;
    private readonly HudController _controller;

    public HudArrows(BreakoutGame game)
    {
        _game = game;
        _controller = new HudController(game);
        _game.AddInputController(_controller);
    }

    public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args, GestureEventProcessingInfo apply)
    {
        if (_game.InputPressMode)
        {
            var hitbox = this.GetHitBox();
            var consumed = _controller.ProcessGestures(args, apply, hitbox, RenderingScale);
            if (consumed)
            {
                return this;
            }
        }

        return base.ProcessGestures(args, apply);
    }

    public override void OnWillDisposeWithChildren()
    {
        base.OnWillDisposeWithChildren();

        _game = null;
    }
}

--- C:\code\DrawnUi\src\Game\Controls\OptionWithTappable.cs ---
using AppoMobi.Maui.Gestures;
using Breakout.Game.Input;

namespace Breakout.Game;

/// <summary>
/// To support selected options inside dialog
/// </summary>
public class OptionWithTappable : SkiaLayout, IGameKeyHandler
{
    private readonly string _tag;
    private readonly SkiaControl _control;

    public OptionWithTappable(SkiaControl control)
    {
        _control = control;
    }

    public OptionWithTappable(string tag)
    {
        _tag = tag;
    }

    public bool HandleGameKey(GameKey key)
    {
        if (key == GameKey.Fire)
        {
            var control = _control;
            if (control == null)
            {
                control = FindViewByTag(_tag);
            }
            if (control != null)
            {
                var tap = new SkiaGesturesParameters()
                {
                    Type = TouchActionResult.Tapped
                };
                control.ProcessGestures(tap, GestureEventProcessingInfo.Empty);
            }
            return true;
        }

        return false;
    }
    public bool IsSelected { get; set; }
}

--- C:\code\DrawnUi\src\Game\Controls\SelectableGameButton.cs ---
using AppoMobi.Maui.Gestures;
using Breakout.Game.Input;

namespace Breakout.Game.Controls;

public class SelectableGameButton : SkiaShape, IGameKeyHandler
{
    public bool HandleGameKey(GameKey key)
    {
        if (key == GameKey.Fire)
        {
            var tap = new SkiaGesturesParameters()
            {
                Type = TouchActionResult.Tapped
            };
            ProcessGestures(tap, GestureEventProcessingInfo.Empty);
            return true;
        }

        return false;
    }


}

--- C:\code\DrawnUi\src\Game\Controls\StableCacheLayout.cs ---
namespace Breakout.Game;

public class StableCacheLayout : SkiaLayout
{
    private long _state;
    private long _stateCached;

    public override void OnScaleChanged()
    {
        _state++;

        base.OnScaleChanged();
    }

    protected override void OnCacheCreated()
    {
        base.OnCacheCreated();

        _stateCached = _state;
    }


    public override void OnChildrenChanged()
    {
        base.OnChildrenChanged();

        _state++;
    }

    public override void InvalidateCache()
    {
        if (_stateCached == _state)
        {
            return; // disable cache invalidation, we will need it built only once
        }

        base.InvalidateCache();
    }

}

--- C:\code\DrawnUi\src\Game\Dev\Test.cs ---
using AppoMobi.Maui.Gestures;
using SkiaSharp;

namespace Breakout.Game.Dev
{
    //public class Test : Canvas
    //{
    //    public Test()
    //    {
    //        RetainedMode = true;

    //        Gestures = GesturesMode.Enabled;
    //        HardwareAcceleration = HardwareAccelerationMode.Enabled;
    //        HorizontalOptions = LayoutOptions.Fill;
    //        VerticalOptions = LayoutOptions.Fill;
    //        BackgroundColor = Colors.DarkGrey;
    //        Content = new TouchLayout()
    //        {
    //        };
    //    }
    //}

    /// <summary>
    /// Just testing retained here. Could rewrite game to use retained rendering at some point.
    /// </summary>
    public class TouchLayout : SkiaLayout
    {
        private PointF? _tapped;
        private List<PointF> _brushStrokes = new List<PointF>();
        private float _brushSize = 30;
        private SKColor _brushColor = SKColors.Blue;

        public TouchLayout()
        {
            HorizontalOptions = LayoutOptions.Fill;
            VerticalOptions = LayoutOptions.Fill;
        }

        protected override void Paint(DrawingContext ctx)
        {
            base.Paint(ctx);

            if (_tapped != null)
            {
                var canvas = ctx.Context.Canvas;


                using var paint = new SKPaint
                {
                    IsAntialias = true,
                    Color = _brushColor,
                    Style = SKPaintStyle.Fill
                };

                canvas.DrawCircle(_tapped.Value.X, _tapped.Value.Y,
                    _brushSize, paint);

                // Add to our persistent collection
                _brushStrokes.Add(_tapped.Value);
                _tapped = null;

                // Alternate brush colors to make it easy to see each new tap
                if (_brushColor == SKColors.Blue)
                    _brushColor = SKColors.Red;
                else if (_brushColor == SKColors.Red)
                    _brushColor = SKColors.Green;
                else
                    _brushColor = SKColors.Blue;

                _tapped = null;
            }
        }

        public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args,
            GestureEventProcessingInfo apply)
        {
            if (args.Type == TouchActionResult.Tapped)
            {
                _tapped = args.Event.Location;


                return this;
            }

            return base.ProcessGestures(args, apply);
        }
    }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogAnimations.cs ---
namespace Breakout.Game.Dialogs;

/// <summary>
/// Animation definitions for dialog appearance and disappearance
/// </summary>
public class DialogAnimations
{
    public Func<SkiaLayout, CancellationToken, Task> BackdropAppearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> BackdropDisappearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> FrameAppearing { get; set; }
    public Func<SkiaLayout, CancellationToken, Task> FrameDisappearing { get; set; }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogTemplate.cs ---
namespace Breakout.Game.Dialogs;

/// <summary>
/// Template system for customizing dialog appearance and behavior
/// </summary>
public class DialogTemplate
{
    public Func<GameDialog, SkiaControl, string, string, SkiaLayout> CreateDialogFrame { get; set; }
    public Func<SkiaLayout> CreateBackdrop { get; set; }
    public Func<string, SkiaControl> CreateButton { get; set; }
    public DialogAnimations Animations { get; set; }
}

--- C:\code\DrawnUi\src\Game\Dialogs\DialogThemes.cs ---

namespace Breakout.Game.Dialogs
{
    /// <summary>
    /// Predefined dialog themes for easy customization
    /// </summary>
    public static class DialogThemes
    {
        #region MODERN

        /// <summary>
        /// Modern glass-like dialog theme with blur effects
        /// </summary>
        public static DialogTemplate Modern => new DialogTemplate
        {
            CreateBackdrop = () => new SkiaLayout
            {
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = Colors.Black.WithAlpha(0.5f)
            },

            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 40,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                MinimumHeightRequest = 50,
                Children = new List<SkiaControl>
                {
                    // Modern backdrop with blur
                    new SkiaShape
                    {
                        CornerRadius = 16,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        BackgroundColor = Colors.White.WithAlpha(0.9f),
                        //Shadow = new SkiaShadow
                        //{
                        //    Color = Colors.Black.WithAlpha(0.3f),
                        //    Blur = 20,
                        //    OffsetY = 8
                        //}
                    },

                    // Content container
                    new SkiaLayout
                    {
                        Type = LayoutType.Column,
                        Padding = 32,
                        Spacing = 24,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = CreateModernContentChildren(dialog, content, okText, cancelText)
                    }
                }
            },

            CreateButton = (text) => new SkiaButton
            {
                Text = text,
                FontSize = 16,
                TextColor = Colors.White,
                BackgroundColor = Colors.Blue,
                CornerRadius = 8,
                Padding = new Thickness(24, 12),
                MinimumWidthRequest = 100
            },

            Animations = new DialogAnimations
            {
                BackdropAppearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    backdrop.Opacity = 0;
                    await backdrop.FadeToAsync(1.0, 300, Easing.Linear, cancelSource);
                },

                FrameAppearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    frame.Scale = 0.8;
                    frame.Opacity = 0;
                    await Task.WhenAll(
                        frame.ScaleToAsync(1.0, 1.0, 400, Easing.CubicOut, cancelSource),
                        frame.FadeToAsync(1.0, 300, Easing.Linear, cancelSource)
                    );
                },

                BackdropDisappearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await backdrop.FadeToAsync(0.0, 200, Easing.Linear, cancelSource);
                },

                FrameDisappearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await Task.WhenAll(
                        frame.ScaleToAsync(0.9, 0.9, 200, Easing.CubicIn, cancelSource),
                        frame.FadeToAsync(0.0, 200, Easing.Linear, cancelSource)
                    );
                }
            }
        };


        private static List<SkiaControl> CreateModernContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                children.Add(content);
            }

            children.Add(CreateModernButtonLayout(dialog, okText, cancelText));
            return children;
        }


        private static SkiaLayout CreateModernButtonLayout(GameDialog dialog, string okText, string cancelText)
        {
            var okButton = CreateModernButton(okText, true);
            okButton.OnTapped(async me => await dialog.CloseWithOkAsync());

            var layout = new SkiaLayout
            {
                Type = LayoutType.Row,
                HorizontalOptions = LayoutOptions.Center,
                Spacing = 16,
                Children = { okButton }
            };

            if (!string.IsNullOrEmpty(cancelText))
            {
                var cancelButton = CreateModernButton(cancelText, false);
                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                layout.Add(cancelButton);
            }

            return layout;
        }

        private static SkiaButton CreateModernButton(string text, bool isPrimary)
        {
            return new SkiaButton
            {
                Text = text,
                FontSize = 16,
                TextColor = Colors.White,
                BackgroundColor = isPrimary ? Colors.Blue : Colors.Gray,
                CornerRadius = 8,
                Padding = new Thickness(24, 12),
                MinimumWidthRequest = 100
            };
        }

        #endregion

        #region RETRO

        /// <summary>
        /// Retro terminal-style dialog theme
        /// </summary>
        public static DialogTemplate Retro => new DialogTemplate
        {
            CreateBackdrop = () => new SkiaLayout
            {
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = Colors.Black.WithAlpha(0.8f)
            },

            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 60,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                Children = new List<SkiaControl>
                {
                    // Retro terminal background
                    new SkiaShape
                    {
                        CornerRadius = 0,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        BackgroundColor = Colors.Black,
                        StrokeColor = Colors.LimeGreen,
                        StrokeWidth = 2
                    },

                    // Content container
                    new SkiaLayout
                    {
                        Type = LayoutType.Column,
                        Padding = 24,
                        Spacing = 16,
                        HorizontalOptions = LayoutOptions.Fill,
                        Children = CreateRetroContentChildren(dialog, content, okText, cancelText)
                    }
                }
            },

            CreateButton = (text) => new SkiaButton
            {
                Text = text,
                FontSize = 14 * AppFonts.GameAdjustSize,
                FontFamily = AppFonts.GameAutoselect,
                TextColor = Colors.LimeGreen,
                BackgroundColor = Colors.Black,
                StrokeColor = Colors.LimeGreen,
                StrokeWidth = 1,
                Padding = new Thickness(16, 8),
                MinimumWidthRequest = 80
            },

            Animations = new DialogAnimations
            {
                BackdropAppearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    backdrop.Opacity = 0;
                    await backdrop.FadeToAsync(1.0, 150, Easing.Linear, cancelSource);
                },

                FrameAppearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    frame.Opacity = 0;
                    await frame.FadeToAsync(1.0, 200, Easing.Linear, cancelSource);
                },

                BackdropDisappearing = async (backdrop, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await backdrop.FadeToAsync(0.0, 100, Easing.Linear, cancelSource);
                },

                FrameDisappearing = async (frame, token) =>
                {
                    var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(token);
                    await frame.FadeToAsync(0.0, 150, Easing.Linear, cancelSource);
                }
            }
        };

        private static List<SkiaControl> CreateRetroContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                // Style content for retro theme
                if (content is SkiaLabel label)
                {
                    label.TextColor = Colors.LimeGreen;
                    label.FontFamily = AppFonts.GameAutoselect;
                }

                children.Add(content);
            }

            children.Add(CreateRetroButtonLayout(dialog, okText, cancelText));
            return children;
        }

        private static SkiaLayout CreateRetroButtonLayout(GameDialog dialog, string okText, string cancelText)
        {
            var okButton = CreateRetroButton(okText, true);
            okButton.OnTapped(async me => await dialog.CloseWithOkAsync());

            var layout = new SkiaLayout
            {
                Type = LayoutType.Row,
                HorizontalOptions = LayoutOptions.Center,
                Spacing = 12,
                Children = { okButton }
            };

            if (!string.IsNullOrEmpty(cancelText))
            {
                var cancelButton = CreateRetroButton(cancelText, false);
                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                layout.Add(cancelButton);
            }

            return layout;
        }

        private static SkiaButton CreateRetroButton(string text, bool isPrimary)
        {
            return new SkiaButton
            {
                Text = text,
                FontSize = 14 * AppFonts.GameAdjustSize,
                FontFamily = AppFonts.GameAutoselect,
                TextColor = Colors.LimeGreen,
                BackgroundColor = Colors.Black,
                StrokeColor = Colors.LimeGreen,
                StrokeWidth = 1,
                Padding = new Thickness(16, 8),
                MinimumWidthRequest = 80
            };
        }

        #endregion

        #region GAME

        private static float gameRadius = 8;

        /// <summary>
        /// Game-specific dialog theme (recreates the original design exactly)
        /// </summary>
        public static DialogTemplate Game => new DialogTemplate
        {
            CreateBackdrop = () => null, // Original design doesn't use dimmer layer


            CreateDialogFrame = (dialog, content, okText, cancelText) => new SkiaLayout
            {
                Margin = 32,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center,
                MinimumHeightRequest = 80,
                Children = new List<SkiaControl>
                {
                    //shape A - background texture for frosted effect plus shadow (cached layer)
                    new SkiaShape()
                    {
                        UseCache = SkiaCacheType.Image,
                        BackgroundColor = Color.Parse("#10ffffff"),
                        CornerRadius = gameRadius,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        StrokeColor = Colors.Red,
                        StrokeWidth = 2,
                        StrokeGradient = new SkiaGradient()
                        {
                            Opacity = 0.99f,
                            StartXRatio = 0.2f,
                            EndXRatio = 0.5f,
                            StartYRatio = 0.0f,
                            EndYRatio = 1f,
                            Colors = new Color[]
                            {
                                Color.Parse("#ffffff"),
                                Color.Parse("#999999"),
                            }
                        },
                        Children =
                        {
                            new SkiaImage()
                            {
                                Opacity = 0.25,
                                Source = "Images/glass.jpg",
                                HorizontalOptions = LayoutOptions.Fill,
                                VerticalOptions = LayoutOptions.Fill,
                            }
                        }
                    },

                    //shape B = backdrop
                    new SkiaShape()
                    {
                        CornerRadius = gameRadius,
                        HorizontalOptions = LayoutOptions.Fill,
                        VerticalOptions = LayoutOptions.Fill,
                        Children =
                        {
                            new SkiaBackdrop()
                            {
                                Blur = 4,
                                HorizontalOptions = LayoutOptions.Fill,
                                VerticalOptions = LayoutOptions.Fill,
                            }
                        }
                    },

                    // Content layout
                    new SkiaLayout()
                    {
                        ZIndex = 1,
                        HorizontalOptions = LayoutOptions.Fill,
                        UseCache = SkiaCacheType.Image,
                        Type = LayoutType.Column,
                        Padding = 20,
                        Spacing = 32,
                        Children = CreateGameContentChildren(dialog, content, okText, cancelText)
                    }
                }
            }
        };

        private static List<SkiaControl> CreateGameContentChildren(GameDialog dialog, SkiaControl content,
            string okText, string cancelText)
        {
            var children = new List<SkiaControl>();

            // Add the main content
            if (content != null)
            {
                content.VerticalOptions = LayoutOptions.Start;
                children.Add(content);
            }

            var btnOk = BreakoutGame.UiElements.Button(okText, async () => await dialog.CloseWithOkAsync());
            btnOk.HorizontalOptions = LayoutOptions.Fill;

            // Create buttons layout exactly like the original
            var buttonsLayout = new SkiaLayout()
            {
                Type = LayoutType.Wrap,
                Margin = new(16, 0, 16, 0),
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 16,
                Children =
                {
                    // OK button using UiElements.Button (original design) with proper callback
                    btnOk
                }
            };

            // Cancel button (optional) - exactly like original
            if (!string.IsNullOrEmpty(cancelText))
            {
                btnOk.HorizontalOptions = LayoutOptions.Start;
                buttonsLayout.HorizontalOptions = LayoutOptions.Center;

                var cancelButton = new SkiaButton()
                {
                    Text = cancelText,
                    FontSize = 14 * AppFonts.GameAdjustSize,
                    FontFamily = AppFonts.GameAutoselect,
                    TextColor = Colors.White,
                    BackgroundColor = Colors.DarkRed,
                    WidthRequest = -1,
                    MinimumWidthRequest = 100,
                };

                cancelButton.OnTapped(async me => await dialog.CloseWithCancelAsync());
                buttonsLayout.Add(cancelButton);
            }

            children.Add(buttonsLayout);
            return children;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\Dialogs\GameDialog.cs ---
using Breakout.Game.Input;
using SkiaSharp;

namespace Breakout.Game.Dialogs
{
    /// <summary>
    /// A standalone dialog class with customizable templates and animations.
    /// Displays content with optional OK and Cancel buttons.
    /// </summary>
    public class GameDialog : SkiaLayout, IGameKeyHandler
    {
        // Navigation stack: container -> dialog
        private static readonly Dictionary<SkiaLayout, Stack<GameDialog>> _navigationStacks = new();

        // Template system for customizing dialog appearance
        public static DialogTemplate DefaultTemplate { get; set; }

        static GameDialog()
        {
            DefaultTemplate = DialogThemes.Modern;
        }

        // Legacy animation delegates (kept for backward compatibility)
        public static Func<SkiaLayout, SkiaLayout, SkiaLayout, CancellationToken, Task> DefaultAppearingAnimation
        {
            get;
            set;
        }

        public static Func<SkiaLayout, SkiaLayout, SkiaLayout, CancellationToken, Task> DefaultDisappearingAnimation
        {
            get;
            set;
        }

        public Action OnOkClicked { get; set; }
        public Action OnCancelClicked { get; set; }

        public SkiaControl Content;
        private string _okText;
        private string _cancelText;
        private SkiaLayout _parentContainer;
        private TaskCompletionSource<bool> _taskCompletionSource;
        private bool _isClosing;

        // References to dialog components for separate animations
        private SkiaLayout _dimmerLayer;
        private SkiaLayout _dialogFrame;

        private DialogTemplate _template;

        private GameDialog(SkiaControl content, string ok = null, string cancel = null,
            SkiaLayout parentContainer = null, DialogTemplate template = null)
        {
            Content = content;
            _okText = ok ?? ResStrings.BtnOk;
            _cancelText = cancel;
            _parentContainer = parentContainer;
            _template = template ?? DefaultTemplate;

            SetupDialog();
        }

        public override ISkiaGestureListener ProcessGestures(SkiaGesturesParameters args,
            GestureEventProcessingInfo apply)
        {
            return base.ProcessGestures(args, apply);
        }

        /// <summary>
        /// Shows a dialog with the specified content and buttons.
        /// </summary>
        /// <param name="parentContainer">The parent container to add the dialog to</param>
        /// <param name="content">The content to display in the dialog</param>
        /// <param name="ok">OK button text (defaults to "OK")</param>
        /// <param name="cancel">Cancel button text (null = no cancel button)</param>
        /// <param name="onOk">Action to execute when OK is clicked</param>
        /// <param name="onCancel">Action to execute when Cancel is clicked</param>
        /// <param name="template">Custom template to use for this dialog (optional)</param>
        public static void Show(SkiaLayout parentContainer, SkiaControl content, string ok = null, string cancel = null,
            Action onOk = null, Action onCancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            dialog.OnOkClicked = onOk;
            dialog.OnCancelClicked = onCancel;

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();
        }

        /// <summary>
        /// Shows a dialog asynchronously and returns true if OK was clicked, false if Cancel was clicked.
        /// </summary>
        /// <param name="parentContainer">The parent container to add the dialog to</param>
        /// <param name="content">The content to display in the dialog</param>
        /// <param name="ok">OK button text (defaults to "OK")</param>
        /// <param name="cancel">Cancel button text (null = no cancel button)</param>
        /// <param name="template">Custom template to use for this dialog (optional)</param>
        /// <returns>Task that returns true for OK, false for Cancel</returns>
        public static Task<bool> ShowAsync(SkiaLayout parentContainer, SkiaControl content, string ok = null,
            string cancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);
            dialog._taskCompletionSource = new TaskCompletionSource<bool>();

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            // Note: OnOkClicked and OnCancelClicked will be handled by the CloseAsync method
            // The task completion will be set there

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();

            return dialog._taskCompletionSource.Task;
        }

        /// <summary>
        /// Closes the dialog with the specified result and optional animation.
        /// </summary>
        /// <param name="result">The result to return (true for OK, false for Cancel)</param>
        /// <param name="animate">Whether to animate the closing</param>
        public async Task CloseAsync(bool result, bool animate = true)
        {
            if (_isClosing) return;
            _isClosing = true;

            SelectionIndicatorRect = SKRect.Empty;

            if (animate)
            {
                await PlayDisappearingAnimation();
            }

            // Remove from parent
            _parentContainer?.RemoveSubView(this);

            // Remove from navigation stack
            if (_parentContainer != null && _navigationStacks.ContainsKey(_parentContainer))
            {
                var stack = _navigationStacks[_parentContainer];
                if (stack.Count > 0 && stack.Peek() == this)
                {
                    stack.Pop();
                }

                // Clean up empty stacks
                if (stack.Count == 0)
                {
                    _navigationStacks.Remove(_parentContainer);
                }
            }

            // Complete the task if it exists
            _taskCompletionSource?.SetResult(result);

            // Call the appropriate callback AFTER cleanup (user doesn't need to close dialog)
            if (result)
            {
                System.Diagnostics.Debug.WriteLine($"GameDialog: Calling OnOkClicked callback");
                OnOkClicked?.Invoke();
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"GameDialog: Calling OnCancelClicked callback");
                OnCancelClicked?.Invoke();
            }
        }

        /// <summary>
        /// Closes the dialog with OK result.
        /// </summary>
        public Task CloseWithOkAsync(bool animate = true) => CloseAsync(true, animate);

        /// <summary>
        /// Closes the dialog with Cancel result.
        /// </summary>
        public Task CloseWithCancelAsync(bool animate = true) => CloseAsync(false, animate);

        /// <summary>
        /// Plays the appearing animation when the dialog is shown.
        /// Override this method to customize the appearing animation.
        /// </summary>
        /// <param name="parent">The parent container</param>
        /// <param name="dimmer">The dimmer/background layer</param>
        /// <param name="frame">The dialog frame/content</param>
        /// <param name="cancellationToken">Cancellation token for the animation</param>
        protected virtual async Task PlayAppearingAnimation(SkiaLayout parent, SkiaLayout dimmer, SkiaLayout frame,
            CancellationToken cancellationToken = default)
        {
            // Check template animations first
            if (_template?.Animations?.FrameAppearing != null && _template?.Animations?.BackdropAppearing != null)
            {
                var tasks = new List<Task>();

                if (dimmer != null && _template.Animations.BackdropAppearing != null)
                {
                    tasks.Add(_template.Animations.BackdropAppearing(dimmer, cancellationToken));
                }

                if (frame != null && _template.Animations.FrameAppearing != null)
                {
                    tasks.Add(_template.Animations.FrameAppearing(frame, cancellationToken));
                }

                await Task.WhenAll(tasks);
            }
            // Fallback to legacy animation system
            else if (DefaultAppearingAnimation != null)
            {
                await DefaultAppearingAnimation(parent, dimmer, frame, cancellationToken);
            }
            else
            {
                // Default appearing animation: dimmer fades in, frame scales up with fade
                var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

                var tasks = new List<Task>();

                // Dimmer: Only fade in
                if (dimmer != null)
                {
                    dimmer.Opacity = 0.0;
                    tasks.Add(dimmer.FadeToAsync(1.0, 150, Easing.Linear, cancelSource));
                }

                foreach (var child in frame.Children)
                {
                    child.Scale = 0.8;
                    var frameScaleTask = child.ScaleToAsync(1.0, 1.0, 100, Easing.CubicOut, cancelSource);
                    tasks.Add(frameScaleTask);

                    if (child is not SkiaBackdrop)
                    {
                        child.Opacity = 0.0;
                        var frameFadeTask = child.FadeToAsync(1.0, 75, Easing.Linear, cancelSource);
                        tasks.Add(frameFadeTask);
                    }
                }

                // Frame: Scale up from center with fade in
                //frame.Scale = 0.8;
                //frame.Opacity = 0.0;
                //var frameScaleTask = frame.ScaleToAsync(1.0, 1.0, 5250, Easing.CubicOut, cancelSource);
                //var frameFadeTask = frame.FadeToAsync(1.0, 5200, Easing.Linear, cancelSource);

                await Task.WhenAll(tasks);
            }
        }

        /// <summary>
        /// Plays the disappearing animation when the dialog is closed.
        /// Override this method to customize the disappearing animation.
        /// </summary>
        /// <param name="parent">The parent container</param>
        /// <param name="dimmer">The dimmer/background layer</param>
        /// <param name="frame">The dialog frame/content</param>
        /// <param name="cancellationToken">Cancellation token for the animation</param>
        protected virtual async Task PlayDisappearingAnimation(SkiaLayout parent, SkiaLayout dimmer, SkiaLayout frame,
            CancellationToken cancellationToken = default)
        {
            // Check template animations first
            if (_template?.Animations?.FrameDisappearing != null && _template?.Animations?.BackdropDisappearing != null)
            {
                var tasks = new List<Task>();

                if (dimmer != null && _template.Animations.BackdropDisappearing != null)
                {
                    tasks.Add(_template.Animations.BackdropDisappearing(dimmer, cancellationToken));
                }

                if (frame != null && _template.Animations.FrameDisappearing != null)
                {
                    tasks.Add(_template.Animations.FrameDisappearing(frame, cancellationToken));
                }

                await Task.WhenAll(tasks);
            }
            // Fallback to legacy animation system
            else if (DefaultDisappearingAnimation != null)
            {
                await DefaultDisappearingAnimation(parent, dimmer, frame, cancellationToken);
            }
            else
            {
                // Default disappearing animation: dimmer fades out, frame scales down with fade
                var cancelSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

                var tasks = new List<Task>();


                // Dimmer: Only fade out
                if (dimmer != null)
                {
                    tasks.Add(dimmer.FadeToAsync(0.0, 150, Easing.Linear, cancelSource));
                }

                // Frame: Scale down with fade out
                tasks.Add(frame.ScaleToAsync(0.8, 0.8, 150, Easing.CubicIn, cancelSource));
                tasks.Add(frame.FadeToAsync(0.0, 150, Easing.Linear, cancelSource));

                await Task.WhenAll(tasks);
            }
        }

        /// <summary>
        /// Convenience method that calls PlayAppearingAnimation with proper parameters.
        /// </summary>
        private async Task PlayAppearingAnimation(CancellationToken cancellationToken = default)
        {
            await PlayAppearingAnimation(_parentContainer, _dimmerLayer, _dialogFrame, cancellationToken);
        }

        /// <summary>
        /// Convenience method that calls PlayDisappearingAnimation with proper parameters.
        /// </summary>
        private async Task PlayDisappearingAnimation(CancellationToken cancellationToken = default)
        {
            await PlayDisappearingAnimation(_parentContainer, _dimmerLayer, _dialogFrame, cancellationToken);
        }

        #region Navigation Stack Methods

        /// <summary>
        /// Pushes a dialog onto the navigation stack (equivalent to Show but adds to stack).
        /// </summary>
        public static void Push(SkiaLayout parentContainer, SkiaControl content, string ok = null, string cancel = null,
            Action onOk = null, Action onCancel = null, DialogTemplate template = null)
        {
            var dialog = new GameDialog(content, ok, cancel, parentContainer, template);

            // Add to navigation stack
            if (!_navigationStacks.ContainsKey(parentContainer))
            {
                _navigationStacks[parentContainer] = new Stack<GameDialog>();
            }

            _navigationStacks[parentContainer].Push(dialog);

            dialog.OnOkClicked = onOk;
            dialog.OnCancelClicked = onCancel;

            parentContainer.AddSubView(dialog);

            // Play appearing animation
            _ = dialog.PlayAppearingAnimation();
        }

        /// <summary>
        /// Pops the topmost dialog from the navigation stack.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task Pop(SkiaLayout parentContainer, bool animate = true)
        {
            if (!_navigationStacks.ContainsKey(parentContainer) || _navigationStacks[parentContainer].Count == 0)
                return;

            var dialog = _navigationStacks[parentContainer].Peek();
            await dialog.CloseAsync(false, animate); // No result, just close
        }

        /// <summary>
        /// Pops the topmost dialog asynchronously (waits for animation to finish).
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        /// <returns>Task that completes when the dialog is closed</returns>
        public static async Task PopAsync(SkiaLayout parentContainer, bool animate = true)
        {
            await Pop(parentContainer, animate);
        }

        /// <summary>
        /// Pops all dialogs from the navigation stack.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task PopAll(SkiaLayout parentContainer, bool animate = true)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return;

            var stack = _navigationStacks[parentContainer];
            var tasks = new List<Task>();

            while (stack.Count > 0)
            {
                var dialog = stack.Pop();
                tasks.Add(dialog.CloseAsync(false, animate));
            }

            await Task.WhenAll(tasks);
        }

        /// <summary>
        /// Pops all dialogs from the navigation stack and returns when all are closed.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <param name="animate">Whether to animate the closing</param>
        public static async Task PopAllAsync(SkiaLayout parentContainer, bool animate = true)
        {
            await PopAll(parentContainer, animate);
        }

        /// <summary>
        /// Gets the number of dialogs in the navigation stack for the specified container.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <returns>Number of dialogs in the stack</returns>
        public static int GetStackCount(SkiaLayout parentContainer)
        {
            return _navigationStacks.ContainsKey(parentContainer) ? _navigationStacks[parentContainer].Count : 0;
        }

        /// <summary>
        /// Checks if any dialog is currently open (visible) for the specified container.
        /// </summary>
        /// <param name="parentContainer">The parent container</param>
        /// <returns>True if any dialog is currently open, false otherwise</returns>
        public static bool IsAnyDialogOpen(SkiaLayout parentContainer)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return false;

            var stack = _navigationStacks[parentContainer];
            if (stack.Count == 0)
                return false;

            return true;
        }

        #endregion

        public static GameDialog GetTopDialog(SkiaLayout parentContainer)
        {
            if (!_navigationStacks.ContainsKey(parentContainer))
                return null;

            var stack = _navigationStacks[parentContainer];
            if (stack.Count == 0)
                return null;

            return stack.Last();
        }

        protected virtual void SetupDialogWithTemplate()
        {
            // Create backdrop if template provides one
            if (_template.CreateBackdrop != null)
            {
                _dimmerLayer = _template.CreateBackdrop();
            }

            // Create dialog frame using template - pass dialog instance for callbacks
            if (_template.CreateDialogFrame != null)
            {
                _dialogFrame = _template.CreateDialogFrame(this, Content, _okText, _cancelText);
            }
            else
            {
                throw new InvalidOperationException("Template must provide CreateDialogFrame");
            }

            // Add children
            var children = new List<SkiaControl>();
            if (_dimmerLayer != null)
            {
                children.Add(_dimmerLayer);
            }

            children.Add(_dialogFrame);

            Children = children;
        }

        /// <summary>
        /// Public method for templates to close dialog with OK result
        /// </summary>
        public async Task CloseWithOkAsync()
        {
            await CloseWithOkAsync(animate: true);
        }

        /// <summary>
        /// Public method for templates to close dialog with Cancel result
        /// </summary>
        public async Task CloseWithCancelAsync()
        {
            await CloseWithCancelAsync(animate: true);
        }

        /// <summary>
        /// Finds all child views that implement IGameKeyHandler interface in the view hierarchy
        /// </summary>
        /// <returns>List of all found views implementing IGameKeyHandler</returns>
        public List<IGameKeyHandler> FindAllKeyHandlers(SkiaControl parent)
        {
            var handlers = new List<IGameKeyHandler>();

            if (parent is IGameKeyHandler selfHandler)
                handlers.Add(selfHandler);

            foreach (var view in parent.Views)
            {
                if (view is IGameKeyHandler handler)
                    handlers.Add(handler);

                // Manually recurse through child's Views
                var childHandlers = GetKeyHandlersFromViews(view.Views);
                handlers.AddRange(childHandlers);
            }

            return handlers;
        }

        private List<IGameKeyHandler> GetKeyHandlersFromViews(IEnumerable<SkiaControl> views)
        {
            var handlers = new List<IGameKeyHandler>();

            foreach (var view in views)
            {
                if (view is IGameKeyHandler handler)
                    handlers.Add(handler);

                var childHandlers = GetKeyHandlersFromViews(view.Views);
                handlers.AddRange(childHandlers);
            }

            return handlers;
        }

        protected void SetupDialog()
        {
            // Main dialog container
            HorizontalOptions = LayoutOptions.Fill;
            VerticalOptions = LayoutOptions.Fill;
            ZIndex = 200;

            // Always use template system (default is Game template which recreates original design)
            SetupDialogWithTemplate();

            var frameHandlers = FindAllKeyHandlers(_dialogFrame);
            foreach (var handler in frameHandlers)
            {
                KeyHandlers.Add(handler);
            }

            SelectionIndicator = new SkiaShape()
            {
                StrokeColor = Colors.Gold,
                StrokeWidth = 3,
                UseCache = SkiaCacheType.Operations,
            };
        }


        private List<IGameKeyHandler> KeyHandlers = new();
        private IGameKeyHandler SelectedKeyHandler;
        SKRect SelectionIndicatorRect = SKRect.Empty;
        SkiaShape SelectionIndicator;

        // Time-delay filtering
        private int DirectionalActionDelayMs = 200;
        private long _lastDirectionalActionTime = 0;

        private int ActionDelayMs = 750;
        private long _lastActionTime = 0;

        public bool HandleGameKey(GameKey key)
        {
            if (key == GameKey.Fire)
            {
                if (CanProcessAction())
                {
                    if (SelectedKeyHandler == null && KeyHandlers.Count > 1)
                    {
                        SelectNextHandler();
                        UpdateLastDirectionalActionTime();
                    }
                    else
                    {
                        if (SelectedKeyHandler != null)
                        {
                            var handled = SelectedKeyHandler.HandleGameKey(key);
                            UpdateLastActionTime();
                            return true;
                        }

                        //tap single default button/control
                        if (OnCancelClicked != null)
                        {
                            OnOkClicked?.Invoke();
                        }
                        else
                        {
                            _ = CloseAsync(true, true);
                        }
                        UpdateLastActionTime();
                    }
                }

                return true;
            }

            if (KeyHandlers.Count > 0)
            {
                if (key == GameKey.Left || key == GameKey.Up)
                {
                    if (CanProcessDirectionalAction())
                    {
                        SelectPreviousHandler();
                        UpdateLastDirectionalActionTime();
                    }
                }
                else if (key == GameKey.Right || key == GameKey.Down)
                {
                    if (CanProcessDirectionalAction())
                    {
                        SelectNextHandler();
                        UpdateLastDirectionalActionTime();
                    }
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if enough time has passed since the last action to allow processing a new one
        /// </summary>
        private bool CanProcessAction()
        {
            var currentTime = Environment.TickCount64;
            return currentTime - _lastActionTime >= ActionDelayMs;
        }

        /// <summary>
        /// Updates the timestamp of the last action
        /// </summary>
        private void UpdateLastActionTime()
        {
            _lastActionTime = Environment.TickCount64;
        }

        /// <summary>
        /// Checks if enough time has passed since the last directional action to allow processing a new one
        /// </summary>
        private bool CanProcessDirectionalAction()
        {
            var currentTime = Environment.TickCount64;
            return currentTime - _lastDirectionalActionTime >= DirectionalActionDelayMs;
        }

        /// <summary>
        /// Updates the timestamp of the last directional action
        /// </summary>
        private void UpdateLastDirectionalActionTime()
        {
            _lastDirectionalActionTime = Environment.TickCount64;
        }

        void SelectGameKeyHandler(IGameKeyHandler selected)
        {
            SelectionIndicatorRect = SKRect.Empty;
            if (selected != null)
            {
                SelectedKeyHandler = selected;
                if (SelectedKeyHandler is SkiaControl control)
                {
                    var expand = control.DrawingRect;
                    var ex = 3 * RenderingScale;
                    expand.Inflate(ex, ex);
                    SelectionIndicatorRect = expand;
                    var width = SelectionIndicatorRect.Width;
                    var height = SelectionIndicatorRect.Height;
                    SelectionIndicator.WidthRequest = width;
                    SelectionIndicator.HeightRequest = height;
                }
            }
        }

        protected override void Paint(DrawingContext ctx)
        {
            base.Paint(ctx);
            if (SelectionIndicatorRect != SKRect.Empty)
            {
                if (SelectionIndicator.NeedMeasure)
                {
                    SelectionIndicator.Measure((float)SelectionIndicator.WidthRequest,
                        (float)SelectionIndicator.HeightRequest, RenderingScale);
                    SelectionIndicator.Arrange(SelectionIndicatorRect, (float)SelectionIndicator.WidthRequest,
                        (float)SelectionIndicator.HeightRequest, RenderingScale);
                }

                SelectionIndicator.Render(ctx.WithDestination(SelectionIndicatorRect));
            }
        }

        private void SelectPreviousHandler()
        {
            if (KeyHandlers.Count == 0) return;
            int currentIndex = SelectedKeyHandler != null ? KeyHandlers.IndexOf(SelectedKeyHandler) : 0;
            int newIndex = currentIndex - 1;
            if (newIndex < 0)
                newIndex = KeyHandlers.Count - 1;
            SelectGameKeyHandler(KeyHandlers[newIndex]);
        }

        private void SelectNextHandler()
        {
            if (KeyHandlers.Count == 0) return;
            int currentIndex = SelectedKeyHandler != null ? KeyHandlers.IndexOf(SelectedKeyHandler) : -1;
            int newIndex = currentIndex + 1;
            if (newIndex >= KeyHandlers.Count)
                newIndex = 0;
            SelectGameKeyHandler(KeyHandlers[newIndex]);
        }
    }
}

--- C:\code\DrawnUi\src\Game\Input\EventType.cs ---
namespace Breakout.Game.Input;

public enum EventType
{
    KeyDown,
    KeyUp,
    Mouse,
    Joystick
}

--- C:\code\DrawnUi\src\Game\Input\GameControllerInput.cs ---
using Orbit.Input;

namespace Breakout.Game.Input;

public class GameControllerInput : IInputController
{
    private readonly BreakoutGame _game;
    private Orbit.Input.GameController _gameController;

    public GameControllerInput(BreakoutGame game)
    {
        _game = game;

        GameControllerManager.Current.GameControllerConnected += OnGameControllerConnected;

        _ = GameControllerManager.Current.StartDiscovery();
    }

    private void OnGameControllerConnected(object sender, GameControllerConnectedEventArgs args)
    {
        _gameController = args.GameController;
    }

    public void ProcessState()
    {
        if (_gameController is null)
        {
            return;
        }

        if (_gameController.LeftStick.XAxis.Value < -0.001f ||
            _gameController.Dpad.XAxis.Value < -0.001f)
        {
            _game.SendKey(GameKey.Left);
        }
        else if (_gameController.LeftStick.XAxis.Value > 0.001f ||
                 _gameController.Dpad.XAxis.Value > 0.001f)
        {
            _game.SendKey(GameKey.Right);
        }
        else
        {
            _game.SendKey(GameKey.Stop);
        }

        if (_gameController.LeftStick.YAxis.Value < -0.001f ||
            _gameController.Dpad.YAxis.Value > 0.001f)
        {
            _game.SendKey(GameKey.Up);
        }
        else if (_gameController.LeftStick.YAxis.Value > 0.001f ||
                 _gameController.Dpad.YAxis.Value < -0.001f)
        {
            _game.SendKey(GameKey.Down);
        }

        if (_gameController.South.Value)
        {
            _game.SendKey(GameKey.Fire);
        }

        if (_gameController.Pause.Value)
        {
            _game.SendKey(GameKey.Pause);
        }
    }

    public void Dispose()
    {
        _game?.Dispose();

        GameControllerManager.Current.GameControllerConnected -= OnGameControllerConnected;
    }
}

--- C:\code\DrawnUi\src\Game\Input\GameKey.cs ---
namespace Breakout.Game.Input;

/// <summary>
/// Game-dependent action keys
/// </summary>
public enum GameKey
{
    Unset,

    Demo,

    /// <summary>
    /// Will open options
    /// </summary>
    Pause,

    Fire,

    Left,
    Right,
    Up,
    Down,

    Stop,
}

--- C:\code\DrawnUi\src\Game\Input\HudController.cs ---
using System.Diagnostics;
using AppoMobi.Maui.Gestures;
using SkiaSharp;

namespace Breakout.Game.Input;

public class HudController : IInputController
{
    private readonly BreakoutGame _game;
    private bool _leftPressed = false;
    private bool _rightPressed = false;
    private Dictionary<long, bool> _touchSides = new Dictionary<long, bool>(); // true = left, false = right

    /// <summary>
    /// Initializes a new instance of the VirtualController class
    /// </summary>
    /// <param name="game">The breakout game instance</param>
    public HudController(BreakoutGame game)
    {
        _game = game;
    }

    /// <summary>
    /// Processes touch gestures and updates internal key state
    /// </summary>
    /// <param name="args">The gesture parameters</param>
    /// <param name="apply">The gesture processing info</param>
    /// <param name="hitbox">The hit box area for touch detection</param>
    /// <param name="scale">The rendering scale factor</param>
    /// <returns>True if gesture was consumed, false otherwise</returns>
    public bool ProcessGestures(SkiaGesturesParameters args, GestureEventProcessingInfo apply, SKRect hitbox,
        float scale)
    {
        if (!_game.InputPressMode)
            return false;

        var point = new SKPoint(args.Event.Location.X / scale, args.Event.Location.Y / scale);

        if (!hitbox.Contains(point))
            return false;

        bool isLeftSide = point.X < hitbox.Left + hitbox.Width / 2;

        if (args.Type == TouchActionResult.Down)
        {
            _touchSides[args.Event.Id] = isLeftSide;

            if (isLeftSide)
            {
                Debug.WriteLine("DOWN LEFT");
                _leftPressed = true;
            }
            else
            {
                Debug.WriteLine("DOWN RIGHT");
                _rightPressed = true;
            }

            return true;
        }
        else if (args.Type == TouchActionResult.Up)
        {
            if (_touchSides.TryGetValue(args.Event.Id, out bool wasLeftSide))
            {
                _touchSides.Remove(args.Event.Id);

                if (wasLeftSide)
                {
                    Debug.WriteLine("UP LEFT");
                    _leftPressed = false;
                }
                else
                {
                    Debug.WriteLine("UP RIGHT");
                    _rightPressed = false;
                }
            }

            if (!_leftPressed && !_rightPressed)
            {
                _game.SendKey(GameKey.Stop);
            }

            return true;
        }

        return false;
    }

    /// <summary>
    /// Called every frame to apply continuous key input based on current state
    /// </summary>
    public void ProcessState()
    {
        if (!_game.InputPressMode)
            return;

        if (_rightPressed && _leftPressed)
        {
            // Both pressed - prioritize the most recent one
            // For now, right takes priority when both are pressed
            _game.SendKey(GameKey.Right);
        }
        else if (_leftPressed)
        {
            _game.SendKey(GameKey.Left);
        }
        else if (_rightPressed)
        {
            _game.SendKey(GameKey.Right);
        }
    }

    /// <summary>
    /// Resets the virtual controller state
    /// </summary>
    public void Reset()
    {
        _leftPressed = false;
        _rightPressed = false;
        _touchSides.Clear();
    }

    public void Dispose()
    {

    }
}

--- C:\code\DrawnUi\src\Game\Input\IGameKeyHandler.cs ---
namespace Breakout.Game.Input
{
    /// <summary>
    /// Interface for controls that can handle GameKey input (like dialogs)
    /// </summary>
    public interface IGameKeyHandler
    {
        /// <summary>
        /// Process a game key input. Return true if handled, false to pass through.
        /// </summary>
        bool HandleGameKey(GameKey key);
    }
}

--- C:\code\DrawnUi\src\Game\Input\IInputController.cs ---
namespace Breakout.Game.Input;

public interface IInputController : IDisposable
{
    void ProcessState();
}

--- C:\code\DrawnUi\src\Game\Internals\CollisionFace.cs ---
namespace Breakout.Game;

/// <summary>
/// Enum representing the face of collision
/// </summary>
public enum CollisionFace
{
    None,
    Top,
    Bottom,
    Left,
    Right
}

public class Area : SkiaLayout
{

}

public class ScreenSplash : AppScreen
{

}

public class AppScreen : SkiaLayout
{

}

--- C:\code\DrawnUi\src\Game\Internals\GameState.cs ---
using SkiaSharp;

namespace Breakout.Game;

public enum GameState
{
    Unset,

    /// <summary>
    /// Welcome screen presented
    /// </summary>
    Ready,

    /// <summary>
    /// Game loop is running
    /// </summary>
    Playing,

    Paused,

    /// <summary>
    /// Game ended
    /// </summary>
    Ended,

    LevelComplete,

    DemoPlay
}


--- C:\code\DrawnUi\src\Game\Internals\IReusableSprite.cs ---
namespace Breakout.Game;

/// <summary>
/// Resusable model, to avoid GC
/// </summary>
public interface IReusableSprite
{
    bool IsActive { get; set; }

    Guid Uid { get; }

    void ResetAnimationState();

    Task AnimateDisappearing();
}

--- C:\code\DrawnUi\src\Game\Internals\IWithHitBox.cs ---
using SkiaSharp;

namespace Breakout.Game;

public interface IWithHitBox
{
    /// <summary>
    /// Calculate hitbox etc for the current frame
    /// </summary>
    /// <param name="time"></param>
    void UpdateState(long time, bool forceRecalculate=false);

    /// <summary>
    /// Precalculated
    /// </summary>
    SKRect HitBox { get; }
}

--- C:\code\DrawnUi\src\Game\Internals\MauiGameExtensions.cs ---
using SkiaSharp;

namespace Breakout.Game;

public static class MauiGameExtensions
{

    public static SKRect GetHitBox(this SkiaControl sprite)
    {
        if (sprite is SkiaControl control)
        {
            //real position even below/inside a cached layer
            //var position = control.GetFuturePositionOnCanvasInPoints();
            if (control.VisualLayer == null)
            {
                return SKRect.Empty;
            }

            //we can get position from layer as we do not ache above
            var position = control.VisualLayer.HitBoxWithTransforms.Units.Location;

            var hitBox = new SKRect(position.X, position.Y,
                (float)(position.X + control.Width), (float)(position.Y + control.Height));
            return hitBox;
        }

        return SKRect.Empty;
    }

    /// <summary>
    /// Detects intersection between two rectangles and returns the overlap area
    /// </summary>
    /// <param name="source">Source rectangle</param>
    /// <param name="target">Target rectangle</param>
    /// <param name="overlap">Output overlap rectangle</param>
    /// <returns>True if rectangles intersect, false otherwise</returns>
    public static bool IntersectsWith(this SKRect source, SKRect target, out SKRect overlap)
    {
        // Initialize overlap with empty rect
        overlap = SKRect.Empty;

        // Calculate potential overlap dimensions
        float left = Math.Max(source.Left, target.Left);
        float right = Math.Min(source.Right, target.Right);
        float top = Math.Max(source.Top, target.Top);
        float bottom = Math.Min(source.Bottom, target.Bottom);

        // Check if there's actually an overlap
        if (right <= left || bottom <= top)
        {
            return false;
        }

        // Create overlap rectangle relative to target position
        overlap = new SKRect(
            left - target.Left, // Normalize to target's left edge
            top - target.Top, // Normalize to target's top edge
            right - target.Left, // Normalize to target's left edge
            bottom - target.Top // Normalize to target's top edge
        );

        return true;
    }


}

--- C:\code\DrawnUi\src\Game\Internals\RaycastCollision.cs ---
using System.Numerics;
using SkiaSharp;

namespace Breakout.Game
{
    /// <summary>
    /// Implements raycasting collision detection for more accurate collision handling
    /// </summary>
    public static class RaycastCollision
    {
        // Minimum threshold for direction components to avoid division by very small numbers
        private const float MIN_DIRECTION_THRESHOLD = 0.0001f;

        /// <summary>
        /// Represents the result of a raycast collision
        /// </summary>
        public struct RaycastHit
        {
            public bool Collided { get; set; }
            public float Distance { get; set; }
            public Vector2 Point { get; set; }
            public Vector2 Normal { get; set; }
            public IWithHitBox Target { get; set; }
            public CollisionFace Face { get; set; }

            public static RaycastHit None => new RaycastHit { Collided = false };
        }

        /// <summary>
        /// Performs a raycast from the ball's current position in its movement direction
        /// </summary>
        /// <param name="origin">Current position of the ball</param>
        /// <param name="direction">Direction vector of ball's movement</param>
        /// <param name="distance">Distance to check for collision (based on ball's speed and deltaTime)</param>
        /// <param name="radius">Radius of the ball</param>
        /// <param name="targets">Collection of collision targets</param>
        /// <returns>Information about the collision if it occurred</returns>
        public static RaycastHit CastRay(Vector2 origin, Vector2 direction, float distance, float radius,
            IEnumerable<IWithHitBox> targets)
        {
            var closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            // Create multiple raycasts to simulate the ball's width
            // Main center ray
            var centerHit = CastSingleRay(origin, direction, distance, radius, targets);
            if (centerHit.Collided && centerHit.Distance < closestHit.Distance)
            {
                closestHit = centerHit;
            }

            // Calculate perpendicular vector to the direction for side rays
            Vector2 perpendicular = new Vector2(-direction.Y, direction.X);
            perpendicular = Vector2.Normalize(perpendicular) * radius * 0.8f; // 80% of radius for the side rays

            // Left side ray
            Vector2 leftOrigin = origin + perpendicular;
            var leftHit = CastSingleRay(leftOrigin, direction, distance, radius * 0.2f, targets);
            if (leftHit.Collided && leftHit.Distance < closestHit.Distance)
            {
                closestHit = leftHit;
            }

            // Right side ray
            Vector2 rightOrigin = origin - perpendicular;
            var rightHit = CastSingleRay(rightOrigin, direction, distance, radius * 0.2f, targets);
            if (rightHit.Collided && rightHit.Distance < closestHit.Distance)
            {
                closestHit = rightHit;
            }

            return closestHit.Collided ? closestHit : RaycastHit.None;
        }

        /// <summary>
        /// Casts a single ray against all targets
        /// </summary>
        private static RaycastHit CastSingleRay(Vector2 origin, Vector2 direction, float distance, float radius,
            IEnumerable<IWithHitBox> targets)
        {
            var closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            foreach (var target in targets)
            {
                if (target is BallSprite)
                    continue;

                var hit = TestRaycastAgainstRect(origin, direction, distance, radius, target.HitBox, target);

                if (hit.Collided && hit.Distance < closestHit.Distance)
                {
                    closestHit = hit;
                }
            }

            return closestHit.Collided ? closestHit : RaycastHit.None;
        }

        /// <summary>
        /// Tests if a ray collides with a rectangle
        /// </summary>
        private static RaycastHit TestRaycastAgainstRect(Vector2 origin, Vector2 direction, float maxDistance,
            float radius, SKRect rect, IWithHitBox target)
        {
            // Make sure we're using the correct HitBox from the target
            rect = target.HitBox;

            // Expand the rect by the ball's radius to account for the ball's size
            var expandedRect = new SKRect(
                rect.Left - radius,
                rect.Top - radius,
                rect.Right + radius,
                rect.Bottom + radius
            );

            // Points representing the expanded rectangle
            Vector2 rectMin = new Vector2(expandedRect.Left, expandedRect.Top);
            Vector2 rectMax = new Vector2(expandedRect.Right, expandedRect.Bottom);

            // Check if the origin is inside the expanded rectangle - this would cause negative distance
            bool originInsideRect = origin.X >= rectMin.X && origin.X <= rectMax.X &&
                                   origin.Y >= rectMin.Y && origin.Y <= rectMax.Y;

            if (originInsideRect)
            {
                // Return no collision if we're already inside - prevents the stuck bug
                return RaycastHit.None;
            }

            // Calculate distance to intersection points
            float tNear = float.NegativeInfinity;
            float tFar = float.PositiveInfinity;

            // Normal of the hit face
            Vector2 hitNormal = Vector2.Zero;
            CollisionFace hitFace = CollisionFace.None;

            // Check X axis intersection - FIXED threshold for shallow angles
            if (Math.Abs(direction.X) < MIN_DIRECTION_THRESHOLD)
            {
                // Ray is nearly parallel to X axis
                if (origin.X < rectMin.X || origin.X > rectMax.X)
                    return RaycastHit.None;
            }
            else
            {
                float tx1 = (rectMin.X - origin.X) / direction.X;
                float tx2 = (rectMax.X - origin.X) / direction.X;

                if (tx1 > tx2)
                {
                    float temp = tx1;
                    tx1 = tx2;
                    tx2 = temp;
                }

                tNear = Math.Max(tNear, tx1);
                tFar = Math.Min(tFar, tx2);

                if (tNear == tx1)
                {
                    hitNormal = new Vector2(-1, 0);
                    hitFace = CollisionFace.Left;
                }
                else if (tNear == tx2)
                {
                    hitNormal = new Vector2(1, 0);
                    hitFace = CollisionFace.Right;
                }

                if (tNear > tFar || tFar < 0)
                    return RaycastHit.None;
            }

            // Check Y axis intersection - FIXED threshold for shallow angles
            if (Math.Abs(direction.Y) < MIN_DIRECTION_THRESHOLD)
            {
                // Ray is nearly parallel to Y axis
                if (origin.Y < rectMin.Y || origin.Y > rectMax.Y)
                    return RaycastHit.None;
            }
            else
            {
                float ty1 = (rectMin.Y - origin.Y) / direction.Y;
                float ty2 = (rectMax.Y - origin.Y) / direction.Y;

                if (ty1 > ty2)
                {
                    float temp = ty1;
                    ty1 = ty2;
                    ty2 = temp;
                }

                float originalTNear = tNear;

                tNear = Math.Max(tNear, ty1);
                tFar = Math.Min(tFar, ty2);

                if (tNear > originalTNear)
                {
                    if (tNear == ty1)
                    {
                        hitNormal = new Vector2(0, -1);
                        hitFace = CollisionFace.Top;
                    }
                    else
                    {
                        hitNormal = new Vector2(0, 1);
                        hitFace = CollisionFace.Bottom;
                    }
                }

                if (tNear > tFar || tFar < 0)
                    return RaycastHit.None;
            }

            // Ensure we only detect collisions at positive distances
            if (tNear < 0 || tNear > maxDistance)
                return RaycastHit.None;

            // Calculate the hit point
            Vector2 hitPoint = origin + direction * tNear;

            return new RaycastHit
            {
                Collided = true,
                Distance = tNear,
                Point = hitPoint,
                Normal = hitNormal,
                Target = target,
                Face = hitFace
            };
        }

        /// <summary>
        /// Checks if a moving object (ball) would collide with walls using proper distance calculations
        /// </summary>
        public static RaycastHit CheckWallCollision(Vector2 position, Vector2 direction, float radius,
            float maxDistance, SKRect gameField)
        {
            RaycastHit closestHit = RaycastHit.None;
            closestHit.Distance = float.MaxValue;

            // Normalize direction to unit vector for distance calculations
            Vector2 normalizedDirection = Vector2.Normalize(direction);

            // Left wall collision
            if (normalizedDirection.X < -MIN_DIRECTION_THRESHOLD) // Moving left
            {
                float wallPosition = gameField.Left + radius; // Ball edge should not go below this X position
                float distanceToWall = position.X - wallPosition;

                if (distanceToWall > 0) // Not already past the wall
                {
                    // Calculate actual distance along the ray to reach the wall
                    float rayDistance = distanceToWall / -normalizedDirection.X;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        // Verify Y coordinate is within bounds
                        if (hitPoint.Y >= gameField.Top + radius && hitPoint.Y <= gameField.Bottom - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(1, 0);
                            closestHit.Face = CollisionFace.Left;
                            closestHit.Point = new Vector2(gameField.Left, hitPoint.Y);
                        }
                    }
                }
            }

            // Right wall collision
            if (normalizedDirection.X > MIN_DIRECTION_THRESHOLD) // Moving right
            {
                float wallPosition = gameField.Right - radius; // Ball edge should not go above this X position
                float distanceToWall = wallPosition - position.X;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / normalizedDirection.X;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.Y >= gameField.Top + radius && hitPoint.Y <= gameField.Bottom - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(-1, 0);
                            closestHit.Face = CollisionFace.Right;
                            closestHit.Point = new Vector2(gameField.Right, hitPoint.Y);
                        }
                    }
                }
            }

            // Top wall collision (ball hits top of screen - should bounce)
            if (normalizedDirection.Y < -MIN_DIRECTION_THRESHOLD) // Moving up
            {
                float wallPosition = gameField.Top + radius; // Ball edge should not go above this Y position
                float distanceToWall = position.Y - wallPosition;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / -normalizedDirection.Y;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.X >= gameField.Left + radius && hitPoint.X <= gameField.Right - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(0, 1);
                            closestHit.Face = CollisionFace.Bottom; // Ball hits bottom face of top wall
                            closestHit.Point = new Vector2(hitPoint.X, gameField.Top);
                        }
                    }
                }
            }

            // Bottom wall collision (ball hits bottom of screen - should lose life)
            if (normalizedDirection.Y > MIN_DIRECTION_THRESHOLD) // Moving down
            {
                float wallPosition = gameField.Bottom - radius; // Ball edge should not go below this Y position
                float distanceToWall = wallPosition - position.Y;

                if (distanceToWall > 0) // Not already past the wall
                {
                    float rayDistance = distanceToWall / normalizedDirection.Y;

                    if (rayDistance >= 0 && rayDistance <= maxDistance && rayDistance < closestHit.Distance)
                    {
                        Vector2 hitPoint = position + normalizedDirection * rayDistance;

                        if (hitPoint.X >= gameField.Left + radius && hitPoint.X <= gameField.Right - radius)
                        {
                            closestHit.Collided = true;
                            closestHit.Distance = rayDistance;
                            closestHit.Normal = new Vector2(0, -1);
                            closestHit.Face = CollisionFace.Top; // Ball hits top face of bottom wall
                            closestHit.Point = new Vector2(hitPoint.X, gameField.Bottom);
                        }
                    }
                }
            }

            return closestHit;
        }

        /// <summary>
        /// Reflects a vector off a surface with the given normal
        /// </summary>
        public static Vector2 Reflect(Vector2 direction, Vector2 normal)
        {
            return direction - 2 * Vector2.Dot(direction, normal) * normal;
        }
    }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPosition.cs ---
namespace Breakout.Game;

/// <summary>
/// Represents a position for a brick in the layout
/// </summary>
public class BrickPosition
{
    /// <summary>
    /// Column index
    /// </summary>
    public float Column { get; set; }

    /// <summary>
    /// Row index
    /// </summary>
    public float Row { get; set; }

    /// <summary>
    /// Preset ID to use for this brick
    /// </summary>
    public string PresetId { get; set; }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPreset.cs ---
namespace Breakout.Game
{
    /// <summary>
    /// Defines the properties of a brick preset
    /// </summary>
    public class BrickPreset
    {
        /// <summary>
        /// Unique identifier for the preset
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Visual color of the brick
        /// </summary>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Additional hits required beyond the first hit
        /// </summary>
        public int SupplementaryHitsToDestroy { get; set; }

        /// <summary>
        /// Whether the brick cannot be destroyed
        /// </summary>
        public bool Undestructible { get; set; }

        /// <summary>
        /// Score value when destroyed
        /// </summary>
        public int ScoreValue { get; set; }

        /// <summary>
        /// Human-readable description
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Base probability of appearance
        /// </summary>
        public float Probability { get; set; }

        /// <summary>
        /// Whether this brick type has special effects
        /// </summary>
        public bool IsSpecial { get; set; }

        /// <summary>
        /// Type of power-up this brick might drop
        /// </summary>
        public PowerupType PowerUpType { get; set; }
    }
}

--- C:\code\DrawnUi\src\Game\Levels\BrickPresets.cs ---
namespace Breakout.Game;

/// <summary>
/// Manages brick presets and their applications
/// </summary>
public static class BrickPresets
{
    /// <summary>
    /// Collection of all available brick presets
    /// </summary>
    public static Dictionary<string, BrickPreset> Presets;

    /// <summary>
    /// Static constructor to initialize presets
    /// </summary>
    static BrickPresets()
    {
        InitializePresets();
    }

    /// <summary>
    /// Gets all available presets
    /// </summary>
    public static IReadOnlyDictionary<string, BrickPreset> All => Presets;

    /// <summary>
    /// Initializes the standard brick presets
    /// </summary>
    private static void InitializePresets()
    {
        Presets = new Dictionary<string, BrickPreset>
        {
            // Standard bricks (1 hit)
            { "Standard_Red", new BrickPreset {
                Id = "Standard_Red",
                BackgroundColor = Colors.Magenta,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 50,
                Description = "Standard brick, 1 hit",
                Probability = 0.2f
            }},

            { "Standard_Blue", new BrickPreset {
                    Id = "Standard_Blue",
                    BackgroundColor = Colors.CornflowerBlue,
                    SupplementaryHitsToDestroy = 0,
                    ScoreValue = 10,
                    Description = "Standard brick, 1 hit",
                    Probability = 0.30f
            }},

            { "Standard_Green", new BrickPreset {
                Id = "Standard_Green",
                BackgroundColor = Colors.HotPink,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 10,
                Description = "Standard brick, 1 hit",
                Probability = 0.30f
            }},

            { "Standard_Orange", new BrickPreset {
                Id = "Standard_Orange",
                BackgroundColor = Colors.Orange,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 15,
                Description = "Standard brick, 1 hit",
                Probability = 0.20f
            }},

            { "Standard_Yellow", new BrickPreset {
                Id = "Standard_Yellow",
                BackgroundColor = Colors.Yellow,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 15,
                Description = "Standard brick, 1 hit",
                Probability = 0.15f
            }},

            // Reinforced bricks (2 hits)
            { "Reinforced_Brown", new BrickPreset {
                Id = "Reinforced_Brown",
                BackgroundColor = Colors.GreenYellow,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 20,
                Description = "???",
                Probability = 0.15f
            }},

            // Hard bricks (3 hits)
            { "Hard_DarkGray", new BrickPreset {
                Id = "Hard_DarkGray",
                BackgroundColor = Colors.DarkGreen,
                SupplementaryHitsToDestroy = 1,
                ScoreValue = 30,
                Description = "Hard brick, 3 hits",
            }},

            // Obstacle bricks (indestructible)
            { "Obstacle_Black", new BrickPreset {
                Id = "Obstacle_Black",
                BackgroundColor = Colors.DarkGray,
                Undestructible = true,
                ScoreValue = 0,
                Description = "Indestructible obstacle",
                Probability = 0.05f
            }},

            // Special bricks (with power-ups)
            { "Special_Green", new BrickPreset {
                Id = "Special_Green",
                BackgroundColor = Colors.LightGreen,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 25,
                IsSpecial = true,
                Description = "Drops paddle expander power-up",
                Probability = 0.07f
            }},

            { "Special_Blue", new BrickPreset {
                Id = "Special_Blue",
                BackgroundColor = Colors.LightBlue,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 25,
                IsSpecial = true,
                Description = "Drops slow ball power-up",
                Probability = 0.07f
            }},

            { "Special_Purple", new BrickPreset {
                Id = "Special_Purple",
                BackgroundColor = Colors.Purple,
                SupplementaryHitsToDestroy = 0,
                ScoreValue = 35,
                IsSpecial = true,
                PowerUpType = PowerupType.ExtraLife,
                Description = "Drops extralife power-up",
                Probability = 0.04f
            }},

            { "Special_Gold", new BrickPreset {
                Id = "Special_Gold",
                BackgroundColor = Colors.Gold,
                SupplementaryHitsToDestroy = 1,
                ScoreValue = 50,
                IsSpecial = true,
                Probability = 0.02f
            }}
        };
    }

    /// <summary>
    /// Applies a preset to a brick
    /// </summary>
    public static void ApplyPreset(BrickSprite brick, string presetId)
    {
        if (brick != null)
        {
            brick.ResetAnimationState();
            if (Presets.TryGetValue(presetId, out var preset))
            {
                brick.BackgroundColor = preset.BackgroundColor;
                brick.SupplementaryHitsToDestroy = preset.SupplementaryHitsToDestroy;
                brick.Undestructible = preset.Undestructible;

                // Additional properties could be set here if BrickSprite supports them
            }
        }
    }

    /// <summary>
    /// Gets a preset by ID
    /// </summary>
    public static BrickPreset GetPreset(string presetId)
    {
        return Presets.TryGetValue(presetId, out var preset) ? preset : null;
    }

    /// <summary>
    /// Gets all presets matching a filter
    /// </summary>
    public static List<BrickPreset> GetPresets(Func<BrickPreset, bool> filter)
    {
        return Presets.Values.Where(filter).ToList();
    }
}

--- C:\code\DrawnUi\src\Game\Levels\FormationType.cs ---
namespace Breakout.Game
{
    /// <summary>
    /// Represents a formation type for brick layouts
    /// </summary>
    public enum FormationType
    {
        Grid,           // Regular grid layout
        Pyramid,        // Triangular/pyramid shape
        Arch,           // Arch or multiple arches
        Diamond,
        Zigzag,
        Organic,        // Organic/irregular shape using noise
        Wave,
        Maze,           // Maze-like corridors and walls
    }
}

--- C:\code\DrawnUi\src\Game\Levels\LevelManager.cs ---
namespace Breakout.Game
{

    /// <summary>
    /// Manages level generation and difficulty progression
    /// </summary>
    public class LevelManager
    {
        #region Properties

        /// <summary>
        /// Current game level
        /// </summary>
        public int CurrentLevel { get; private set; } = 1;

        /// <summary>
        /// Current difficulty factor
        /// </summary>
        public float Difficulty { get; private set; } = 1.0f;

        /// <summary>
        /// Number of critical paths in path-based generations
        /// </summary>
        public int MaxPathsPerLevel { get; set; } = 3;

        /// <summary>
        /// Probability of reinforced bricks appearing
        /// </summary>
        public float ReinforcedBrickProbability { get; private set; } = 0.15f;

        /// <summary>
        /// Probability of obstacle bricks appearing
        /// </summary>
        public float ObstacleBrickProbability { get; private set; } = 0.05f;

        /// <summary>
        /// Probability of special bricks appearing
        /// </summary>
        public float SpecialBrickProbability { get; private set; } = 0.1f;

        /// <summary>
        /// Default brick height
        /// </summary>
        public float DefaultBrickHeight { get; set; } = 20f;

        /// <summary>
        /// Maximum columns in layout
        /// </summary>
        public int MaxColumns { get; set; } = BreakoutGame.MAX_BRICKS_COLUMNS;

        /// <summary>
        /// Maximum rows in layout
        /// </summary>
        public int MaxRows { get; set; } = BreakoutGame.MAX_BRICKS_ROWS;

        /// <summary>
        /// Horizontal spacing between bricks
        /// </summary>
        public float HorizontalSpacing { get; set; } = 4f;

        /// <summary>
        /// Vertical spacing between bricks
        /// </summary>
        public float VerticalSpacing { get; set; } = 6f;

        /// <summary>
        /// Space from top of play area
        /// </summary>
        public float TopMargin { get; set; } = 30f;

        /// <summary>
        /// Space from sides of play area
        /// </summary>
        public float SideMargin { get; set; } = 16f;

        /// <summary>
        /// Whether to allow variable brick sizes
        /// </summary>
        public bool AllowVariableBrickSizes { get; set; } = false;

        /// <summary>
        /// Base difficulty multiplier
        /// </summary>
        public float BaseDifficulty { get; set; } = 1.0f;

        /// <summary>
        /// How much difficulty increases per level
        /// </summary>
        public float DifficultyIncreasePerLevel { get; set; } = 0.15f;

        /// <summary>
        /// Base chance for indestructible bricks
        /// </summary>
        public float IndestructibleBrickBaseChance { get; set; } = 0.02f;

        /// <summary>
        /// Increase in indestructible chance per level
        /// </summary>
        public float IndestructibleBrickLevelScaling { get; set; } = 0.01f;

        /// <summary>
        /// Minimum level for indestructible bricks to appear
        /// </summary>
        public int MinimumLevelForIndestructible { get; set; } = 3;

        /// <summary>
        /// Maximum indestructible bricks per level
        /// </summary>
        public int MaxIndestructibleBricks { get; set; } = 5;

        /// <summary>
        /// Scale of noise function for organic shapes
        /// </summary>
        public float NoiseScale { get; set; } = 0.1f;

        /// <summary>
        /// Threshold for brick placement in noise-based generation
        /// </summary>
        public float NoiseThreshold { get; set; } = 0.5f;

        /// <summary>
        /// Smoothing iterations for organic shapes
        /// </summary>
        public int SmoothingPasses { get; set; } = 2;

        /// <summary>
        /// Random number generator
        /// </summary>
        private Random _random = new Random();

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new level manager
        /// </summary>
        public LevelManager()
        {
            // Default constructor
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Counts the number of breakable bricks in the generated level
        /// </summary>
        /// <param name="positions">The list of brick positions generated for the level</param>
        /// <returns>The number of bricks that can be destroyed</returns>
        public int CountBreakableBricks(List<BrickPosition> positions)
        {
            int breakableBricks = 0;

            foreach (var position in positions)
            {
                if (!string.IsNullOrEmpty(position.PresetId))
                {
                    var preset = BrickPresets.GetPreset(position.PresetId);

                    // Count as breakable if not undestructible and not special
                    if (preset != null && !preset.Undestructible)
                    {
                        breakableBricks++;
                    }
                }
            }

            return breakableBricks;
        }

        /// <summary>
        /// Generates a level with specified parameters
        /// </summary>
        public List<BrickPosition> GenerateLevel(
            int level,
            float availableWidth,
            float availableHeight,
            FormationType formation = FormationType.Grid,
            List<string> allowedPresets = null,
            Dictionary<string, float> presetProbabilityOverrides = null)
        {
            CurrentLevel = level;
            Difficulty = CalculateLevelDifficulty(level);

            // Calculate columns and rows based on level and available space
            int columns = DetermineColumns(level);
            int rows = DetermineRows(level);

            // Generate formation positions (rows may be adjusted by formation requirements)
            var positions = GenerateFormation(formation, columns, ref rows);

            // Filter allowed presets if specified
            var presets = FilterPresets(allowedPresets);

            // Apply difficulty and assign brick types
            AssignBrickTypes(positions, level, presets, presetProbabilityOverrides);

            // Return the positions (let the game create actual sprites)
            return positions;
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Calculates level difficulty based on level number
        /// </summary>
        private float CalculateLevelDifficulty(int level)
        {
            return BaseDifficulty + (level) * DifficultyIncreasePerLevel;
        }

        /// <summary>
        /// Determines number of columns based on level
        /// </summary>
        private int DetermineColumns(int level)
        {
            return MaxColumns;
        }

        /// <summary>
        /// Determines number of rows based on level
        /// </summary>
        private int DetermineRows(int level)
        {
            return Math.Min(BreakoutGame.MIN_BRICKS_ROWS + level, MaxRows);
        }

        /// <summary>
        /// Calculates brick width based on available space and columns
        /// </summary>
        private float CalculateBrickWidth(float availableWidth, int columns)
        {
            float totalSpacing = HorizontalSpacing * (columns + 1);
            float availableWidthForBricks = availableWidth - totalSpacing - (SideMargin * 2);
            return availableWidthForBricks / columns;
        }

        /// <summary>
        /// Filters presets based on allowed list
        /// </summary>
        private List<BrickPreset> FilterPresets(List<string> allowedPresets)
        {
            if (allowedPresets == null || allowedPresets.Count == 0)
            {
                // If no filter, use all presets
                return BrickPresets.All.Values.ToList();
            }

            return BrickPresets.GetPresets(p => allowedPresets.Contains(p.Id));
        }

        /// <summary>
        /// Gets the chance for indestructible bricks based on level
        /// </summary>
        private float GetIndestructibleBrickChance(int level)
        {
            if (level < MinimumLevelForIndestructible)
                return 0;

            return Math.Min(
                IndestructibleBrickBaseChance + ((level - MinimumLevelForIndestructible) * IndestructibleBrickLevelScaling),
                0.25f // Cap at 25% chance for game balance
            );
        }

        /// <summary>
        /// Determines if a position is strategic for obstacle placement
        /// </summary>
        private bool IsStrategicPosition(float row, float col, int maxCols)
        {
            // Key pathways (middle columns on higher rows)
            bool isKeyPathway = (col > maxCols / 3 && col < 2 * maxCols / 3) && row < 2;

            // Border positions that block access
            bool isBorder = col == 0 || col == maxCols - 1 || row == 0;

            // "Chokepoints" where the ball must pass
            bool isChokepoint = (Math.Abs(col - maxCols / 2) < 1) && row % 2 == 0;

            return isKeyPathway || isBorder || isChokepoint;
        }

        /// <summary>
        /// Selects a brick preset based on difficulty and random factors
        /// </summary>
        private string SelectBrickPresetByDifficulty(List<BrickPreset> presets, float difficulty,
            Dictionary<string, float> probabilityOverrides)
        {
            // Group presets by type
            var standardPresets = presets.Where(p => p.SupplementaryHitsToDestroy == 0 && !p.IsSpecial && !p.Undestructible).ToList();
            var reinforcedPresets = presets.Where(p => p.SupplementaryHitsToDestroy > 0 && !p.IsSpecial && !p.Undestructible).ToList();
            var specialPresets = presets.Where(p => p.IsSpecial).ToList();
            var obstaclePresets = presets.Where(p => p.Undestructible).ToList();

            // If no presets of a certain type, return null or a default
            if (standardPresets.Count == 0)
                return null;

            float randomValue = (float)_random.NextDouble();

            // Apply difficulty scaling to probabilities
            float reinforcedChance = ReinforcedBrickProbability * difficulty;
            float specialChance = SpecialBrickProbability;
            float obstacleChance = ObstacleBrickProbability * difficulty;

            // Apply any overrides
            if (probabilityOverrides != null)
            {
                foreach (var preset in reinforcedPresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        reinforcedChance = overrideProb;
                        break;
                    }
                }

                foreach (var preset in obstaclePresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        obstacleChance = overrideProb;
                        break;
                    }
                }

                foreach (var preset in specialPresets)
                {
                    if (probabilityOverrides.TryGetValue(preset.Id, out float overrideProb))
                    {
                        specialChance = overrideProb;
                        break;
                    }
                }
            }

            // Select brick type based on probabilities
            if (obstaclePresets.Count > 0 && randomValue < obstacleChance)
            {
                return obstaclePresets[_random.Next(obstaclePresets.Count)].Id;
            }
            else if (reinforcedPresets.Count > 0 && randomValue < obstacleChance + reinforcedChance)
            {
                return reinforcedPresets[_random.Next(reinforcedPresets.Count)].Id;
            }
            else if (specialPresets.Count > 0 && randomValue < obstacleChance + reinforcedChance + specialChance)
            {
                return specialPresets[_random.Next(specialPresets.Count)].Id;
            }
            else
            {
                return standardPresets[_random.Next(standardPresets.Count)].Id;
            }
        }

        /// <summary>
        /// Assigns brick types to positions based on level difficulty
        /// </summary>
        private void AssignBrickTypes(List<BrickPosition> positions, int level, List<BrickPreset> presets,
            Dictionary<string, float> probabilityOverrides)
        {
            int indestructibleCount = 0;
            int maxCols = positions.Max(p => (int)p.Column) + 1;

            foreach (var position in positions)
            {
                // Check for strategic positions that might get indestructible bricks
                bool isStrategic = IsStrategicPosition(position.Row, position.Column, maxCols);

                // Calculate indestructible chance with strategic bonus
                float indestructibleChance = GetIndestructibleBrickChance(level);
                if (isStrategic)
                    indestructibleChance *= 2;

                // Assign indestructible if appropriate
                if (indestructibleCount < MaxIndestructibleBricks && _random.NextDouble() < indestructibleChance)
                {
                    var obstaclePresets = presets.Where(p => p.Undestructible).ToList();
                    if (obstaclePresets.Count > 0)
                    {
                        position.PresetId = obstaclePresets[_random.Next(obstaclePresets.Count)].Id;
                        indestructibleCount++;
                        continue;
                    }
                }

                // For other bricks, select by difficulty
                position.PresetId = SelectBrickPresetByDifficulty(presets, Difficulty, probabilityOverrides);
            }
        }



        /// <summary>
        /// Normalizes brick positions to ensure they start from column 0 (left-aligned)
        /// </summary>
        private void NormalizePositions(List<BrickPosition> positions)
        {
            if (positions == null || positions.Count == 0)
                return;

            float minColumn = positions.Min(p => p.Column);

            if (minColumn != 0)
            {
                float offset = -minColumn;
                foreach (var position in positions)
                {
                    position.Column += offset;
                }
            }
        }

        /// <summary>
        /// Adjusts the number of rows based on formation requirements
        /// </summary>
        private int AdjustRowsForFormation(FormationType formation, int requestedRows)
        {
            switch (formation)
            {
                case FormationType.Diamond:
                    // Diamond needs minimum 5 rows to form proper shape, max 12 for good proportions
                    return Math.Max(8, Math.Min(12, requestedRows));

                case FormationType.Arch:
                    // Arch needs minimum 5 rows for proper arch shape, max 12
                    return Math.Max(8, Math.Min(12, requestedRows));

                case FormationType.Wave:
                    // Wave needs minimum 6 rows for visible wave pattern, max 10
                    return Math.Max(6, Math.Min(10, requestedRows));

                case FormationType.Maze:
                    // Maze needs minimum 6 rows for corridors, max 15 for complexity
                    return Math.Max(6, Math.Min(15, requestedRows));

                case FormationType.Organic:
                    // Organic can work with any size but looks better with minimum 5 rows
                    return Math.Max(8, requestedRows);

                case FormationType.Zigzag:
                    // Zigzag needs minimum 4 rows for pattern, max 12
                    return Math.Max(6, Math.Min(12, requestedRows));

                case FormationType.Grid:
                default:
                    // Grid can work with any number of rows
                    return requestedRows;
            }
        }

        /// <summary>
        /// Generates formation based on specified type
        /// </summary>
        private List<BrickPosition> GenerateFormation(FormationType formation, int columns, ref int rows)
        {
            List<BrickPosition> positions;

            // Adjust rows based on formation requirements
            rows = AdjustRowsForFormation(formation, rows);

            switch (formation)
            {
                case FormationType.Pyramid:
                    positions = GeneratePyramidFormation(columns, rows);
                    break;
                case FormationType.Arch:
                    positions = GenerateArchFormation(columns, rows);
                    break;
                case FormationType.Diamond:
                    positions = GenerateDiamondFormation(columns, rows);
                    break;
                case FormationType.Zigzag:
                    positions = GenerateZigzagFormation(columns, rows);
                    break;
                //case FormationType.Spiral:
                //    positions = GenerateSpiralFormation(columns, rows);
                //    break;
                case FormationType.Organic:
                    positions = GenerateOrganicFormation(columns, rows);
                    break;
                case FormationType.Wave:
                    positions = GenerateWaveFormation(columns, rows);
                    break;
                case FormationType.Maze:
                    positions = GenerateMazeFormation(columns, rows);
                    break;
                case FormationType.Grid:
                default:
                    positions = GenerateGridFormation(columns, rows);
                    break;
            }

            NormalizePositions(positions);
            return positions;
        }

        #endregion

        #region Formation Generators

        /// <summary>
        /// Generates a standard grid formation
        /// </summary>
        private List<BrickPosition> GenerateGridFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = col,
                        Row = row,
                        PresetId = null // Will be assigned later
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a pyramid formation
        /// </summary>
        private List<BrickPosition> GeneratePyramidFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Calculate max width based on requested rows to ensure pyramid fits
            int maxWidth = Math.Min(columns, rows * 2 - 1); // Ensure pyramid can have the requested height

            // Center position offset
            float centerX = columns / 2f;

            for (int row = 0; row < rows; row++)
            {
                // Calculate how many bricks in this row (wider at bottom, narrower at top)
                int rowWidth = maxWidth - row * 2;
                if (rowWidth <= 0) break; // Safety check, but shouldn't happen with proper maxWidth

                // Calculate starting position to center the row
                float startX = centerX - (rowWidth / 2f);

                for (int col = 0; col < rowWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = startX + col,
                        Row = row,
                        PresetId = null // Will be assigned later
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates an arch formation
        /// </summary>
        private List<BrickPosition> GenerateArchFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Number of arches
            int numArches = Math.Max(1, columns / 6);

            // Width of each arch
            int archWidth = columns / numArches;

            // Height of arches
            int archHeight = Math.Min(rows, archWidth / 2);

            for (int archIdx = 0; archIdx < numArches; archIdx++)
            {
                float archCenterX = archIdx * archWidth + archWidth / 2f;

                // Create the arch
                for (int row = 0; row < archHeight; row++)
                {
                    // Calculate width at this row (wider at top)
                    float rowWidth = archWidth * (1 - (float)row / archHeight);

                    // Calculate starting position
                    float startX = archCenterX - rowWidth / 2;
                    float endX = archCenterX + rowWidth / 2;

                    // Add bricks along the row
                    for (float col = startX; col < endX; col++)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }

                // Add some supporting columns
                for (int row = archHeight; row < rows; row++)
                {
                    // Left support
                    positions.Add(new BrickPosition
                    {
                        Column = archCenterX - archWidth / 2,
                        Row = row,
                        PresetId = null
                    });

                    // Right support
                    positions.Add(new BrickPosition
                    {
                        Column = archCenterX + archWidth / 2 - 1,
                        Row = row,
                        PresetId = null
                    });
                }
            }

            return positions;
        }

        private List<BrickPosition> GenerateDiamondFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Define the center. For an even number of columns/rows,
            // the center is between cells, so we use (columns - 1) / 2f, etc.
            float centerX = (columns - 1) / 2f;
            float centerY = (rows - 1) / 2f;

            // Decide how large the diamond should be horizontally and vertically.
            // If you want it to span the full grid width/height, use columns-1 and rows-1 as below.
            float horizontalRadius = (columns - 1) / 2f;
            float verticalRadius = (rows - 1) / 2f;

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    // Offsets from center
                    float dx = col - centerX;
                    float dy = row - centerY;

                    // Diamond equation in “centered” form:
                    //   |dx|/horizontalRadius + |dy|/verticalRadius <= 1
                    if ((Math.Abs(dx) / horizontalRadius) + (Math.Abs(dy) / verticalRadius) <= 1f)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null // assigned later
                        });
                    }
                }
            }

            return positions;
        }


        /// <summary>
        /// Generates a zigzag formation
        /// </summary>
        private List<BrickPosition> GenerateZigzagFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Number of zigzags
            int zigzagCount = Math.Max(2, rows / 3);

            // Width of each zigzag leg
            int legWidth = columns / 2;

            for (int zigzag = 0; zigzag < zigzagCount; zigzag++)
            {
                int rowStart = zigzag * 3;

                // Going right
                for (int col = 0; col < legWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = col,
                        Row = rowStart,
                        PresetId = null
                    });
                }

                // Going left
                for (int col = 0; col < legWidth; col++)
                {
                    positions.Add(new BrickPosition
                    {
                        Column = columns - 1 - col,
                        Row = rowStart + 1,
                        PresetId = null
                    });
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates an organic formation using noise
        /// </summary>
        private List<BrickPosition> GenerateOrganicFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Create a noise seed
            float seedX = (float)_random.NextDouble() * 100;
            float seedY = (float)_random.NextDouble() * 100;

            // Create a boolean grid to track brick positions
            bool[,] hasBlock = new bool[columns, rows];

            // Fill using noise
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    // Generate perlin-like noise value
                    float noiseValue = GenerateNoiseValue(col * NoiseScale + seedX, row * NoiseScale + seedY);

                    // If noise value exceeds threshold, place a brick
                    if (noiseValue > NoiseThreshold)
                    {
                        hasBlock[col, row] = true;
                    }
                }
            }

            // Apply smoothing if needed
            if (SmoothingPasses > 0)
            {
                for (int pass = 0; pass < SmoothingPasses; pass++)
                {
                    hasBlock = SmoothOrganicGrid(hasBlock, columns, rows);
                }
            }

            // Convert grid to positions
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    if (hasBlock[col, row])
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a wave formation
        /// </summary>
        private List<BrickPosition> GenerateWaveFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Wave parameters
            float amplitude = rows / 5f;
            float frequency = 2 * (float)Math.PI / columns;
            int waves = 2;  // Number of complete waves

            for (int col = 0; col < columns; col++)
            {
                // Calculate wave height at this column
                float waveY = amplitude * (float)Math.Sin(frequency * waves * col);

                // Center wave vertically
                float centerY = rows / 2f;
                float baseY = centerY + waveY;

                // Place bricks above and below the wave curve
                for (int offset = -2; offset <= 2; offset++)
                {
                    float y = baseY + offset;
                    if (y >= 0 && y < rows)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = y,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        /// <summary>
        /// Generates a simple noise value (simple hash-based noise)
        /// </summary>
        private float GenerateNoiseValue(float x, float y)
        {
            // A simple hash-based noise function
            float n = x + y * 57;
            n = (n * 21.5453f) % 1.0f;
            return n;
        }

        /// <summary>
        /// Smooths an organic grid using cellular automata rules
        /// </summary>
        private bool[,] SmoothOrganicGrid(bool[,] grid, int width, int height)
        {
            bool[,] newGrid = new bool[width, height];

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    // Count alive neighbors
                    int neighbors = 0;
                    for (int nx = -1; nx <= 1; nx++)
                    {
                        for (int ny = -1; ny <= 1; ny++)
                        {
                            if (nx == 0 && ny == 0) continue;

                            int checkX = x + nx;
                            int checkY = y + ny;

                            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height)
                            {
                                if (grid[checkX, checkY])
                                    neighbors++;
                            }
                        }
                    }

                    // Apply cellular automata rules
                    if (grid[x, y])
                    {
                        // Cell is alive
                        newGrid[x, y] = neighbors >= 3;
                    }
                    else
                    {
                        // Cell is dead
                        newGrid[x, y] = neighbors >= 5;
                    }
                }
            }

            return newGrid;
        }

        /// <summary>
        /// Generates a maze-like formation with corridors and walls
        /// </summary>
        private List<BrickPosition> GenerateMazeFormation(int columns, int rows)
        {
            var positions = new List<BrickPosition>();

            // Create maze using simple algorithm
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < columns; col++)
                {
                    bool placeBrick = false;

                    // Create maze walls - every 3rd column and row creates corridors
                    if (row % 3 == 0 || col % 3 == 0)
                    {
                        placeBrick = true;
                    }

                    // Add some random openings in walls (30% chance)
                    if (placeBrick && _random.NextDouble() < 0.3)
                    {
                        placeBrick = false;
                    }

                    // Add some random blocks in corridors (20% chance)
                    if (!placeBrick && _random.NextDouble() < 0.2)
                    {
                        placeBrick = true;
                    }

                    if (placeBrick)
                    {
                        positions.Add(new BrickPosition
                        {
                            Column = col,
                            Row = row,
                            PresetId = null
                        });
                    }
                }
            }

            return positions;
        }

        #endregion
    }
}

--- C:\code\DrawnUi\src\Game\Levels\PowerUpType.cs ---
namespace Breakout.Game;

/// <summary>
/// Types of power-ups that can be dropped by special bricks
/// </summary>
public enum PowerupType
{
    None,
    Destroyer,
    StickyBall,
    ExpandPaddle,
    ShrinkPaddle,
    SlowBall,
    FastBall,
    MultiBall,
    ExtraLife,
    Fireball
}

--- C:\code\DrawnUi\src\Game\Sound\AudioMixerService.cs ---
using System.Diagnostics;
using System.Numerics;
using AppoMobi.Specials;
using Plugin.Maui.Audio;

namespace Breakout.Game;

/// <summary>
/// Game audio service using Plugin.Maui.Audio's AudioMixer for professional sound management
/// </summary>
public class AudioMixerService : IAudioService
{
    #region CONSTANTS

    /// <summary>
    /// Number of audio channels for sound effects
    /// </summary>
    private const int SOUND_EFFECT_CHANNELS = 8;

    #endregion

    #region SOUND DATA STORAGE

    // Store preloaded audio sources for use with AudioMixer
    private readonly Dictionary<string, MemoryAudioSource> _soundSources = new();

    #endregion

    #region PROPERTIES

    private float _masterVolume = 1.0f;
    private bool _isMuted;

    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    public float MasterVolume
    {
        get => _masterVolume;
        set
        {
            _masterVolume = Math.Clamp(value, 0f, 1f);
            UpdateAllChannelVolumes();
        }
    }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    public bool IsMuted
    {
        get => _isMuted;
        set
        {
            _isMuted = value;
            UpdateAllChannelVolumes();
            UpdateBackgroundMusicVolume();
        }
    }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    public bool IsBackgroundMusicPlaying => _backgroundMusicPlayer?.IsPlaying == true;

    #endregion

    #region FIELDS

    // Audio management using AudioMixer
    private readonly IAudioManager _audioManager;
    private readonly AudioMixer _audioMixer;

    // Background music tracking
    private IAudioPlayer _backgroundMusicPlayer;
    private float _backgroundMusicVolume = 0.3f;

    // Sound effect management
    private int _currentSoundChannel = 0;

    #endregion

    #region CONSTRUCTOR

    /// <summary>
    /// Initializes a new game audio service using AudioMixer
    /// </summary>
    /// <param name="audioManager">The MAUI Audio manager instance</param>
    public AudioMixerService(IAudioManager audioManager)
    {
        _audioManager = audioManager ?? throw new ArgumentNullException(nameof(audioManager));
        _audioMixer = new AudioMixer(audioManager, SOUND_EFFECT_CHANNELS);
    }

    #endregion

    #region PRELOADING

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    public async Task<bool> PreloadSoundAsync(string soundId, string filePath)
    {
        try
        {
            // Load audio data into memory
            byte[] audioData;
            using (var stream = await FileSystem.OpenAppPackageFileAsync(filePath))
            using (var memoryStream = new MemoryStream())
            {
                await stream.CopyToAsync(memoryStream);
                audioData = memoryStream.ToArray();
            }

            // Create audio source from data
            var audioSource = new MemoryAudioSource(audioData);
            _soundSources[soundId] = audioSource;

            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error preloading '{soundId}': {ex}");
            return false;
        }
    }

    #endregion

    #region SOUND PLAYBACK

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false)
    {
        if (_audioMixer == null)
            return;

        Tasks.StartDelayed(TimeSpan.FromMicroseconds(1), () =>
        {
            if (IsMuted)
                volume = 0f;
            else
                volume *= MasterVolume;

            if (!_soundSources.TryGetValue(soundId, out var audioSource))
            {
                Debug.WriteLine($"Sound '{soundId}' not preloaded");
                return;
            }

            try
            {
                // Get next available channel (round-robin)
                int channelIndex = _currentSoundChannel;
                _currentSoundChannel = (_currentSoundChannel + 1) % SOUND_EFFECT_CHANNELS;

                // Play sound on the selected channel
                _audioMixer.Play(channelIndex, audioSource, loop);
                _audioMixer.SetVolume(channelIndex, volume);
                _audioMixer.SetBalance(channelIndex, balance);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error playing sound '{soundId}': {ex}");
            }
        });
    }

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false)
    {
        if (IsMuted)
            volume = 0f;
        else
            volume *= MasterVolume;

        var (balance, adjustedVolume) = _audioMixer.PositionInSpace(position, volume, 0f);

        PlaySound(soundId, adjustedVolume, balance, loop);
    }

    #endregion

    #region BACKGROUND MUSIC

    public async void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        try
        {
            // Stream directly from file using Plugin.Maui.Audio
            var fileStream = await FileSystem.OpenAppPackageFileAsync(filePath);
            _backgroundMusicPlayer = _audioManager.CreatePlayer(fileStream);
            _backgroundMusicPlayer.Loop = true;
            UpdateBackgroundMusicVolume();
            _backgroundMusicPlayer.Play();

            Debug.WriteLine($"Started background music streaming from '{filePath}' using AudioMixer");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error starting background music from file '{filePath}': {ex}");
        }
    }


    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void StartBackgroundMusic(string soundId, float volume = 0.3f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        if (_soundSources.TryGetValue(soundId, out var audioSource))
        {
            _backgroundMusicPlayer = _audioManager.CreatePlayer(audioSource.GetAudioStream());
            _backgroundMusicPlayer.Loop = true;
            UpdateBackgroundMusicVolume();
            _backgroundMusicPlayer.Play();
        }
    }

    /// <summary>
    /// Stops background music playback
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                _backgroundMusicPlayer.Stop();
                _backgroundMusicPlayer.Dispose();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error stopping background music: {ex}");
            }
            finally
            {
                _backgroundMusicPlayer = null;
            }
        }
    }

    #endregion

    #region VOLUME MANAGEMENT

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void SetSoundVolume(string soundId, float volume)
    {
        volume = Math.Clamp(volume, 0f, 1f);

        // Special handling for background music
        if (soundId == "background")
        {
            _backgroundMusicVolume = volume;
            UpdateBackgroundMusicVolume();
            return;
        }

        // Note: For sound effects, we can't easily adjust volume for specific sound IDs
        // since the AudioMixer manages channels independently. This would require tracking
        // which sounds are playing on which channels, which adds complexity.
        Debug.WriteLine(
            $"SetSoundVolume for '{soundId}' - individual sound volume control not supported with AudioMixer");
    }

    /// <summary>
    /// Updates the volume of all sound effect channels based on master volume and mute state
    /// </summary>
    private void UpdateAllChannelVolumes()
    {
        float effectiveVolume = IsMuted ? 0f : MasterVolume;

        for (int i = 0; i < SOUND_EFFECT_CHANNELS; i++)
        {
            try
            {
                var channel = _audioMixer.GetChannel(i);
                if (channel.IsPlaying)
                {
                    _audioMixer.SetVolume(i, effectiveVolume);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating channel {i} volume: {ex}");
            }
        }
    }

    /// <summary>
    /// Updates background music volume based on settings
    /// </summary>
    private void UpdateBackgroundMusicVolume()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                float effectiveVolume = IsMuted ? 0f : _backgroundMusicVolume * MasterVolume;
                _backgroundMusicPlayer.Volume = effectiveVolume;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating background music volume: {ex}");
            }
        }
    }

    #endregion

    #region DISPOSAL

    /// <summary>
    /// Cleans up all resources used by the audio service
    /// </summary>
    public void Dispose()
    {
        StopBackgroundMusic();
        _audioMixer?.Dispose();

        foreach (var audioSource in _soundSources.Values)
        {
            try
            {
                audioSource?.Dispose();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error disposing audio source: {ex}");
            }
        }

        _soundSources.Clear();
    }

    #endregion
}

--- C:\code\DrawnUi\src\Game\Sound\GameAudioSource.cs ---
using Plugin.Maui.Audio;

namespace Breakout.Game;

public interface IGameAudioSource : IAudioSource, IDisposable
{
}

/// <summary>
/// Preloaded IAudioSource for sound effects (small files, zero-lag playback)
/// </summary>
internal class GameAudioSource : IGameAudioSource
{
    private readonly byte[] _audioData;
    private MemoryStream _stream;

    public GameAudioSource(byte[] audioData)
    {
        _audioData = audioData ?? throw new ArgumentNullException(nameof(audioData));
        _stream = new MemoryStream(_audioData, false); // Read-only
    }

    public Stream GetAudioStream()
    {
        // Reset position and return the same stream
        _stream.Position = 0;
        return _stream;
    }

    public void Dispose()
    {
        _stream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sound\IAudioService.cs ---
using System.Numerics;

namespace Breakout.Game;

/// <summary>
/// Interface for game audio services to enable easy switching between implementations
/// </summary>
public interface IAudioService : IDisposable
{
    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    float MasterVolume { get; set; }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    bool IsMuted { get; set; }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    bool IsBackgroundMusicPlaying { get; }

    void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f);

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    Task<bool> PreloadSoundAsync(string soundId, string filePath);

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false);

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false);

    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    void StartBackgroundMusic(string soundId, float volume = 0.3f);

    /// <summary>
    /// Stops background music playback
    /// </summary>
    void StopBackgroundMusic();

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    void SetSoundVolume(string soundId, float volume);
}

--- C:\code\DrawnUi\src\Game\Sound\MemoryAudioSource.cs ---
namespace Breakout.Game;

/// <summary>
/// Simple audio source implementation for memory-based audio data, reuses stream
/// </summary>
internal class MemoryAudioSource : IGameAudioSource
{
    private readonly byte[] _audioData;
    private readonly MemoryStream _reusableStream;

    public MemoryAudioSource(byte[] audioData)
    {
        _audioData = audioData ?? throw new ArgumentNullException(nameof(audioData));
        _reusableStream = new MemoryStream(_audioData, false); // Read-only
    }

    public Stream GetAudioStream()
    {
        // Reset position and return the same stream
        _reusableStream.Position = 0;
        return _reusableStream;
    }

    public void Dispose()
    {
        _reusableStream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sound\SoundFlowAudioService.cs ---
#if ANDROID

using AppoMobi.Specials;
using SoundFlow.Abstracts;
using SoundFlow.Backends.MiniAudio;
using SoundFlow.Components;
using SoundFlow.Enums;
using SoundFlow.Interfaces;
using SoundFlow.Providers;
using System.Diagnostics;
using System.Numerics;

namespace Breakout.Game;

/// <summary>
/// Game audio service using SoundFlow for high-performance cross-platform audio management
/// </summary>
public class SoundFlowAudioService : IAudioService
{
    #region CONSTANTS

    /// <summary>
    /// Number of audio channels for sound effects
    /// </summary>
    private const int SOUND_EFFECT_CHANNELS = 8;

    /// <summary>
    /// Sample rate for audio engine (48kHz for high quality)
    /// </summary>
    private const int SAMPLE_RATE = 48000;

    #endregion

    #region SOUND DATA STORAGE

    // Store preloaded audio data for use with SoundFlow
    private readonly Dictionary<string, byte[]> _soundData = new();

    // Track active sound players for sound effects
    private readonly List<SoundPlayer> _soundEffectPlayers = new();

    // Object pool for memory streams to reduce GC pressure
    private readonly Queue<MemoryStream> _memoryStreamPool = new();
    private readonly object _poolLock = new();

    #endregion

    #region PROPERTIES

    private float _masterVolume = 1.0f;
    private bool _isMuted;

    /// <summary>
    /// Gets or sets the master volume for all audio
    /// </summary>
    public float MasterVolume
    {
        get => _masterVolume;
        set
        {
            _masterVolume = Math.Clamp(value, 0f, 1f);
            UpdateAllVolumes();
        }
    }

    /// <summary>
    /// Gets or sets whether audio is muted
    /// </summary>
    public bool IsMuted
    {
        get => _isMuted;
        set
        {
            _isMuted = value;
            UpdateAllVolumes();
        }
    }

    /// <summary>
    /// Gets whether background music is currently playing
    /// </summary>
    public bool IsBackgroundMusicPlaying => _backgroundMusicPlayer?.State == PlaybackState.Playing;

    #endregion

    #region FIELDS

    // SoundFlow audio engine and mixer
    private readonly AudioEngine _audioEngine;
    private readonly Mixer _masterMixer;

    // Background music tracking
    private SoundPlayerBase _backgroundMusicPlayer;
    private float _backgroundMusicVolume = 0.3f;

    // Sound effect management
    private int _currentSoundChannel = 0;

    // Disposal tracking
    private bool _disposed = false;

    #endregion

    #region CONSTRUCTOR

    /// <summary>
    /// Initializes a new game audio service using SoundFlow
    /// </summary>
    public SoundFlowAudioService()
    {
        try
        {
            // Initialize SoundFlow audio engine with MiniAudio backend
            _audioEngine = new MiniAudioEngine(SAMPLE_RATE, Capability.Playback);
            _masterMixer = Mixer.Master;

            Debug.WriteLine($"SoundFlow audio engine initialized with {SAMPLE_RATE}Hz sample rate");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error initializing SoundFlow audio engine: {ex}");
            throw;
        }
    }

    #endregion

    #region PRELOADING

    /// <summary>
    /// Preloads a sound file into memory for immediate playback
    /// </summary>
    /// <param name="soundId">Identifier for the sound</param>
    /// <param name="filePath">Path to the sound file</param>
    /// <returns>True if preloading was successful</returns>
    public async Task<bool> PreloadSoundAsync(string soundId, string filePath)
    {
        try
        {
            // Load audio data into memory
            byte[] audioData;
            using (var stream = await FileSystem.OpenAppPackageFileAsync(filePath))
            using (var memoryStream = new MemoryStream())
            {
                await stream.CopyToAsync(memoryStream);
                audioData = memoryStream.ToArray();
            }

            // Store the raw audio data
            _soundData[soundId] = audioData;

            Debug.WriteLine($"Preloaded sound '{soundId}' from '{filePath}' ({audioData.Length} bytes)");
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error preloading '{soundId}': {ex}");
            return false;
        }
    }

    #endregion

    #region SOUND PLAYBACK

    /// <summary>
    /// Plays a sound with standard stereo positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    /// <param name="balance">Stereo balance (-1.0 to 1.0)</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySound(string soundId, float volume = 1.0f, float balance = 0.0f, bool loop = false)
    {
        if (_disposed || _audioEngine == null)
            return;

        //Tasks.StartDelayed(TimeSpan.FromMicroseconds(1), () =>
        //{
            try
            {
                if (IsMuted)
                    volume = 0f;
                else
                    volume *= MasterVolume;

                if (!_soundData.TryGetValue(soundId, out var audioData))
                {
                    Debug.WriteLine($"Sound '{soundId}' not preloaded");
                    return;
                }

                // Create a new SoundPlayer for this sound effect using pooled memory stream
                var memoryStream = GetPooledMemoryStream(audioData);
                var dataProvider = new StreamDataProvider(memoryStream);
                var player = new SoundPlayer(dataProvider);

                // Configure the player
                player.Volume = volume;
                player.IsLooping = loop;

                // Add to master mixer
                _masterMixer.AddComponent(player);

                // Track the player for cleanup
                _soundEffectPlayers.Add(player);

                // Start playback
                player.Play();

                // Clean up finished players periodically
                CleanupFinishedPlayers();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error playing sound '{soundId}': {ex}");
            }
        //});
    }

    /// <summary>
    /// Plays a sound with spatial positioning
    /// </summary>
    /// <param name="soundId">ID of the sound to play</param>
    /// <param name="position">3D position of the sound</param>
    /// <param name="volume">Base volume before spatial adjustments</param>
    /// <param name="loop">Whether to loop the sound</param>
    public void PlaySpatialSound(string soundId, Vector3 position, float volume = 1.0f, bool loop = false)
    {
        if (IsMuted)
            volume = 0f;
        else
            volume *= MasterVolume;

        // Simple spatial audio calculation
        // Distance attenuation and stereo panning based on X position
        float distance = position.Length();
        float attenuatedVolume = volume / (1.0f + distance * 0.1f); // Simple distance attenuation
        float balance = Math.Clamp(position.X * 0.5f, -1.0f, 1.0f); // Pan based on X position

        PlaySound(soundId, attenuatedVolume, balance, loop);
    }

    #endregion

    #region BACKGROUND MUSIC



    public class SFPlayer : SoundPlayerBase
    {
        /// <summary>A sound player that plays audio from a data provider.</summary>
        public SFPlayer(ISoundDataProvider dataProvider) : base (dataProvider)
        {
            _dataProvider = dataProvider;
        }

        private readonly ISoundDataProvider _dataProvider;

        protected override void HandleEndOfStream(Span<float> remainingOutputBuffer)
        {
            if (!_dataProvider.CanSeek)
            {
                //basically we wouldn't be able to loop as we don't know the end
                var check = $"{Time} / {Duration}  {LoopStartSamples} / {LoopEndSamples}  |  {LoopEndSeconds}";
                Debug.WriteLine(check);
            }
            base.HandleEndOfStream(remainingOutputBuffer);
        }

        /// <inheritdoc />
        public override string Name { get; set; }
    }

    /// <summary>
    /// Starts background music playback directly from file (streaming, memory-efficient)
    /// </summary>
    /// <param name="filePath">Path to the background music file</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public async void StartBackgroundMusicFromFile(string filePath, float volume = 1.0f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        try
        {
            // Stream directly from file instead of loading into memory
            var fileStream = await FileSystem.OpenAppPackageFileAsync(filePath);
            var dataProvider = new StreamDataProvider(fileStream);
            _backgroundMusicPlayer = new SFPlayer(dataProvider);

            _backgroundMusicPlayer.IsLooping = true;
            UpdateBackgroundMusicVolume();

            _masterMixer.AddComponent(_backgroundMusicPlayer);
            _backgroundMusicPlayer.Play();

            Debug.WriteLine($"Started background music streaming from '{filePath}'");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error starting background music from file '{filePath}': {ex}");
        }
    }


    /// <summary>
    /// Starts background music playback
    /// </summary>
    /// <param name="soundId">ID of the background music sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void StartBackgroundMusic(string soundId, float volume = 0.3f)
    {
        StopBackgroundMusic(); // Stop any existing background music

        _backgroundMusicVolume = Math.Clamp(volume, 0f, 1f);

        if (_soundData.TryGetValue(soundId, out var audioData))
        {
            try
            {
                var memoryStream = GetPooledMemoryStream(audioData);
                var dataProvider = new StreamDataProvider(memoryStream);
                _backgroundMusicPlayer = new SoundPlayer(dataProvider);

                _backgroundMusicPlayer.IsLooping = true;
                UpdateBackgroundMusicVolume();

                _masterMixer.AddComponent(_backgroundMusicPlayer);
                _backgroundMusicPlayer.Play();

                Debug.WriteLine($"Started background music '{soundId}'");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error starting background music '{soundId}': {ex}");
            }
        }
        else
        {
            Debug.WriteLine($"Background music '{soundId}' not preloaded");
        }
    }

    /// <summary>
    /// Stops background music playback
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                _backgroundMusicPlayer.Stop();
                _masterMixer.RemoveComponent(_backgroundMusicPlayer);
                Debug.WriteLine("Stopped background music");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error stopping background music: {ex}");
            }
            finally
            {
                _backgroundMusicPlayer = null;
            }
        }
    }

    #endregion

    #region VOLUME MANAGEMENT

    /// <summary>
    /// Sets the volume for a specific sound type
    /// </summary>
    /// <param name="soundId">ID of the sound</param>
    /// <param name="volume">Volume level (0.0 to 1.0)</param>
    public void SetSoundVolume(string soundId, float volume)
    {
        volume = Math.Clamp(volume, 0f, 1f);

        // Special handling for background music
        if (soundId == "background")
        {
            _backgroundMusicVolume = volume;
            UpdateBackgroundMusicVolume();
            return;
        }

        // Note: For sound effects, individual volume control is complex with SoundFlow
        // since each sound creates a new player. This would require tracking
        // which sounds are playing, which adds complexity.
        Debug.WriteLine($"SetSoundVolume for '{soundId}' - individual sound volume control not implemented");
    }

    /// <summary>
    /// Updates all audio volumes based on master volume and mute state
    /// </summary>
    private void UpdateAllVolumes()
    {
        UpdateBackgroundMusicVolume();

        // Update sound effect volumes
        foreach (var player in _soundEffectPlayers.ToList())
        {
            if (player != null)
            {
                try
                {
                    float effectiveVolume = IsMuted ? 0f : MasterVolume;
                    player.Volume = effectiveVolume;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error updating sound effect volume: {ex}");
                }
            }
        }
    }

    /// <summary>
    /// Updates background music volume based on settings
    /// </summary>
    private void UpdateBackgroundMusicVolume()
    {
        if (_backgroundMusicPlayer != null)
        {
            try
            {
                float effectiveVolume = IsMuted ? 0f : _backgroundMusicVolume * MasterVolume;
                _backgroundMusicPlayer.Volume = effectiveVolume;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating background music volume: {ex}");
            }
        }
    }

    #endregion

    #region MEMORY MANAGEMENT

    /// <summary>
    /// Gets a pooled memory stream to reduce GC pressure
    /// </summary>
    /// <param name="audioData">Audio data to initialize the stream with</param>
    /// <returns>A memory stream containing the audio data</returns>
    private MemoryStream GetPooledMemoryStream(byte[] audioData)
    {
        MemoryStream stream;

        lock (_poolLock)
        {
            if (_memoryStreamPool.Count > 0)
            {
                stream = _memoryStreamPool.Dequeue();
                stream.SetLength(0);
                stream.Position = 0;
            }
            else
            {
                stream = new MemoryStream();
            }
        }

        stream.Write(audioData, 0, audioData.Length);
        stream.Position = 0;
        return stream;
    }

    /// <summary>
    /// Returns a memory stream to the pool for reuse
    /// </summary>
    /// <param name="stream">The stream to return to the pool</param>
    private void ReturnMemoryStreamToPool(MemoryStream stream)
    {
        if (stream == null) return;

        lock (_poolLock)
        {
            // Limit pool size to prevent excessive memory usage
            if (_memoryStreamPool.Count < 10)
            {
                stream.SetLength(0);
                stream.Position = 0;
                _memoryStreamPool.Enqueue(stream);
            }
            else
            {
                stream.Dispose();
            }
        }
    }

    #endregion

    #region CLEANUP

    /// <summary>
    /// Cleans up finished sound effect players to prevent memory leaks
    /// </summary>
    private void CleanupFinishedPlayers()
    {
        try
        {
            var playersToRemove = new List<SoundPlayer>();

            foreach (var player in _soundEffectPlayers.ToList())
            {
                if (player == null || player.State == PlaybackState.Stopped)
                {
                    playersToRemove.Add(player);
                }
            }

            foreach (var player in playersToRemove)
            {
                _soundEffectPlayers.Remove(player);

                if (player != null)
                {
                    try
                    {
                        _masterMixer.RemoveComponent(player);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error removing sound effect player: {ex}");
                    }
                }
            }

            // Limit the number of tracked players to prevent excessive memory usage
            if (_soundEffectPlayers.Count > SOUND_EFFECT_CHANNELS * 2)
            {
                var oldestPlayers = _soundEffectPlayers.Take(_soundEffectPlayers.Count - SOUND_EFFECT_CHANNELS).ToList();
                foreach (var player in oldestPlayers)
                {
                    _soundEffectPlayers.Remove(player);
                    if (player != null)
                    {
                        try
                        {
                            player.Stop();
                            _masterMixer.RemoveComponent(player);
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Error stopping old sound effect player: {ex}");
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error during player cleanup: {ex}");
        }
    }

    #endregion

    #region DISPOSAL

    /// <summary>
    /// Cleans up all resources used by the audio service
    /// </summary>
    public void Dispose()
    {
        if (_disposed)
            return;

        try
        {
            Debug.WriteLine("Disposing SoundFlow audio service...");

            // Stop background music
            StopBackgroundMusic();

            // Stop and dispose all sound effect players
            foreach (var player in _soundEffectPlayers.ToList())
            {
                if (player != null)
                {
                    try
                    {
                        player.Stop();
                        _masterMixer.RemoveComponent(player);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error stopping sound effect player: {ex}");
                    }
                }
            }
            _soundEffectPlayers.Clear();

            // Clear sound data
            _soundData.Clear();

            // Clear memory stream pool
            lock (_poolLock)
            {
                while (_memoryStreamPool.Count > 0)
                {
                    var stream = _memoryStreamPool.Dequeue();
                    stream?.Dispose();
                }
            }

            // Dispose audio engine
            _audioEngine?.Dispose();

            Debug.WriteLine("SoundFlow audio service disposed successfully");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error disposing SoundFlow audio service: {ex}");
        }
        finally
        {
            _disposed = true;
        }
    }

    #endregion
}

#endif

--- C:\code\DrawnUi\src\Game\Sound\StreamingAudioSource.cs ---
using System.Diagnostics;

namespace Breakout.Game;

/// <summary>
/// Streaming IAudioSource for background music (large files, loaded on-demand)
/// </summary>
internal class StreamingAudioSource : IGameAudioSource
{
    private readonly string _filePath;
    private Stream _currentStream;

    public StreamingAudioSource(string filePath)
    {
        _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
    }

    public Stream GetAudioStream()
    {
        // Create a new stream each time for background music (file streaming)
        // This allows the AudioMixer to handle the music file without loading it all into memory
        try
        {
            return FileSystem.OpenAppPackageFileAsync(_filePath).Result;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error opening music file '{_filePath}': {ex}");
            return Stream.Null;
        }
    }

    public void Dispose()
    {
        _currentStream?.Dispose();
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\BallSprite.cs ---
using System.Numerics;
using SkiaSharp;

namespace Breakout.Game;

public class BallSprite : SkiaShape, IWithHitBox, IReusableSprite
{

    //BackgroundColor="#dddddd"
    public BallSprite()
    {
        UseCache = SkiaCacheType.GPU;
        HeightRequest = 15;
        HorizontalOptions = LayoutOptions.Center;
        VerticalOptions = LayoutOptions.End;
        Type = ShapeType.Circle;
        StrokeColor = Colors.White;
        StrokeWidth = 2;
        LockRatio = 1;
        BackgroundColor = Colors.Aqua;
        SpeedRatio = 1;
        IsActive = true;
        BevelType = BevelType.Bevel;
        Bevel = new SkiaBevel()
        {
            Depth = 4,
            LightColor = Colors.White,
            ShadowColor = Color.Parse("#333333"),
            Opacity = 0.33
        };
    }

    public static BallSprite Create()
    {
        return new();
    }

    public bool IsActive { get; set; }

    private bool _isFireball = false;
    public bool IsFireball
    {
        get => _isFireball;
        set
        {
            if (_isFireball != value)
            {
                _isFireball = value;
                UpdateFireballAppearance();
            }
        }
    }

    private void UpdateFireballAppearance()
    {
        if (_isFireball)
        {
            // Fireball appearance: red/orange with fiery glow
            BackgroundColor = Colors.Red;
            StrokeColor = Colors.Orange;
            StrokeWidth = 3;
        }
        else
        {
            // Normal ball appearance
            BackgroundColor = Colors.Aqua;
            StrokeColor = Colors.White;
            StrokeWidth = 2;
        }
    }

    public float Angle
    {
        get => _angle;
        set
        {
            _angle = ClampAngleFromHorizontal(value);
            TrackAngleForOscillation(_angle);
        }
    }


    public float SpeedRatio { get; set; }

    public bool IsMoving
    {
        get => _isMoving;
        set
        {
            if (value == _isMoving) return;
            _isMoving = value;
            OnPropertyChanged();
        }
    }

    public void ResetAnimationState()
    {
    }

    public async Task AnimateDisappearing()
    {
    }

    public void UpdateState(long time, bool force=false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    long _stateUpdated;
    public SKRect HitBox { get; set; }

    // New interpolation fields
    private float _lastMoveX;
    private float _lastMoveY;
    private float _interpolationFactor = 0.5f; // Smoothing factor
    private float _angle;
    private bool _isMoving;

    // Angle oscillation detection for unsticking
    private float _angleHistory1 = float.NaN;
    private float _angleHistory2 = float.NaN;
    private float _angleHistory3 = float.NaN;
    private int _oscillationCount = 0;

    /// <summary>
    /// Change the current position offset by the provided amount in points
    /// </summary>
    public void MoveOffset(double x, double y)
    {
        Left += x;
        Top += y;
        //Repaint();
    }

    /// <summary>
    /// Replaces the current position offset by the provided amount in points
    /// </summary>
    public void SetOffset(double x, double y)
    {
        Left = x;
        Top = y;
        //Repaint();
    }

    public void SetOffsetX(double x)
    {
        Left = x;
        //Repaint();
    }

    public void SetOffsetY(double y)
    {
        Top = y;
        //Repaint();
    }

    public void UpdatePosition(float deltaSeconds)
    {
        // Ensure delta is capped and positive
        if (deltaSeconds <= 0 || !IsMoving)
            return;

        // Calculate new movement
        float moveX = BreakoutGame.BALL_SPEED * SpeedRatio * MathF.Cos(Angle) * deltaSeconds;
        float moveY = BreakoutGame.BALL_SPEED * SpeedRatio * MathF.Sin(Angle) * deltaSeconds;

        //// Interpolate movement for smoother transition
        //moveX = float.Lerp(_lastMoveX, moveX, _interpolationFactor);
        //moveY = float.Lerp(_lastMoveY, moveY, _interpolationFactor);
        //_lastMoveX = moveX;
        //_lastMoveY = moveY;

        // Apply interpolated movement
        Left += moveX;
        Top += moveY;

        //Repaint();
    }

    /// <summary>
    /// Returns the current movement direction as a normalized vector
    /// </summary>
    public Vector2 Direction => new Vector2(MathF.Cos(Angle), MathF.Sin(Angle));

    /// <summary>
    /// Returns the ball's center position as a Vector2
    /// </summary>
    public Vector2 Position => new Vector2(HitBox.MidX, HitBox.MidY);

    /// <summary>
    /// Sets the ball's direction from a Vector2 (automatically normalizes)
    /// </summary>
    public void SetDirection(Vector2 direction)
    {
        if (direction == Vector2.Zero)
            return;

        Vector2 normalized = Vector2.Normalize(direction);
        Angle = MathF.Atan2(normalized.Y, normalized.X);
    }

    /// <summary>
    /// Clamps an angle (in radians) to ensure it is at least a minimum deviation
    /// away from the horizontal axes (0, +/- PI, +/- 2*PI, etc.).
    /// </summary>
    /// <param name="angle">The input angle in radians.</param>
    /// <param name="minAngleFromHorizontal">
    /// The minimum desired angle (in radians) between the output angle and the
    /// nearest horizontal axis. Must be positive and less than PI/2 (90 degrees).
    /// </param>
    /// <returns>
    /// The adjusted angle (in radians), guaranteed to be at least minAngleFromHorizontal
    /// away from any horizontal axis. The returned angle will be normalized to the range (-PI, PI].
    /// </returns>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown if minAngleFromHorizontal is not within the valid range (0, PI/2).
    /// </exception>
    public static float ClampAngleFromHorizontal(float angle, float minAngleFromHorizontal = MathF.PI / 10.0f)
    {
        // --- Input Validation ---
        if (minAngleFromHorizontal <= 0 || minAngleFromHorizontal >= MathF.PI / 2.0f)
        {
            throw new ArgumentOutOfRangeException(nameof(minAngleFromHorizontal),
                "Must be positive and less than PI/2 radians.");
        }

        // --- Normalize angle to the range (-PI, PI] for easier comparison ---
        // This simplifies checking against 0 and +/- PI
        float twoPi = 2.0f * MathF.PI;
        float normalizedAngle = angle % twoPi; // Bring angle within (-2*PI, 2*PI)

        // Adjust to (-PI, PI] range
        if (normalizedAngle <= -MathF.PI)
        {
            normalizedAngle += twoPi;
        }
        else if (normalizedAngle > MathF.PI)
        {
            normalizedAngle -= twoPi;
        }
        // Now normalizedAngle is guaranteed to be in the interval (-PI, PI]

        // --- Check if the angle is too close to horizontal ---
        bool tooCloseToZero = MathF.Abs(normalizedAngle) < minAngleFromHorizontal;
        bool tooCloseToPi = MathF.Abs(normalizedAngle) > (MathF.PI - minAngleFromHorizontal);

        if (tooCloseToZero || tooCloseToPi)
        {
            // --- Adjust the angle ---
            // Determine the sign to preserve the general direction (up/down)
            float sign = MathF.Sign(normalizedAngle);

            // Handle the edge case where normalizedAngle is exactly 0
            if (sign == 0)
            {
                // If the original angle was 0 or a multiple of 2*PI, it normalized to 0.
                // We need a consistent direction to nudge it. Let's default to positive (up/right quadrant).
                // You might adjust this based on game context if 0 needs special handling.
                sign = 1;
            }

            if (tooCloseToZero)
            {
                // If it was near 0, set it to the minimum angle away from 0
                return sign * minAngleFromHorizontal;
            }
            else // tooCloseToPi
            {
                // If it was near +/- PI, set it to the minimum angle away from +/- PI
                return sign * (MathF.PI - minAngleFromHorizontal);
            }
        }
        else
        {
            // Angle is not too horizontal, return the normalized version
            return normalizedAngle;
        }
    }

    /// <summary>
    /// Track angle changes to detect oscillation (ball stuck between surfaces)
    /// </summary>
    private void TrackAngleForOscillation(float newAngle)
    {
        // Only track if ball is moving
        if (!IsMoving)
        {
            ResetOscillationTracking();
            return;
        }

        // Shift history: 3 -> 2 -> 1 -> new
        _angleHistory3 = _angleHistory2;
        _angleHistory2 = _angleHistory1;
        _angleHistory1 = newAngle;

        // Check for oscillation pattern (need at least 3 angles)
        if (!float.IsNaN(_angleHistory3))
        {
            CheckForOscillation();
        }
    }

    /// <summary>
    /// Check if ball is stuck in angle oscillation pattern
    /// </summary>
    private void CheckForOscillation()
    {
        const float angleTolerance = 0.01f; // Small tolerance for floating point comparison

        // Check if we have a 2-angle oscillation pattern
        bool isOscillating =
            (MathF.Abs(_angleHistory1 - _angleHistory3) < angleTolerance) && // Current matches 2 steps ago
            (MathF.Abs(_angleHistory2 - _angleHistory1) > angleTolerance);   // But different from previous

        if (isOscillating)
        {
            _oscillationCount++;

            // If oscillating for 6+ frames, we're stuck!
            if (_oscillationCount >= 6)
            {
                UnstickBall();
            }
        }
        else
        {
            _oscillationCount = 0; // Reset counter if pattern breaks
        }
    }

    /// <summary>
    /// Unstick the ball by adding a small random angle adjustment
    /// </summary>
    private void UnstickBall()
    {
        // Add small random nudge to break oscillation
        var random = new Random();
        float nudge = (float)(random.NextDouble() - 0.5) * 0.4f; // ±0.2 radians (~±11 degrees)

        _angle = ClampAngleFromHorizontal(_angle + nudge);

        // Reset tracking
        ResetOscillationTracking();

        // Optional: Boost speed slightly to help escape
        SpeedRatio = Math.Max(SpeedRatio, 1.0f);
    }

    /// <summary>
    /// Reset oscillation tracking
    /// </summary>
    private void ResetOscillationTracking()
    {
        _angleHistory1 = float.NaN;
        _angleHistory2 = float.NaN;
        _angleHistory3 = float.NaN;
        _oscillationCount = 0;
    }

}

--- C:\code\DrawnUi\src\Game\Sprites\BrickSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class BrickSprite : SkiaShape, IWithHitBox, IReusableSprite
{
    public static BrickSprite Create()
    {
        return new BrickSprite
        {
            UseCache = SkiaCacheType.Operations,
            BackgroundColor = Colors.Red,
            CornerRadius = 6,
            WidthRequest = 50,
            HeightRequest = 24,
            StrokeColor = Colors.White,
            StrokeWidth = 2,
            BevelType = BevelType.Bevel,
            Bevel = new SkiaBevel()
            {
                Depth = 4,
                LightColor = Colors.White,
                ShadowColor = Color.Parse("#333333"),
                Opacity = 0.33
            },
            ZIndex = 4
        };
    }

    public bool HitBoxInvalidated { get; set; }
    public bool IsActive { get; set; }

    public void ResetAnimationState()
    {
        try
        {
            this.CancelDisappearing?.Cancel();
        }
        catch
        {
        }

        Opacity = 1;
        Scale = 1;
    }

    /// <summary>
    /// Cancellation token for sprite removal animations.
    /// </summary>
    public CancellationTokenSource CancelDisappearing { get; set; }

    public async Task AnimateDisappearing()
    {
        this.CancelDisappearing?.Cancel();
        using var cancel = new CancellationTokenSource();
        CancelDisappearing = cancel;
        await FadeToAsync(0, 200, Easing.SpringOut, cancel);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (_stateUpdated != time || force)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
            HitBoxInvalidated = false;
        }
    }

    private long _stateUpdated;

    /// <summary>
    /// In POINTS
    /// </summary>
    public SKRect HitBox { get; private set; }

    /// <summary>
    /// By default it's 0 means 1 hit required to destroy
    /// </summary>
    public int SupplementaryHitsToDestroy { get; set; }

    /// <summary>
    /// By default it's false
    /// </summary>
    public bool Undestructible { get; set; }

    public BrickPreset Preset { get; set; }
}

--- C:\code\DrawnUi\src\Game\Sprites\BulletSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class BulletSprite : StableCacheLayout, IWithHitBox, IReusableSprite
{
    public static float Speed = 500f;

    public static BulletSprite Create()
    {
        return new BulletSprite
        {
            Tag = "Bullet",
            WidthRequest = BreakoutGame.PADDLE_WIDTH,
            UseCache = SkiaCacheType.Operations,
            SpeedRatio = 1,
            ZIndex = 2,
            HeightRequest = 16,
            //same as player
            HorizontalOptions = LayoutOptions.Center,
            VerticalOptions = LayoutOptions.End,
            Children =
            {
                CreateLazer(),
                CreateLazer().EndX(),
            }
        };
    }

    static SkiaShape CreateLazer()
    {
        return new SkiaShape()
        {
            WidthRequest = 5,
            CornerRadius = 2,
            BackgroundColor = Color.Parse("#ffff4444"),
            StrokeColor = Color.Parse("#ffff0000"),
            StrokeWidth = 1,
            VerticalOptions = LayoutOptions.Fill,
        };
    }

    public bool IsActive { get; set; }
    public float SpeedRatio { get; set; }

    public void ResetAnimationState()
    {
        Opacity = 1;
        Scale = 1;
    }

    public async Task AnimateDisappearing()
    {
        await FadeToAsync(0, 100);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    private long _stateUpdated;
    public SKRect HitBox { get; private set; }
}

--- C:\code\DrawnUi\src\Game\Sprites\LifeSprite.cs ---
using Breakout.Game.Input;

namespace Breakout.Game;

public class LifeSprite : SkiaShape
{
    public LifeSprite()
    {
        Margin = new Thickness(1,1,3,3);
        WidthRequest = 26;
        HeightRequest = 7.5;
        StrokeColor = Color.Parse("#CCCCFF");
        StrokeWidth = -1;
        CornerRadius = 4;
        BackgroundColor = Colors.DarkOrange;
        Children = new List<SkiaControl>()
        {
            new SkiaShape()
            {
                CornerRadius = 2,
                HorizontalOptions = LayoutOptions.Fill,
                VerticalOptions = LayoutOptions.Fill,
                BackgroundColor = AmstradColors.BrightGreen,
                Margin = new(5, 1.5),
                BevelType = BevelType.Emboss,
                Bevel = new SkiaBevel()
                {
                    Depth = 2,
                    LightColor = Colors.White,
                    ShadowColor = Color.Parse("#333333"),
                    Opacity = 0.33,
                }
            }
        };
        //Shadows = new List<SkiaShadow>()
        //{
        //    new SkiaShadow()
        //    {
        //        X = 2, Y = 2, Color = Colors.DarkBlue, Blur = 0
        //    }
        //} ;
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\PaddleSprite.cs ---
using Breakout.Game.Input;
using SkiaSharp;

namespace Breakout.Game;

public class PaddleSprite : SkiaShape, IWithHitBox //, IReusableSprite
{
    public static float Speed = BreakoutGame.PADDLE_SPEED;

    Color ColorA = Colors.DarkOrange;
    private Color ColorB = AmstradColors.BrightGreen;

    public PaddleSprite()
    {
        UseCache = SkiaCacheType.GPU;
        HeightRequest = 16;
        CornerRadius = 8;
        BackgroundColor = ColorA;
        HorizontalOptions = LayoutOptions.Center;
        VerticalOptions = LayoutOptions.End;
        Type = ShapeType.Rectangle;
        StrokeColor = Color.Parse("#CCCCFF");
        StrokeWidth = 2;
        SpeedRatio = 1;
        IsActive = true;
        BevelType = BevelType.Bevel;
        Bevel = new SkiaBevel()
        {
            Depth = 4,
            LightColor = Colors.White,
            ShadowColor = Color.Parse("#333333"),
            Opacity = 0.33,
        };
        Children = new List<SkiaControl>()
            {
                new SkiaShape()
                {
                    CornerRadius = 2,
                    HorizontalOptions = LayoutOptions.Fill,
                    VerticalOptions = LayoutOptions.Fill,
                    BackgroundColor = ColorB,
                    Margin = new(14, 3),
                    BevelType = BevelType.Emboss,
                    Bevel = new SkiaBevel()
                    {
                        Depth = 2,
                        LightColor = Colors.White,
                        ShadowColor = Color.Parse("#333333"),
                        Opacity = 0.33,
                    }
                }
            }
            ;

        ApplyPowerup(PowerupType.None);

        //Powerup = PowerupType.StickyBall;
    }

    public float Angle { get; set; }

    private PowerupType _powerup;

    public PowerupType Powerup
    {
        get { return _powerup; }
        set
        {
            if (value != _powerup)
            {
                _powerup = value;
                ApplyPowerup(value);
            }
        }
    }

    public float PowerupDuration { get; set; }

    /// <summary>
    /// Update look upon powerups
    /// </summary>
    protected void ApplyPowerup(PowerupType powerup)
    {
        //DURATION
        if (powerup == PowerupType.None)
        {
            PowerupDuration = 0;
        }
        else
        {
            PowerupDuration = BreakoutGame.POWERUP_DURATION;
        }

        // Remove incorrect speed logic - ball speed should be handled in BreakoutGame
        // SpeedRatio should remain 1 for paddle

        //SIZE
        if (Powerup == PowerupType.ExpandPaddle)
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH * 1.33;
        }
        else
        if (Powerup == PowerupType.ShrinkPaddle)
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH / 1.33;
        }
        else
        {
            WidthRequest = BreakoutGame.PADDLE_WIDTH;
        }

        //COLORS
        if (Powerup == PowerupType.Destroyer)
        {
            BackgroundColor = AmstradColors.Red;
        }
        else
        if (Powerup == PowerupType.StickyBall)
        {
            BackgroundColor = Colors.DarkCyan;
        }
        else
        {
            BackgroundColor = ColorA;
        }
    }

    public bool IsActive { get; set; }

    public static PaddleSprite Create()
    {
        return new();
    }

    public void ResetAnimationState()
    {
    }

    public async Task AnimateDisappearing()
    {
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    long _stateUpdated;
    public SKRect HitBox { get; set; }
    public float SpeedRatio { get; set; }

    public void UpdatePosition(float deltaTime)
    {
        // we are not updating it here, but in the game loop
    }
}

--- C:\code\DrawnUi\src\Game\Sprites\PowerupSprite.cs ---
using SkiaSharp;

namespace Breakout.Game;

public class PowerUpSprite : SkiaShape, IWithHitBox, IReusableSprite
{
    public static float FallSpeed = BreakoutGame.POWERUP_SPEED;

    private SkiaLabel _letterLabel;

    public static PowerUpSprite Create()
    {
        var powerup = new PowerUpSprite();
        powerup.Initialize();
        return powerup;
    }

    private void Initialize()
    {
        UseCache = SkiaCacheType.Operations;
        WidthRequest = 34;
        HeightRequest = 18;
        CornerRadius = 4;
        BackgroundColor = Colors.Purple;
        StrokeColor = Colors.White;
        StrokeWidth = 2;
        SpeedRatio = 1;
        IsActive = false;
        ZIndex = 3;

        _letterLabel = new SkiaLabel
        {
            Text = "?",
            UseCache = SkiaCacheType.Operations,
            FontSize = 10,
            TextColor = Colors.White,
            FontFamily = "FontSystem",
            HorizontalOptions = LayoutOptions.Center,
            VerticalOptions = LayoutOptions.Center
        };

        Children = new List<SkiaControl> { _letterLabel };
    }

    public PowerupType Type { get; set; }
    public bool IsActive { get; set; }
    public float SpeedRatio { get; set; }

    public void SetPowerupType(PowerupType type)
    {
        Type = type;

        // Set letter and color based on type
        switch (type)
        {
            case PowerupType.Destroyer:
                _letterLabel.Text = "A";
                BackgroundColor = Colors.Red;
                _letterLabel.TextColor = WhiteColor;
                break;
            case PowerupType.ExpandPaddle:
                _letterLabel.Text = "E";
                BackgroundColor = Colors.BlueViolet;
                _letterLabel.TextColor = WhiteColor;
                break;
            case PowerupType.StickyBall:
                _letterLabel.Text = "C";
                BackgroundColor = Colors.Cyan;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.ShrinkPaddle:
                _letterLabel.Text = "R";
                BackgroundColor = Colors.Yellow;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.SlowBall:
                _letterLabel.Text = "S";
                BackgroundColor = Colors.White;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.FastBall:
                _letterLabel.Text = "F";
                BackgroundColor = Colors.CornflowerBlue;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.MultiBall:
                _letterLabel.Text = "M";
                BackgroundColor = Colors.DarkGreen;
                _letterLabel.TextColor = Colors.White;
                break;
            case PowerupType.ExtraLife:
                _letterLabel.Text = "L";
                BackgroundColor = Colors.GreenYellow;
                _letterLabel.TextColor = BlackColor;
                break;
            case PowerupType.Fireball:
                _letterLabel.Text = "B";
                BackgroundColor = Colors.Crimson;
                _letterLabel.TextColor = WhiteColor;
                break;

            default:
                _letterLabel.Text = "?";
                BackgroundColor = Colors.White;
                _letterLabel.TextColor = BlackColor;
                break;
        }

        StrokeColor = BackgroundColor.MakeLighter(50f);
    }

    public void UpdateRotation(float deltaTime)
    {
        // Rotate the letter for visual effect
        if (_letterLabel != null)
        {
            LetterRotation += 180 * deltaTime; // Rotate 180 degrees per second
            if (LetterRotation > 360)
                LetterRotation -= 360;
        }
    }

    double LetterRotation
    {
        get { return _letterLabel.RotationX; }
        set { _letterLabel.RotationX = value; }
    }

    public void ResetAnimationState()
    {
        Opacity = 1;
        Scale = 1;
        if (_letterLabel != null)
            LetterRotation = 0;
    }

    public async Task AnimateDisappearing()
    {
        await FadeToAsync(0, 150);
    }

    public void UpdateState(long time, bool force = false)
    {
        if (force || _stateUpdated != time)
        {
            HitBox = this.GetHitBox();
            _stateUpdated = time;
        }
    }

    private long _stateUpdated;
    public SKRect HitBox { get; private set; }
}

--- C:\code\DrawnUi\src\Helpers\AppFonts.cs ---
namespace Breakout.Resources.Fonts;

public static class AppFonts
{
    /// <summary>
    /// Dialogs, default text
    /// </summary>
    public const string Default = "FontText";

    /// <summary>
    /// Score, buttons, game-style
    /// </summary>
    public const string Game = "FontGame";
    public const string GameKo = "FontGameKo";
    public const string GameZh = "FontGameZh";

    public static string GameAutoselect
    {
        get
        {
            if (!string.IsNullOrEmpty(_useGameFont))
            {
                return _useGameFont;
            }
            return Game;
        }
    }

    public static double GameAdjustSize
    {
        get
        {
            if (_adjustGameFont<=0)
            {
                return 1;
            }
            return _adjustGameFont;
        }
    }

    private static double _adjustGameFont;
    private static string _useGameFont;
    public static void UseGameFont(string value, double scale = 1.0)
    {
        _useGameFont = value;
        _adjustGameFont=scale;
    }

    public static MauiAppBuilder AddAppFonts(this MauiAppBuilder builder)
    {

        builder.ConfigureFonts(fonts =>
        {
            fonts.AddFont("ZenMaruGothic-Bold.ttf", AppFonts.Default); //dialogs
            fonts.AddFont("DelaGothicOne-Regular.ttf", AppFonts.Game); //score, buttons
            fonts.AddFont("BlackHanSans-Regular.ttf", AppFonts.GameKo);
            fonts.AddFont("MaShanZheng-Regular.ttf", AppFonts.GameZh);
            fonts.AddFont("amstrad_cpc464.ttf", "FontSystem");
        });

        return builder;
    }

}

--- C:\code\DrawnUi\src\Helpers\AppLanguage.cs ---
using AppoMobi.Specials;
using Breakout.Helpers;
using System.Globalization;

namespace Breakout.Resources.Fonts;

public static class AppLanguage
{
    /// <summary>
    /// Enabled languages
    /// </summary>
    public static List<string> EnabledLanguages = new List<string>
    {
        "en", //FIRST is fallback
        "de",
        "es",
        "fr",
        "it",
        "ru",
        "ja",
        "ko",
        "zh",
    };

    /// <summary>
    /// Applies the selected language or detects device language on first start
    /// </summary>
    public static void ApplySelected()
    {
        if (Preferences.Get("FirstStart", true) ||
            AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault) == string.Empty)
        {
            // detect the device language
            var deviceLanguage = CultureInfo.CurrentUICulture.TwoLetterISOLanguageName;

            if (!EnabledLanguages.Contains(deviceLanguage))
            {
                var fallback = EnabledLanguages.First();
                Set(fallback);
            }
            else
            {
                Set(deviceLanguage);
            }

            Preferences.Set("FirstStart", false);
        }
        else
        {
            var lang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
            Set(lang);
        }
    }

    public static void Set(string lang)
    {
        ResStrings.Culture = CultureInfo.CreateSpecificCulture(lang);
        Thread.CurrentThread.CurrentCulture = ResStrings.Culture;
        Thread.CurrentThread.CurrentUICulture = ResStrings.Culture;

        AppSettings.Set(AppSettings.Lang, lang);

        switch (lang)
        {
            case "zh":
                AppFonts.UseGameFont(AppFonts.GameZh, 1.1);
                break;
            case "ko":
                AppFonts.UseGameFont(AppFonts.GameKo, 1.1);
                break;
            default:
                AppFonts.UseGameFont(AppFonts.Game);
                break;
        }
    }

    public static void RestartWith(string lang)
    {
        Set(lang);

        MainThread.BeginInvokeOnMainThread(() => { App.Current.MainPage = new NavigationPage(new MainPage()); });
    }

    static List<KeyValuePair<string, string>> DisplayLanguages;

    public static void SetAndApply(string lang)
    {
        Set(lang);

        Super.OnFrame +=
            OnFrame; //will change language on rendering thread if different from main
    }

    private static void OnFrame(object o, EventArgs a)
    {
        Super.OnFrame -= OnFrame;
        Thread.CurrentThread.CurrentUICulture = ResStrings.Culture;

        //soft refresh
        BreakoutGame.Instance.RedrawFromOptions();

        //mimic HotReload
        //MainPage.Instance.Build(); // reload game completely as if HotReload hit
    }

    /// <summary>
    /// Cycles to the next enabled language and applies it
    /// </summary>
    public static void SelectNextAndSet()
    {
        var currentLang = AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault);
        var currentIndex = EnabledLanguages.IndexOf(currentLang);

        var nextIndex = (currentIndex + 1) % EnabledLanguages.Count;
        var nextLang = EnabledLanguages[nextIndex];

        SetAndApply(nextLang);
    }

    public static void SelectAndSet()
    {
        var languages = EnabledLanguages;
        if (languages.Count() > 2)
        {
            if (DisplayLanguages == null)
            {
                DisplayLanguages = new();
                foreach (var lang in languages)
                {
                    var culture = CultureInfo.CreateSpecificCulture(lang);
                    var title = culture.NativeName.ToTitleCase().ToTitleCase("(");
                    DisplayLanguages.Add(new(lang, title));
                }
            }

            MainThread.BeginInvokeOnMainThread(async () =>
            {
                var options = DisplayLanguages.Select(c => c.Value).ToArray();

                //block game input from keys
                BreakoutGame.Instance.Pause();

                var result =
                    await App.Current.MainPage.DisplayActionSheet(ResStrings.Language, ResStrings.BtnCancel, null,
                        options);

                BreakoutGame.Instance.Resume();

                if (!string.IsNullOrEmpty(result))
                {
                    var selectedIndex = options.FindIndex(result);
                    if (selectedIndex >= 0)
                    {
                        var lang = languages[selectedIndex];
                        if (lang != AppSettings.Get(AppSettings.Lang, AppSettings.LangDefault))
                        {
                            SetAndApply(lang);
                        }
                    }
                }
            });

        }
    }
}

--- C:\code\DrawnUi\src\Helpers\AppSettings.cs ---
namespace Breakout.Helpers;

public static class AppSettings
{
    public static readonly string Lang = "lang";
    public static readonly string LangDefault = string.Empty;

    public static readonly string MusicOn = "mus";
    public static readonly bool MusicOnDefault = true;

    public static readonly string SoundsOn = "fx";
    public static readonly bool SoundsOnDefault = true;

    public static readonly string InputPressEnabled = "press";
    public static readonly bool InputPressEnabledDefault = false;

    public static T Get<T>(string key, T defaultValue)
    {
        return Preferences.Default.Get(key, defaultValue);
    }

    public static void Set<T>(string key, T value)
    {
        Preferences.Default.Set(key, value);
    }
}

--- C:\code\DrawnUi\src\Helpers\HotPreview.cs ---
using Breakout.Game;
using DrawnUi.Views;

#if PREVIEWS

namespace Breakout.Helpers
{
    using Microsoft.Maui.ApplicationModel;
    using HotPreview;
    using HotPreview.App.Maui;
    using HotPreview.SharedModel;
    using HotPreview.SharedModel.App;
    using System;
    using System.Threading.Tasks;

    /// <summary>
    /// Customizable MauiPreviewNavigatorService
    /// </summary>
    public class PreviewService : MauiPreviewNavigatorService
    {
        /// <summary>
        /// One-line for initialization
        /// </summary>
        public static void Initialize()
        {
            MauiPreviewApplication.Instance.PreviewNavigatorService = new PreviewService();
        }

        /// <summary>
        /// Can be customized
        /// </summary>
        public static Func<INavigation> NavigateFrom = () => { return Application.Current!.MainPage!.Navigation; };

        public override Task NavigateToPreviewAsync(UIComponentReflection uiComponent, PreviewReflection preview)
        {
            return MainThread.InvokeOnMainThreadAsync(async () =>
            {
                object previewUI = preview.Create();

                if (uiComponent.Kind == UIComponentKind.Control)
                {
                    ContentPage controlsPage = new ContentPage
                    {
                        Content = (View)previewUI
                    };

                    await NavigateFrom().PushAsync(controlsPage, NavigateAnimationsEnabled);
                }
                else
                {
                    if (previewUI is RoutePreview routePreview)
                    {
                        Window mainWindow = Application.Current!.Windows[0];
                        Shell shell = mainWindow?.Page as Shell;


                        if (shell is null)
                        {
                            throw new InvalidOperationException("Main window doesn't use Shell");
                        }

                        await shell.GoToAsync(routePreview.Route, NavigateAnimationsEnabled);
                    }
                    else if (previewUI is ContentPage contentPage)
                    {
                        await NavigateFrom().PushAsync(contentPage, NavigateAnimationsEnabled);
                    }
                }
            });
        }
    }
}

#endif

--- C:\code\DrawnUi\src\Platforms\Android\MainActivity.cs ---
using Android.App;
using Android.Content.PM;
using Android.OS;

namespace Breakout;

[Activity(Theme = "@style/MainTheme", MainLauncher = true,
    LaunchMode = LaunchMode.SingleTop,
    ConfigurationChanges = ConfigChanges.ScreenSize |
                           ConfigChanges.Orientation
                           | ConfigChanges.UiMode | ConfigChanges.ScreenLayout |
                           ConfigChanges.SmallestScreenSize | ConfigChanges.Density,
    ScreenOrientation = ScreenOrientation.SensorPortrait)]

public class MainActivity : MauiAppCompatActivity
{
}

--- C:\code\DrawnUi\src\Platforms\Android\MainApplication.cs ---
using Android.App;
using Android.Runtime;

namespace Breakout;

[Application]
public class MainApplication : MauiApplication
{
        public MainApplication(IntPtr handle, JniHandleOwnership ownership)
                : base(handle, ownership)
        {
        }

        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\iOS\AppDelegate.cs ---
using Foundation;

namespace Breakout;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\iOS\Program.cs ---
using ObjCRuntime;
using UIKit;

namespace Breakout;

public class Program
{
        // This is the main entry point of the application.
        static void Main(string[] args)
        {
                // if you want to use a different Application Delegate class from "AppDelegate"
                // you can specify it here.
                UIApplication.Main(args, null, typeof(AppDelegate));
        }
}

--- C:\code\DrawnUi\src\Platforms\MacCatalyst\AppDelegate.cs ---
using Foundation;

namespace Breakout;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}

--- C:\code\DrawnUi\src\Platforms\MacCatalyst\Program.cs ---
using ObjCRuntime;
using UIKit;

namespace Breakout;

public class Program
{
        // This is the main entry point of the application.
        static void Main(string[] args)
        {
                // if you want to use a different Application Delegate class from "AppDelegate"
                // you can specify it here.
                UIApplication.Main(args, null, typeof(AppDelegate));
        }
}

--- C:\code\DrawnUi\src\Platforms\Tizen\Main.cs ---
using System;
using Microsoft.Maui;
using Microsoft.Maui.Hosting;

namespace Breakout;

class Program : MauiApplication
{
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();

        static void Main(string[] args)
        {
                var app = new Program();
                app.Run(args);
        }
}

--- C:\code\DrawnUi\src\Platforms\Windows\App.xaml.cs ---
using Microsoft.UI.Xaml;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace Breakout.WinUI;

/// <summary>
/// Provides application-specific behavior to supplement the default Application class.
/// </summary>
public partial class App : MauiWinUIApplication
{
        /// <summary>
        /// Initializes the singleton application object.  This is the first line of authored code
        /// executed, and as such is the logical equivalent of main() or WinMain().
        /// </summary>
        public App()
        {
                this.InitializeComponent();
        }

        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}


--- C:\code\DrawnUi\src\Resources\Strings\ResStrings.Designer.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Breakout.Resources.Strings {
    using System;


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class ResStrings {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ResStrings() {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Breakout.Resources.Strings.ResStrings", typeof(ResStrings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to About.
        /// </summary>
        public static string AboutApp {
            get {
                return ResourceManager.GetString("AboutApp", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Add.
        /// </summary>
        public static string Add {
            get {
                return ResourceManager.GetString("Add", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Address.
        /// </summary>
        public static string Address {
            get {
                return ResourceManager.GetString("Address", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to All.
        /// </summary>
        public static string All {
            get {
                return ResourceManager.GetString("All", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Amount.
        /// </summary>
        public static string Amount {
            get {
                return ResourceManager.GetString("Amount", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Are You sure?.
        /// </summary>
        public static string AreYouSure {
            get {
                return ResourceManager.GetString("AreYouSure", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Forgot password?.
        /// </summary>
        public static string AuthForgotPasswordQuestion {
            get {
                return ResourceManager.GetString("AuthForgotPasswordQuestion", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Login.
        /// </summary>
        public static string AuthLogin {
            get {
                return ResourceManager.GetString("AuthLogin", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Remember me.
        /// </summary>
        public static string AuthRememberMe {
            get {
                return ResourceManager.GetString("AuthRememberMe", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Balance.
        /// </summary>
        public static string Balance {
            get {
                return ResourceManager.GetString("Balance", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Birthday.
        /// </summary>
        public static string Birthday {
            get {
                return ResourceManager.GetString("Birthday", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Apply.
        /// </summary>
        public static string BtnApply {
            get {
                return ResourceManager.GetString("BtnApply", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Cancel.
        /// </summary>
        public static string BtnCancel {
            get {
                return ResourceManager.GetString("BtnCancel", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Close.
        /// </summary>
        public static string BtnClose {
            get {
                return ResourceManager.GetString("BtnClose", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Connect.
        /// </summary>
        public static string BtnConnect {
            get {
                return ResourceManager.GetString("BtnConnect", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Continue.
        /// </summary>
        public static string BtnContinue {
            get {
                return ResourceManager.GetString("BtnContinue", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Create.
        /// </summary>
        public static string BtnCreate {
            get {
                return ResourceManager.GetString("BtnCreate", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Disconnect.
        /// </summary>
        public static string BtnDisconnect {
            get {
                return ResourceManager.GetString("BtnDisconnect", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Go Back.
        /// </summary>
        public static string BtnGoBack {
            get {
                return ResourceManager.GetString("BtnGoBack", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to OK.
        /// </summary>
        public static string BtnOk {
            get {
                return ResourceManager.GetString("BtnOk", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Play Again.
        /// </summary>
        public static string BtnPlayAgain {
            get {
                return ResourceManager.GetString("BtnPlayAgain", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Ask A Question.
        /// </summary>
        public static string BtnQuestion {
            get {
                return ResourceManager.GetString("BtnQuestion", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Quit.
        /// </summary>
        public static string BtnQuit {
            get {
                return ResourceManager.GetString("BtnQuit", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Reset.
        /// </summary>
        public static string BtnReset {
            get {
                return ResourceManager.GetString("BtnReset", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Save.
        /// </summary>
        public static string BtnSave {
            get {
                return ResourceManager.GetString("BtnSave", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Share.
        /// </summary>
        public static string BtnShare {
            get {
                return ResourceManager.GetString("BtnShare", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Start.
        /// </summary>
        public static string BtnStart {
            get {
                return ResourceManager.GetString("BtnStart", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Stop.
        /// </summary>
        public static string BtnStop {
            get {
                return ResourceManager.GetString("BtnStop", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Camera.
        /// </summary>
        public static string Camera {
            get {
                return ResourceManager.GetString("Camera", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Cameras.
        /// </summary>
        public static string Cameras {
            get {
                return ResourceManager.GetString("Cameras", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Change Balance.
        /// </summary>
        public static string ChangeBalance {
            get {
                return ResourceManager.GetString("ChangeBalance", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Please confirm this action!.
        /// </summary>
        public static string ConfirmAction {
            get {
                return ResourceManager.GetString("ConfirmAction", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Confirmation Needed.
        /// </summary>
        public static string ConfirmationNeeded {
            get {
                return ResourceManager.GetString("ConfirmationNeeded", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Are you sure you want to delete this entry?.
        /// </summary>
        public static string ConfirmDelete {
            get {
                return ResourceManager.GetString("ConfirmDelete", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Dashboard.
        /// </summary>
        public static string Dashboard {
            get {
                return ResourceManager.GetString("Dashboard", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Date.
        /// </summary>
        public static string Date {
            get {
                return ResourceManager.GetString("Date", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Days.
        /// </summary>
        public static string Days {
            get {
                return ResourceManager.GetString("Days", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Delete.
        /// </summary>
        public static string Delete {
            get {
                return ResourceManager.GetString("Delete", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Delete.
        /// </summary>
        public static string Deleting {
            get {
                return ResourceManager.GetString("Deleting", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Demo.
        /// </summary>
        public static string DemoMode {
            get {
                return ResourceManager.GetString("DemoMode", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Description.
        /// </summary>
        public static string Description {
            get {
                return ResourceManager.GetString("Description", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Difficulty.
        /// </summary>
        public static string Difficulty {
            get {
                return ResourceManager.GetString("Difficulty", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Edit.
        /// </summary>
        public static string Edit {
            get {
                return ResourceManager.GetString("Edit", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Edited.
        /// </summary>
        public static string Edited {
            get {
                return ResourceManager.GetString("Edited", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Edit List.
        /// </summary>
        public static string EditList {
            get {
                return ResourceManager.GetString("EditList", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to E-mail.
        /// </summary>
        public static string Email {
            get {
                return ResourceManager.GetString("Email", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to End.
        /// </summary>
        public static string End {
            get {
                return ResourceManager.GetString("End", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Error.
        /// </summary>
        public static string Error {
            get {
                return ResourceManager.GetString("Error", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Europe.
        /// </summary>
        public static string Europe {
            get {
                return ResourceManager.GetString("Europe", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Event.
        /// </summary>
        public static string Event {
            get {
                return ResourceManager.GetString("Event", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Events.
        /// </summary>
        public static string Events {
            get {
                return ResourceManager.GetString("Events", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Filter.
        /// </summary>
        public static string Filter {
            get {
                return ResourceManager.GetString("Filter", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Filtered.
        /// </summary>
        public static string Filtered {
            get {
                return ResourceManager.GetString("Filtered", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to First Name.
        /// </summary>
        public static string FirstName {
            get {
                return ResourceManager.GetString("FirstName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Full Name.
        /// </summary>
        public static string FullName {
            get {
                return ResourceManager.GetString("FullName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Group.
        /// </summary>
        public static string Group {
            get {
                return ResourceManager.GetString("Group", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Group.
        /// </summary>
        public static string Groups {
            get {
                return ResourceManager.GetString("Groups", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to History.
        /// </summary>
        public static string History {
            get {
                return ResourceManager.GetString("History", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Home.
        /// </summary>
        public static string Home {
            get {
                return ResourceManager.GetString("Home", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to  h.
        /// </summary>
        public static string HoursShort {
            get {
                return ResourceManager.GetString("HoursShort", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Info.
        /// </summary>
        public static string Info {
            get {
                return ResourceManager.GetString("Info", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Interaction.
        /// </summary>
        public static string Interaction {
            get {
                return ResourceManager.GetString("Interaction", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Language.
        /// </summary>
        public static string Language {
            get {
                return ResourceManager.GetString("Language", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Last Name.
        /// </summary>
        public static string LastName {
            get {
                return ResourceManager.GetString("LastName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Leads.
        /// </summary>
        public static string Leads {
            get {
                return ResourceManager.GetString("Leads", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Lvl.
        /// </summary>
        public static string Lev {
            get {
                return ResourceManager.GetString("Lev", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Level.
        /// </summary>
        public static string Level {
            get {
                return ResourceManager.GetString("Level", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Lives.
        /// </summary>
        public static string Lives {
            get {
                return ResourceManager.GetString("Lives", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Log Out.
        /// </summary>
        public static string LogOut {
            get {
                return ResourceManager.GetString("LogOut", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Manager.
        /// </summary>
        public static string Manager {
            get {
                return ResourceManager.GetString("Manager", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Managers.
        /// </summary>
        public static string Managers {
            get {
                return ResourceManager.GetString("Managers", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to 🎉 Amazing! You&apos;ve conquered all levels! 🎉
        ///Final Score: {0}
        ///You&apos;re a Breakout Master!.
        /// </summary>
        public static string MessageGameComplete {
            get {
                return ResourceManager.GetString("MessageGameComplete", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to 😔 Game Over! 💔
        ///Final Score: {0}
        ///Ready for another round?.
        /// </summary>
        public static string MessageGameOver {
            get {
                return ResourceManager.GetString("MessageGameOver", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to 🎯 Level {0} Complete! 🎉
        ///Score: {1}
        ///Get ready for Level {2}!.
        /// </summary>
        public static string MessageLevelComplete {
            get {
                return ResourceManager.GetString("MessageLevelComplete", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to 💥 Welcome to Bricks Breaker! 🏓
        ///🏆 Smash all bricks, victory awaits!.
        /// </summary>
        public static string MessageWelcome {
            get {
                return ResourceManager.GetString("MessageWelcome", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to 💥 Welcome to Bricks Breaker! 🏓
        ///Use mouse/keyboard to control.
        ///🏆 Smash all bricks, victory awaits!.
        /// </summary>
        public static string MessageWelcomeDesktop {
            get {
                return ResourceManager.GetString("MessageWelcomeDesktop", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Messenger.
        /// </summary>
        public static string Messenger {
            get {
                return ResourceManager.GetString("Messenger", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Middle Name.
        /// </summary>
        public static string MiddleName {
            get {
                return ResourceManager.GetString("MiddleName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Music.
        /// </summary>
        public static string Music {
            get {
                return ResourceManager.GetString("Music", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to My Profile.
        /// </summary>
        public static string MyProfile {
            get {
                return ResourceManager.GetString("MyProfile", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Name.
        /// </summary>
        public static string Name {
            get {
                return ResourceManager.GetString("Name", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to New Game.
        /// </summary>
        public static string NewGame {
            get {
                return ResourceManager.GetString("NewGame", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to No.
        /// </summary>
        public static string No {
            get {
                return ResourceManager.GetString("No", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to None.
        /// </summary>
        public static string None {
            get {
                return ResourceManager.GetString("None", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Unallowed.
        /// </summary>
        public static string NoRights {
            get {
                return ResourceManager.GetString("NoRights", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Notes.
        /// </summary>
        public static string Notes {
            get {
                return ResourceManager.GetString("Notes", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Off.
        /// </summary>
        public static string Off {
            get {
                return ResourceManager.GetString("Off", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Office.
        /// </summary>
        public static string Office {
            get {
                return ResourceManager.GetString("Office", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Offices.
        /// </summary>
        public static string Offices {
            get {
                return ResourceManager.GetString("Offices", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to On.
        /// </summary>
        public static string On {
            get {
                return ResourceManager.GetString("On", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Options.
        /// </summary>
        public static string Options {
            get {
                return ResourceManager.GetString("Options", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Order.
        /// </summary>
        public static string Order {
            get {
                return ResourceManager.GetString("Order", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Order.
        /// </summary>
        public static string OrderBy {
            get {
                return ResourceManager.GetString("OrderBy", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Newer first.
        /// </summary>
        public static string OrderNewFirst {
            get {
                return ResourceManager.GetString("OrderNewFirst", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Older first.
        /// </summary>
        public static string OrderOldFirst {
            get {
                return ResourceManager.GetString("OrderOldFirst", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Orders.
        /// </summary>
        public static string Orders {
            get {
                return ResourceManager.GetString("Orders", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Delivered to client.
        /// </summary>
        public static string OrderStatus_Issued {
            get {
                return ResourceManager.GetString("OrderStatus_Issued", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Processing.
        /// </summary>
        public static string OrderStatus_Received {
            get {
                return ResourceManager.GetString("OrderStatus_Received", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Sent to office.
        /// </summary>
        public static string OrderStatus_Sent {
            get {
                return ResourceManager.GetString("OrderStatus_Sent", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Password.
        /// </summary>
        public static string Password {
            get {
                return ResourceManager.GetString("Password", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Past Due.
        /// </summary>
        public static string PastDue {
            get {
                return ResourceManager.GetString("PastDue", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Phone.
        /// </summary>
        public static string PhoneNumber {
            get {
                return ResourceManager.GetString("PhoneNumber", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Press Back once again to exit...
        /// </summary>
        public static string PressBACKOnceAgain {
            get {
                return ResourceManager.GetString("PressBACKOnceAgain", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Press HUD.
        /// </summary>
        public static string PressHud {
            get {
                return ResourceManager.GetString("PressHud", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Press Mode.
        /// </summary>
        public static string PressMode {
            get {
                return ResourceManager.GetString("PressMode", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Price.
        /// </summary>
        public static string Price {
            get {
                return ResourceManager.GetString("Price", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Product.
        /// </summary>
        public static string Product {
            get {
                return ResourceManager.GetString("Product", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Products.
        /// </summary>
        public static string Products {
            get {
                return ResourceManager.GetString("Products", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Push.
        /// </summary>
        public static string Push {
            get {
                return ResourceManager.GetString("Push", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Pushes.
        /// </summary>
        public static string Pushes {
            get {
                return ResourceManager.GetString("Pushes", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Quantity.
        /// </summary>
        public static string Quantity {
            get {
                return ResourceManager.GetString("Quantity", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Region.
        /// </summary>
        public static string Region {
            get {
                return ResourceManager.GetString("Region", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Regions.
        /// </summary>
        public static string Regions {
            get {
                return ResourceManager.GetString("Regions", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Remove.
        /// </summary>
        public static string Remove {
            get {
                return ResourceManager.GetString("Remove", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Request.
        /// </summary>
        public static string Request {
            get {
                return ResourceManager.GetString("Request", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Requests.
        /// </summary>
        public static string Requests {
            get {
                return ResourceManager.GetString("Requests", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Reset Password.
        /// </summary>
        public static string ResetPassword {
            get {
                return ResourceManager.GetString("ResetPassword", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Rows per page.
        /// </summary>
        public static string RowsPerPage {
            get {
                return ResourceManager.GetString("RowsPerPage", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Score.
        /// </summary>
        public static string Score {
            get {
                return ResourceManager.GetString("Score", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Search.
        /// </summary>
        public static string Search {
            get {
                return ResourceManager.GetString("Search", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Select.
        /// </summary>
        public static string Select {
            get {
                return ResourceManager.GetString("Select", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Shop.
        /// </summary>
        public static string Shop {
            get {
                return ResourceManager.GetString("Shop", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Sounds.
        /// </summary>
        public static string Sounds {
            get {
                return ResourceManager.GetString("Sounds", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Start.
        /// </summary>
        public static string Start {
            get {
                return ResourceManager.GetString("Start", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Start Game.
        /// </summary>
        public static string StartGame {
            get {
                return ResourceManager.GetString("StartGame", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Paused.
        /// </summary>
        public static string StatePaused {
            get {
                return ResourceManager.GetString("StatePaused", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Status.
        /// </summary>
        public static string Status {
            get {
                return ResourceManager.GetString("Status", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Other.
        /// </summary>
        public static string StudyPlanType_Other {
            get {
                return ResourceManager.GetString("StudyPlanType_Other", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Success!.
        /// </summary>
        public static string Success {
            get {
                return ResourceManager.GetString("Success", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to System Settings.
        /// </summary>
        public static string SystemSettings {
            get {
                return ResourceManager.GetString("SystemSettings", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Teacher.
        /// </summary>
        public static string Teacher {
            get {
                return ResourceManager.GetString("Teacher", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Teachers.
        /// </summary>
        public static string Teachers {
            get {
                return ResourceManager.GetString("Teachers", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Text.
        /// </summary>
        public static string Text {
            get {
                return ResourceManager.GetString("Text", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Time.
        /// </summary>
        public static string Time {
            get {
                return ResourceManager.GetString("Time", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Title.
        /// </summary>
        public static string Title {
            get {
                return ResourceManager.GetString("Title", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Admin Panel.
        /// </summary>
        public static string TitleDesk {
            get {
                return ResourceManager.GetString("TitleDesk", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Translation.
        /// </summary>
        public static string Translation {
            get {
                return ResourceManager.GetString("Translation", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Type.
        /// </summary>
        public static string Type {
            get {
                return ResourceManager.GetString("Type", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Unset.
        /// </summary>
        public static string Unset {
            get {
                return ResourceManager.GetString("Unset", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to User.
        /// </summary>
        public static string User {
            get {
                return ResourceManager.GetString("User", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Username.
        /// </summary>
        public static string UserName {
            get {
                return ResourceManager.GetString("UserName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Users.
        /// </summary>
        public static string Users {
            get {
                return ResourceManager.GetString("Users", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to {0} field not filled.
        /// </summary>
        public static string ValidationFieldRequired {
            get {
                return ResourceManager.GetString("ValidationFieldRequired", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Required field.
        /// </summary>
        public static string ValidationRequired {
            get {
                return ResourceManager.GetString("ValidationRequired", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Demo.
        /// </summary>
        public static string VendorTitle {
            get {
                return ResourceManager.GetString("VendorTitle", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Version.
        /// </summary>
        public static string Version {
            get {
                return ResourceManager.GetString("Version", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Welcome.
        /// </summary>
        public static string Welcome {
            get {
                return ResourceManager.GetString("Welcome", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Word.
        /// </summary>
        public static string Word {
            get {
                return ResourceManager.GetString("Word", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Words.
        /// </summary>
        public static string Words {
            get {
                return ResourceManager.GetString("Words", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Wrong username or password.
        /// </summary>
        public static string WrongPassword {
            get {
                return ResourceManager.GetString("WrongPassword", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Yes.
        /// </summary>
        public static string Yes {
            get {
                return ResourceManager.GetString("Yes", resourceCulture);
            }
        }
    }
}

=== feature FILES ===
2025-08-21 08:42:14
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:45:23
Unlink of file 'scripts/PowerShell.txt' failed. Should I try again? (y/n) n
warning: failed to remove scripts/PowerShell.txt: Invalid argument
Get-Content: C:\code\DrawnUi\scripts\cat.ps1:27
Line |
  27 |      Get-Content Dockerfile
     |      ~~~~~~~~~~~~~~~~~~~~~~
     | Cannot find path 'C:\code\DrawnUi\Dockerfile' because it does not exist.
Get-Content: C:\code\DrawnUi\scripts\cat.ps1:30
Line |
  30 |      Get-Content *.props
     |      ~~~~~~~~~~~~~~~~~~~
     | An object at the specified path *.props does not exist, or has been filtered by the -Include or -Exclude parameter.
Get-Content: C:\code\DrawnUi\scripts\cat.ps1:33
Line |
  33 |      Get-Content .github\workflows\*.yml
     |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Cannot find path 'C:\code\DrawnUi\.github\workflows' because it does not exist.
Script output has been saved to C:\code\DrawnUi\scripts\PowerShell.txt
2025-08-21 08:45:33
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:47:11
Script output has been saved to C:\code\DrawnUi\scripts\PowerShell.txt
2025-08-21 08:47:12
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:49:34
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\PowerShell.txt
Script output has been saved to C:\code\DrawnUi\scripts\PowerShell.txt
2025-08-21 08:49:36
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:50:02
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\source-code.txt
Script output has been saved to C:\code\DrawnUi\scripts\source-code.txt
2025-08-21 08:50:03
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:50:23
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 08:50:24
PS C:\code\DrawnUi> git remote rename origin upstream
Renaming remote references: 100% (6/6), done.
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 08:52:09
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 08:52:10
PS C:\code\DrawnUi> git remote add origin git@github.com:kusl/DrawnUi.git
PS C:\code\DrawnUi> git push origin --all
Enumerating objects: 1472, done.
Counting objects: 100% (1472/1472), done.
Delta compression using up to 10 threads
Compressing objects: 100% (523/523), done.
Writing objects: 100% (1472/1472), 40.11 MiB | 24.80 MiB/s, done.
Total 1472 (delta 940), reused 1461 (delta 936), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (940/940), done.
To github.com:kusl/DrawnUi.git
 * [new branch]      main -> main
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:16:04
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:16:05
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:16:05
[main 7cad254] add all files
 2 files changed, 19 insertions(+), 3 deletions(-)
2025-08-21 09:16:05
Enumerating objects: 18, done.
Counting objects: 100% (18/18), done.
Delta compression using up to 10 threads
Compressing objects: 100% (13/13), done.
Writing objects: 100% (14/14), 6.04 KiB | 687.00 KiB/s, done.
Total 14 (delta 4), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (4/4), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   bee1c42..7cad254  main -> main
2025-08-21 09:16:06
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:17:19
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:17:20
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:17:21
[main 4fad8e1] add all files
 1 file changed, 1 insertion(+), 2 deletions(-)
2025-08-21 09:17:21
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 398 bytes | 132.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   7cad254..4fad8e1  main -> main
2025-08-21 09:17:22
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:17:50
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:17:52
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:17:52
[main 98a81b9] add all files
 1 file changed, 1 insertion(+), 1 deletion(-)
2025-08-21 09:17:52
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 393 bytes | 131.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   4fad8e1..98a81b9  main -> main
2025-08-21 09:17:53
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:23:05
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:23:07
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:23:07
[main 068e805] add all files
 1 file changed, 1 insertion(+), 1 deletion(-)
2025-08-21 09:23:07
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 10 threads
Compressing objects: 100% (9/9), done.
Writing objects: 100% (10/10), 1.59 KiB | 272.00 KiB/s, done.
Total 10 (delta 5), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (5/5), completed with 4 local objects.
To github.com:kusl/DrawnUi.git
   98a81b9..068e805  main -> main
2025-08-21 09:23:08
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:29:04
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:29:05
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:29:05
[main 1c9291b] add all files
 1 file changed, 1 insertion(+), 1 deletion(-)
2025-08-21 09:29:06
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 396 bytes | 132.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   068e805..1c9291b  main -> main
2025-08-21 09:29:07
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 09:31:56
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 09:31:58
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 09:31:58
[main 14e7b21] add all files
 3 files changed, 483 insertions(+), 257 deletions(-)
2025-08-21 09:31:58
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 10 threads
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 4.23 KiB | 618.00 KiB/s, done.
Total 9 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   1c9291b..14e7b21  main -> main
2025-08-21 09:31:59
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 10:46:43
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 10:46:45
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 10:46:45
[main 47bff3c] add all files
 2 files changed, 105 insertions(+), 12371 deletions(-)
2025-08-21 10:46:45
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 10 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1.57 KiB | 201.00 KiB/s, done.
Total 5 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   14e7b21..47bff3c  main -> main
2025-08-21 10:46:46
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 10:53:28
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 10:53:29
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 10:53:29
[main 30954b6] add all files
 1 file changed, 441 insertions(+), 34 deletions(-)
2025-08-21 10:53:29
Enumerating objects: 23, done.
Counting objects: 100% (23/23), done.
Delta compression using up to 10 threads
Compressing objects: 100% (14/14), done.
Writing objects: 100% (14/14), 5.33 KiB | 454.00 KiB/s, done.
Total 14 (delta 7), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (7/7), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   47bff3c..30954b6  main -> main
2025-08-21 10:53:30
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 10:55:32
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 10:55:33
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 10:55:33
[main a218a7e] add all files
 2 files changed, 11 insertions(+), 1 deletion(-)
2025-08-21 10:55:34
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 10 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 580 bytes | 145.00 KiB/s, done.
Total 5 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   30954b6..a218a7e  main -> main
2025-08-21 10:55:35
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 11:09:41
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 11:09:42
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 11:09:42
[main 87c187d] add all files
 7 files changed, 965 insertions(+), 133 deletions(-)
 create mode 100644 .github/workflows/debug-workloads.yml
2025-08-21 11:09:43
Enumerating objects: 28, done.
Counting objects: 100% (28/28), done.
Delta compression using up to 10 threads
Compressing objects: 100% (17/17), done.
Writing objects: 100% (17/17), 4.49 KiB | 353.00 KiB/s, done.
Total 17 (delta 8), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (8/8), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   a218a7e..87c187d  main -> main
2025-08-21 11:09:44
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 11:12:42
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 11:12:44
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 11:12:44
[main 4dcf7fa] add all files
 1 file changed, 2 insertions(+), 11 deletions(-)
2025-08-21 11:12:44
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 402 bytes | 134.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   87c187d..4dcf7fa  main -> main
2025-08-21 11:12:45
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 12:21:03
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 12:21:05
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 12:21:05
[main 8a9bcb4] add all files
 1 file changed, 188 insertions(+), 151 deletions(-)
2025-08-21 12:21:05
Enumerating objects: 26, done.
Counting objects: 100% (26/26), done.
Delta compression using up to 10 threads
Compressing objects: 100% (15/15), done.
Writing objects: 100% (15/15), 9.99 KiB | 487.00 KiB/s, done.
Total 15 (delta 9), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (9/9), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   4dcf7fa..8a9bcb4  main -> main
2025-08-21 12:21:06
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 12:26:15
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 12:26:16
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 12:26:16
[main 68ca96e] add all files
 1 file changed, 2 insertions(+), 2 deletions(-)
2025-08-21 12:26:17
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 392 bytes | 130.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   8a9bcb4..68ca96e  main -> main
2025-08-21 12:26:18
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 12:39:31
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 12:39:32
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 12:39:33
[main 8b05f31] add all files
 1 file changed, 1 insertion(+), 1 deletion(-)
2025-08-21 12:39:33
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 376 bytes | 125.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   68ca96e..8b05f31  main -> main
2025-08-21 12:39:34
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 12:54:12
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 12:54:14
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 12:54:14
[main 5ad4937] add all files
 2 files changed, 3 insertions(+), 1912 deletions(-)
2025-08-21 12:54:14
Enumerating objects: 11, done.
Counting objects: 100% (11/11), done.
Delta compression using up to 10 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 908 bytes | 227.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   8b05f31..5ad4937  main -> main
2025-08-21 12:54:15
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:04:53
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:04:55
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:04:55
[main d081316] add all files
 1 file changed, 5 insertions(+), 4 deletions(-)
2025-08-21 13:04:55
Enumerating objects: 21, done.
Counting objects: 100% (21/21), done.
Delta compression using up to 10 threads
Compressing objects: 100% (12/12), done.
Writing objects: 100% (12/12), 7.25 KiB | 742.00 KiB/s, done.
Total 12 (delta 7), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (7/7), completed with 4 local objects.
To github.com:kusl/DrawnUi.git
   5ad4937..d081316  main -> main
2025-08-21 13:04:56
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:15:17
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:15:18
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:15:18
[main db28f6b] add all files
 2 files changed, 17 insertions(+), 1917 deletions(-)
2025-08-21 13:15:19
Enumerating objects: 11, done.
Counting objects: 100% (11/11), done.
Delta compression using up to 10 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 891 bytes | 222.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   d081316..db28f6b  main -> main
2025-08-21 13:15:19
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:18:08
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:18:09
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:18:09
[main d30f982] add all files
 2 files changed, 1432 insertions(+), 1 deletion(-)
2025-08-21 13:18:10
Enumerating objects: 11, done.
Counting objects: 100% (11/11), done.
Delta compression using up to 10 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 2.74 KiB | 350.00 KiB/s, done.
Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   db28f6b..d30f982  main -> main
2025-08-21 13:18:11
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:23:40
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:23:42
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:23:42
[main 9d598cf] add all files
 1 file changed, 591 insertions(+), 83 deletions(-)
2025-08-21 13:23:42
Enumerating objects: 26, done.
Counting objects: 100% (26/26), done.
Delta compression using up to 10 threads
Compressing objects: 100% (18/18), done.
Writing objects: 100% (18/18), 10.80 KiB | 614.00 KiB/s, done.
Total 18 (delta 9), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (9/9), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   d30f982..9d598cf  main -> main
2025-08-21 13:23:43
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:37:02
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:37:05
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:37:05
[main e6a4bfc] add all files
 2 files changed, 12369 insertions(+), 7 deletions(-)
2025-08-21 13:37:06
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 10 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 76.37 KiB | 2.83 MiB/s, done.
Total 5 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:kusl/DrawnUi.git
   9d598cf..e6a4bfc  main -> main
2025-08-21 13:37:07
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
2025-08-21 13:39:09
Script directory: C:\code\DrawnUi\scripts
Parent directory: C:\code\DrawnUi
Output file: C:\code\DrawnUi\scripts\llm-input.txt
Script output has been saved to C:\code\DrawnUi\scripts\llm-input.txt
2025-08-21 13:39:11
warning: in the working copy of 'scripts/llm-input.txt', LF will be replaced by CRLF the next time Git touches it
2025-08-21 13:39:12
[main 463d4ab] add all files
 3 files changed, 415 insertions(+), 32 deletions(-)
 create mode 100644 .github/workflows/android-build.yml
2025-08-21 13:39:12
Enumerating objects: 16, done.
Counting objects: 100% (16/16), done.
Delta compression using up to 10 threads
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 5.39 KiB | 368.00 KiB/s, done.
Total 9 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To github.com:kusl/DrawnUi.git
   e6a4bfc..463d4ab  main -> main
2025-08-21 13:39:13
PS C:\code\DrawnUi> C:\code\DrawnUi\scripts\cat.ps1
